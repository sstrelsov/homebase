{"version":3,"file":"static/js/320.0355ebdc.chunk.js","mappings":"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","sources":["webpack://homebase/./src/css/typewriter.module.css?13c8","components/Typewriter.tsx","store/hooks.ts","components/earth/utils/tripMath.ts","components/earth/utils/trips.ts","components/earth/utils/arcs.ts","components/earth/layers/arcs/AllArcsStaticMesh.tsx","components/earth/layers/arcs/LandingEffect.tsx","components/earth/layers/arcs/Arc.tsx","components/earth/layers/arcs/ArcGroup.tsx","components/earth/utils/AtmosphereShader.ts","components/earth/layers/Atmosphere.tsx","components/earth/layers/BaseSphere.tsx","components/earth/layers/helpers/CityMarker.tsx","components/earth/layers/CityMarkerGroup.tsx","components/earth/utils/earthMath.ts","components/earth/layers/ContinentDots.tsx","components/earth/layers/Globe.tsx","components/earth/layers/ManualBlooms.tsx","components/earth/SceneHelpers.tsx","components/earth/EarthScene.tsx","projects/globe-project/CountryButtons.tsx","projects/globe-project/TheGlobeProjects.tsx","pages/project-details/ProjectDetails.tsx","utils/useAtOrAboveBreakpoint.ts"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport default {\"blink\":\"typewriter_blink__KoZUv\"};","import { useEffect, useState } from \"react\";\nimport styles from \"../css/typewriter.module.css\";\nimport { useLinkColor } from \"../utils/ColorContext\";\n\ninterface TypewriterProps {\n  phrases: string[];\n  period?: number;\n  typingSpeed: number;\n  deletingSpeed: number;\n  loop?: boolean;\n  preserveTrailingNewlines?: boolean;\n}\n\nfunction findPrefixOverlap(a: string, b: string): number {\n  let i = 0;\n  while (i < a.length && i < b.length && a[i] === b[i]) {\n    i++;\n  }\n  return i;\n}\n\nfunction preserveTrailingNewlinesInOverlap(\n  currentPhrase: string,\n  rawOverlapLength: number\n) {\n  if (rawOverlapLength >= currentPhrase.length) return rawOverlapLength;\n  const leftover = currentPhrase.slice(rawOverlapLength);\n  if (/^[\\n\\s]+$/.test(leftover)) {\n    return currentPhrase.length;\n  }\n  return rawOverlapLength;\n}\n\nconst Typewriter = ({\n  phrases,\n  period = 2000,\n  typingSpeed,\n  deletingSpeed,\n  loop = true,\n  preserveTrailingNewlines = false,\n}: TypewriterProps) => {\n  const [phase, setPhase] = useState<\"typing\" | \"deleting\" | \"pause\">(\"typing\");\n  const [index, setIndex] = useState(0);\n  const [charIndex, setCharIndex] = useState(0);\n\n  const { linkColor } = useLinkColor();\n\n  // Whenever phrases changes, reset the typewriter\n  useEffect(() => {\n    setPhase(\"typing\");\n    setIndex(0);\n    setCharIndex(0);\n  }, [phrases]);\n\n  const isLastPhrase = !loop && index === phrases.length - 1;\n\n  const currentPhrase = phrases[index] ?? \"\";\n  const nextPhrase = isLastPhrase ? \"\" : phrases[(index + 1) % phrases.length];\n\n  let overlapLength = findPrefixOverlap(currentPhrase, nextPhrase);\n  if (preserveTrailingNewlines) {\n    overlapLength = preserveTrailingNewlinesInOverlap(\n      currentPhrase,\n      overlapLength\n    );\n  }\n\n  useEffect(() => {\n    if (phase === \"typing\") {\n      if (charIndex < currentPhrase.length) {\n        // Slow down for newlines / periods\n        const nextChar = currentPhrase[charIndex];\n        let currentTypingSpeed = typingSpeed;\n        if (nextChar === \".\" || nextChar === \"\\n\") {\n          currentTypingSpeed *= 2;\n        }\n\n        const timeoutId = setTimeout(() => {\n          setCharIndex((c) => c + 1);\n        }, currentTypingSpeed);\n        return () => clearTimeout(timeoutId);\n      } else {\n        // Done typing; pause\n        const pauseId = setTimeout(() => {\n          setPhase(\"pause\");\n        }, period);\n        return () => clearTimeout(pauseId);\n      }\n    } else if (phase === \"pause\") {\n      if (isLastPhrase) return;\n      setPhase(\"deleting\");\n    } else if (phase === \"deleting\") {\n      if (charIndex > overlapLength) {\n        // Slow down for newlines / periods\n        const prevChar = currentPhrase[charIndex - 1];\n        let currentDeletingSpeed = deletingSpeed;\n        if (prevChar === \".\" || prevChar === \"\\n\") {\n          currentDeletingSpeed *= 2;\n        }\n\n        const timeoutId = setTimeout(() => {\n          setCharIndex((c) => c - 1);\n        }, currentDeletingSpeed);\n        return () => clearTimeout(timeoutId);\n      } else {\n        // If looping, move on; otherwise just end\n        setIndex((i) => (loop ? (i + 1) % phrases.length : i + 1));\n        setPhase(\"typing\");\n      }\n    }\n  }, [\n    phase,\n    charIndex,\n    currentPhrase,\n    overlapLength,\n    period,\n    typingSpeed,\n    deletingSpeed,\n    index,\n    nextPhrase,\n    isLastPhrase,\n    loop,\n    phrases.length,\n  ]);\n\n  const display = currentPhrase.slice(0, charIndex);\n\n  function renderWithLineBreaks(text: string) {\n    return text.split(\"\\n\").map((segment, i, arr) => (\n      <span key={i}>\n        {segment}\n        {i < arr.length - 1 && <br />}\n      </span>\n    ));\n  }\n\n  return (\n    <div>\n      {renderWithLineBreaks(display)}\n      <span\n        className={`border-r-[2.5px] solid ml-[1.8px] ${styles.blink}`}\n        style={{ borderColor: linkColor }}\n      />\n    </div>\n  );\n};\n\nexport default Typewriter;\n","import { TypedUseSelectorHook, useDispatch, useSelector } from \"react-redux\";\nimport type { AppDispatch, RootState } from \"./store\";\n\n// Use throughout your app instead of plain `useDispatch` and `useSelector`\nexport const useAppDispatch = () => useDispatch<AppDispatch>();\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;\n","import { ArcLocation, CityLocation, Trip } from \"../../../types/earthTypes\";\n\nexport function getArcsFromTrip(trip: Trip): ArcLocation[] {\n  const arcs: ArcLocation[] = [];\n  const legs = trip.legs; // an array of CityLocation\n\n  for (let i = 0; i < legs.length - 1; i++) {\n    arcs.push({\n      start: legs[i],\n      end: legs[i + 1],\n    });\n  }\n  return arcs;\n}\n\n/**\n * Converts an ordered list of city stops [C0, C1, C2, ... Cn]\n * into [Arc(C0->C1), Arc(C1->C2), ..., Arc(Cn-1->Cn)].\n */\nexport function getArcsFromLegs(legs: CityLocation[]): ArcLocation[] {\n  const arcs: ArcLocation[] = [];\n  for (let i = 0; i < legs.length - 1; i++) {\n    arcs.push({\n      start: legs[i],\n      end: legs[i + 1],\n    });\n  }\n  return arcs;\n}\n\n/**\n * Flatten arcs from all trips into a single array.\n */\nexport function flattenAllTrips(trips: Trip[]): ArcLocation[] {\n  return trips.flatMap((trip) => getArcsFromLegs(trip.legs));\n}\n\n/**\n * Each arc has start + end city.\n * We want to produce [Arc0.start, Arc0.end, Arc1.end, Arc2.end, ...].\n */\nexport function getArcCities(arcs: ArcLocation[]): CityLocation[] {\n  if (arcs.length === 0) return [];\n\n  const cities: CityLocation[] = [];\n  // Push the first arc's start city\n  cities.push(arcs[0].start);\n\n  // Then for each arc, push the end city\n  for (let i = 0; i < arcs.length; i++) {\n    cities.push(arcs[i].end);\n  }\n\n  return cities;\n}\n\nexport function flattenAllIsos(trips: Trip[]): string[] {\n  return Array.from(new Set(trips.flatMap((trip) => trip.countries ?? [])));\n}\n\n/**\n * Example stats: totalMiles, distinctCities, countries, etc.\n */\nexport interface TripStats {\n  numberOfDistinctCities: number;\n  totalMiles: number;\n  countriesVisited: string[];\n  continentsVisited: string[];\n}\n\nexport function getTripStats(\n  trip: Trip,\n  isoToContinent?: Record<string, string>\n): TripStats {\n  // Distinct city names\n  const distinctCities = new Set<string>();\n  trip.legs.forEach((city) => {\n    if (city.name) distinctCities.add(city.name);\n  });\n\n  // Summation of distances between consecutive legs\n  let totalMiles = 0;\n  for (let i = 0; i < trip.legs.length - 1; i++) {\n    const start = trip.legs[i];\n    const end = trip.legs[i + 1];\n    totalMiles += haversineMiles(start.lat, start.lon, end.lat, end.lon);\n  }\n\n  // Countries visited\n  const countriesVisited = trip.countries ?? [];\n\n  // Continents visited (optional)\n  let continentsVisited: string[] = [];\n  if (isoToContinent) {\n    const contSet = new Set<string>();\n    for (const iso of countriesVisited) {\n      const continent = isoToContinent[iso];\n      if (continent) {\n        contSet.add(continent);\n      }\n    }\n    continentsVisited = Array.from(contSet);\n  }\n\n  return {\n    numberOfDistinctCities: distinctCities.size,\n    totalMiles,\n    countriesVisited,\n    continentsVisited,\n  };\n}\n\nfunction haversineMiles(\n  lat1: number,\n  lon1: number,\n  lat2: number,\n  lon2: number\n) {\n  const R = 3958.8; // Earth radius in miles\n  const dLat = toRad(lat2 - lat1);\n  const dLon = toRad(lon2 - lon1);\n  const a =\n    Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n    Math.cos(toRad(lat1)) *\n      Math.cos(toRad(lat2)) *\n      Math.sin(dLon / 2) *\n      Math.sin(dLon / 2);\n\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  return R * c;\n}\nfunction toRad(value: number) {\n  return (value * Math.PI) / 180;\n}\n","import { Trip } from \"../../../types/earthTypes\";\n\nexport const trips: Trip[] = [\n  {\n    id: \"nyc-dallas\",\n    title: \"NYC → Dallas\",\n    description: \"A short trip to Dallas to escape the winter cold.\",\n    startDate: \"2021-01-05\",\n    endDate: \"2021-01-10\",\n    images: [\n      \"https://example.com/dallas1.jpg\",\n      \"https://example.com/dallas2.jpg\",\n    ],\n    countries: [\"USA\"],\n    legs: [\n      { lat: 40.7128, lon: -74.006, name: \"New York City\", iso: \"USA\" },\n      { lat: 32.7767, lon: -96.797, name: \"Dallas\", iso: \"USA\" },\n    ],\n  },\n  {\n    id: \"nyc-sf\",\n    title: \"NYC → San Francisco\",\n    description: \"Coast-to-coast weekend getaway.\",\n    startDate: \"2021-02-10\",\n    endDate: \"2021-02-15\",\n    images: [\"https://example.com/sf1.jpg\", \"https://example.com/sf2.jpg\"],\n    countries: [\"USA\"],\n    legs: [\n      { lat: 40.7128, lon: -74.006, name: \"New York City\", iso: \"USA\" },\n      { lat: 37.7749, lon: -122.4194, name: \"San Francisco\", iso: \"USA\" },\n    ],\n  },\n  {\n    id: \"nyc-louisville-1\",\n    title: \"NYC → Louisville\",\n    description: \"A quick trip for bourbon and horse racing.\",\n    startDate: \"2021-03-05\",\n    endDate: \"2021-03-10\",\n    images: [\"https://example.com/louisville1.jpg\"],\n    countries: [\"USA\"],\n    legs: [\n      { lat: 40.7128, lon: -74.006, name: \"New York City\", iso: \"USA\" },\n      { lat: 38.2527, lon: -85.7585, name: \"Louisville\", iso: \"USA\" },\n    ],\n  },\n  {\n    id: \"nyc-seattle\",\n    title: \"NYC → Seattle\",\n    description: \"Coffee and rain in the Pacific Northwest.\",\n    startDate: \"2021-04-01\",\n    endDate: \"2021-04-07\",\n    images: [],\n    countries: [\"USA\"],\n    legs: [\n      { lat: 40.7128, lon: -74.006, name: \"New York City\", iso: \"USA\" },\n      { lat: 47.6062, lon: -122.3321, name: \"Seattle\", iso: \"USA\" },\n    ],\n  },\n  {\n    id: \"nyc-bogota-cumaral-cartagena\",\n    title: \"NYC → Bogota → Cumaral → Cartagena\",\n    description:\n      \"Exploring Colombia, from the capital to the countryside to the coast.\",\n    startDate: \"2021-05-10\",\n    endDate: \"2021-05-25\",\n    images: [\n      \"https://example.com/bogota.jpg\",\n      \"https://example.com/cartagena.jpg\",\n    ],\n    countries: [\"COL\"],\n    legs: [\n      { lat: 40.7128, lon: -74.006, name: \"New York City\", iso: \"USA\" },\n      { lat: 4.711, lon: -74.0721, name: \"Bogota\", iso: \"COL\" },\n      { lat: 4.2702, lon: -73.4772, name: \"Cumaral\", iso: \"COL\" },\n      { lat: 10.391, lon: -75.4794, name: \"Cartagena\", iso: \"COL\" },\n    ],\n  },\n  {\n    id: \"nyc-destin\",\n    title: \"NYC → Destin\",\n    description: \"Relaxing on the Emerald Coast.\",\n    startDate: \"2021-06-01\",\n    endDate: \"2021-06-05\",\n    images: [\"https://example.com/destin.jpg\"],\n    countries: [\"USA\"],\n    legs: [\n      { lat: 40.7128, lon: -74.006, name: \"New York City\", iso: \"USA\" },\n      { lat: 30.3935, lon: -86.4958, name: \"Destin\", iso: \"USA\" },\n    ],\n  },\n  {\n    id: \"nyc-sanjose\",\n    title: \"NYC → San Jose, CA\",\n    description: \"Visiting Silicon Valley.\",\n    startDate: \"2021-07-01\",\n    endDate: \"2021-07-07\",\n    images: [],\n    countries: [\"USA\"],\n    legs: [\n      { lat: 40.7128, lon: -74.006, name: \"New York City\", iso: \"USA\" },\n      { lat: 37.3382, lon: -121.8863, name: \"San Jose, CA\", iso: \"USA\" },\n    ],\n  },\n  {\n    id: \"nyc-nashville-louisville\",\n    title: \"NYC → Nashville → Louisville\",\n    description: \"From Music City to Derby City.\",\n    startDate: \"2021-08-10\",\n    endDate: \"2021-08-20\",\n    images: [\n      \"https://example.com/nashville.jpg\",\n      \"https://example.com/louisville2.jpg\",\n    ],\n    countries: [\"USA\"],\n    legs: [\n      { lat: 40.7128, lon: -74.006, name: \"New York City\", iso: \"USA\" },\n      { lat: 36.1627, lon: -86.7816, name: \"Nashville\", iso: \"USA\" },\n      { lat: 38.2527, lon: -85.7585, name: \"Louisville\", iso: \"USA\" },\n    ],\n  },\n  {\n    id: \"nyc-london-zurich-copenhagen-bern\",\n    title: \"NYC → London → Zurich → Copenhagen → Bern\",\n    description: \"European adventure through the UK, Switzerland, and Denmark.\",\n    startDate: \"2021-09-05\",\n    endDate: \"2021-09-25\",\n    images: [\n      \"https://example.com/london.jpg\",\n      \"https://example.com/zurich.jpg\",\n    ],\n    countries: [\"GBR\", \"CHE\", \"DNK\"],\n    legs: [\n      { lat: 40.7128, lon: -74.006, name: \"New York City\", iso: \"USA\" },\n      { lat: 51.5074, lon: -0.1278, name: \"London\", iso: \"GBR\" },\n      { lat: 47.3769, lon: 8.5417, name: \"Zurich\", iso: \"CHE\" },\n      { lat: 55.6761, lon: 12.5683, name: \"Copenhagen\", iso: \"DNK\" },\n      { lat: 46.948, lon: 7.4474, name: \"Bern\", iso: \"CHE\" },\n    ],\n  },\n  {\n    id: \"nyc-reykjavik\",\n    title: \"NYC → Reykjavik\",\n    description: \"Checking out Iceland's capital city.\",\n    startDate: \"2021-10-01\",\n    endDate: \"2021-10-05\",\n    images: [\"https://example.com/reykjavik.jpg\"],\n    countries: [\"ISL\"],\n    legs: [\n      { lat: 40.7128, lon: -74.006, name: \"New York City\", iso: \"USA\" },\n      { lat: 64.1466, lon: -21.9426, name: \"Reykjavik\", iso: \"ISL\" },\n    ],\n  },\n  {\n    id: \"nyc-louisville-2\",\n    title: \"NYC → Louisville\",\n    description: \"A second trip back for more Kentucky experiences.\",\n    startDate: \"2021-11-01\",\n    endDate: \"2021-11-05\",\n    images: [],\n    countries: [\"USA\"],\n    legs: [\n      { lat: 40.7128, lon: -74.006, name: \"New York City\", iso: \"USA\" },\n      { lat: 38.2527, lon: -85.7585, name: \"Louisville\", iso: \"USA\" },\n    ],\n  },\n  {\n    id: \"nyc-louisville-3\",\n    title: \"NYC → Louisville (Part 3)\",\n    description: \"Yet another Louisville trip.\",\n    startDate: \"2021-12-05\",\n    endDate: \"2021-12-10\",\n    images: [\"https://example.com/louisville3.jpg\"],\n    countries: [\"USA\"],\n    legs: [\n      { lat: 40.7128, lon: -74.006, name: \"New York City\", iso: \"USA\" },\n      { lat: 38.2527, lon: -85.7585, name: \"Louisville\", iso: \"USA\" },\n    ],\n  },\n];\n","import * as THREE from \"three\";\n\n/**\n * Convert latitude & longitude to a THREE.Vector3 on a sphere.\n * @param lat   latitude in degrees\n * @param lon   longitude in degrees\n * @param radius sphere radius\n */\nexport const latLongToVector3 = (lat: number, lon: number, radius: number) => {\n  const phi = (90 - lat) * (Math.PI / 180);\n  const theta = (lon + 180) * (Math.PI / 180);\n\n  const x = -radius * Math.sin(phi) * Math.cos(theta);\n  const z = radius * Math.sin(phi) * Math.sin(theta);\n  const y = radius * Math.cos(phi);\n\n  return new THREE.Vector3(x, y, z);\n};\n\n/**\n * buildFullArcGeometry\n *\n * Creates a THREE.TubeGeometry for a 3D arc using the same\n * cubic-bezier control logic that your animated ArcLight uses.\n */\nexport const buildAllArcs = (\n  startLat: number,\n  startLon: number,\n  endLat: number,\n  endLon: number,\n  radius: number\n) => {\n  const startVec = latLongToVector3(startLat, startLon, radius);\n  const endVec = latLongToVector3(endLat, endLon, radius);\n\n  // Approx midpoint logic\n  const midPoint = new THREE.Vector3()\n    .addVectors(startVec, endVec)\n    .multiplyScalar(0.5);\n  const distance = startVec.distanceTo(endVec);\n  const arcHeight = distance * 1.5;\n  midPoint.setLength(midPoint.length() + arcHeight);\n\n  const control1 = new THREE.Vector3().lerpVectors(startVec, midPoint, 0.25);\n  const control2 = new THREE.Vector3().lerpVectors(startVec, midPoint, 0.75);\n\n  // Build a cubic bezier arc\n  const curve = new THREE.CubicBezierCurve3(\n    startVec,\n    control1,\n    control2,\n    endVec\n  );\n\n  return new THREE.TubeGeometry(curve, 64, 0.5, 8, false);\n};\n","import { useEffect, useMemo, useState } from \"react\";\nimport { AllArcsBehavior, ArcLocation } from \"../../../../types/earthTypes\";\nimport { buildAllArcs } from \"../../utils/arcs\";\n\nexport interface AllArcsStaticMeshProps {\n  /**\n   * Array of flight arc locations with start and end coordinates.\n   */\n  flights: ArcLocation[];\n  /**\n   * Base color of the arcs.\n   */\n  color: string;\n  /**\n   * Radius of the sphere on which the arcs are drawn.\n   */\n  radius: number;\n  /**\n   * Animation behavior for the arcs.\n   */\n  behavior?: AllArcsBehavior;\n}\n\n/**\n * `AllArcsStaticMesh` renders multiple arcs as static or animated meshes.\n * - Animates opacity based on the specified `behavior`.\n * - Generates arc geometries dynamically for each flight in the `flights` array.\n */\nconst AllArcsStaticMesh = ({\n  flights,\n  color,\n  radius,\n  behavior,\n}: AllArcsStaticMeshProps) => {\n  // Single opacity state shared by all arcs\n  const [opacity, setOpacity] = useState(!behavior ? 1 : 0);\n\n  useEffect(() => {\n    // If flicker is true, we do the old-timey rapid toggling.\n    if (behavior === \"flicker\") {\n      // Flicker for 1 second (1000 ms), toggling every 100 ms\n      let elapsed = 0;\n      const flickerInterval = 100;\n      const totalDuration = 1000;\n      const intervalId = setInterval(() => {\n        elapsed += flickerInterval;\n        // Randomly go 0 or 1\n        setOpacity(Math.random() < 0.5 ? 0 : 1);\n\n        // After flicker finishes, set full\n        if (elapsed >= totalDuration) {\n          clearInterval(intervalId);\n          setOpacity(1);\n        }\n      }, flickerInterval);\n\n      return () => clearInterval(intervalId);\n\n      // Else if smoothOn is true, do a modern fade from 0 to 1\n    } else if (behavior === \"smooth\") {\n      // We'll animate from 0 to 1 over 1 second\n      let frameId: number | null = null;\n      const startTime = performance.now();\n      const duration = 1000; // 1 second\n\n      const animate = (now: number) => {\n        const elapsed = now - startTime;\n        const t = Math.min(elapsed / duration, 1); // clamp 0..1\n        setOpacity(t);\n\n        if (t < 1) {\n          frameId = requestAnimationFrame(animate);\n        }\n      };\n\n      frameId = requestAnimationFrame(animate);\n      return () => {\n        if (frameId) cancelAnimationFrame(frameId);\n      };\n\n      // Otherwise, show immediately at full opacity\n    } else {\n      setOpacity(1);\n    }\n  }, [behavior]);\n\n  // Precompute the geometries\n  const arcGeometries = useMemo(() => {\n    return flights.map((flight) => {\n      return buildAllArcs(\n        flight.start.lat,\n        flight.start.lon,\n        flight.end.lat,\n        flight.end.lon,\n        radius\n      );\n    });\n  }, [flights, radius]);\n\n  return (\n    <>\n      {arcGeometries.map((geometry, index) => (\n        <mesh key={index} geometry={geometry}>\n          <meshBasicMaterial color={color} transparent opacity={opacity} />\n        </mesh>\n      ))}\n    </>\n  );\n};\n\nexport default AllArcsStaticMesh;\n","import { useFrame } from \"@react-three/fiber\";\nimport { useEffect, useRef, useState } from \"react\";\nimport * as THREE from \"three\";\n\ninterface ArcLandingEffectProps {\n  position: THREE.Vector3;\n  color?: string;\n  onDone?: () => void;\n}\n\nconst LandingEffect = ({\n  position,\n  color = \"#ffffff\",\n  onDone,\n}: ArcLandingEffectProps) => {\n  const groupRef = useRef<THREE.Group>(null!);\n\n  // If you want separate references to tweak them individually:\n  const dotRef = useRef<THREE.Mesh>(null!);\n  const ringRef = useRef<THREE.Mesh>(null!);\n\n  // Circle’s *base* radius (the dot):\n  const BASE_RADIUS = 1;\n\n  // How large do we want them to expand? (1 = same size as base, 2 = double, etc.)\n  const FINAL_SCALE = 1.3;\n\n  // Local state for scale & opacity\n  const [dotScale, setDotScale] = useState(0); // for the solid circle\n  const [ringScale, setRingScale] = useState(0); // for the expanding ring\n  const [ringOpacity, setRingOpacity] = useState(1);\n\n  // Orient the group’s +Z axis toward the point on the globe\n  useEffect(() => {\n    if (position.lengthSq() === 0) return;\n    const normal = position.clone().normalize();\n    const zAxis = new THREE.Vector3(0, 0, 1);\n    const quat = new THREE.Quaternion().setFromUnitVectors(zAxis, normal);\n    groupRef.current.quaternion.copy(quat);\n  }, [position]);\n\n  useFrame(() => {\n    // Animate dot scale: step ~6% closer to 1\n    const newDotScale = dotScale + (1 - dotScale) * 0.06;\n    setDotScale(newDotScale);\n\n    // Animate ring scale: step ~6% closer to 1\n    const newRingScale = ringScale + (1 - ringScale) * 0.06;\n    setRingScale(newRingScale);\n\n    // Fade ring out as it nears full scale\n    const newOpacity = 1 - newRingScale;\n    setRingOpacity(newOpacity);\n\n    // Once it's mostly expanded, remove it\n    if (newRingScale > 0.98) {\n      onDone?.();\n    }\n  });\n\n  return (\n    <group ref={groupRef} position={position}>\n      {/* Dot (solid circle) */}\n      <mesh\n        ref={dotRef}\n        scale={[\n          dotScale * FINAL_SCALE,\n          dotScale * FINAL_SCALE,\n          dotScale * FINAL_SCALE,\n        ]}\n      >\n        <circleGeometry args={[BASE_RADIUS, 64]} />\n        <meshBasicMaterial color={color} transparent opacity={1} />\n      </mesh>\n\n      <mesh\n        ref={ringRef}\n        scale={[\n          ringScale * FINAL_SCALE,\n          ringScale * FINAL_SCALE,\n          ringScale * FINAL_SCALE,\n        ]}\n      >\n        <ringGeometry args={[2.95, 3.1, 64]} />\n        <meshBasicMaterial\n          color={color}\n          transparent\n          opacity={ringOpacity}\n          side={THREE.DoubleSide}\n          depthTest={true}\n        />\n      </mesh>\n    </group>\n  );\n};\n\nexport default LandingEffect;\n","import { useFrame } from \"@react-three/fiber\";\nimport { useMemo, useRef, useState } from \"react\";\nimport * as THREE from \"three\";\nimport { latLongToVector3 } from \"../../utils/arcs\";\nimport LandingEffect from \"./LandingEffect\";\n\ninterface ArcProps {\n  /**\n   * Color of the arc.\n   */\n  color: string;\n  /**\n   * Starting latitude in degrees.\n   */\n  startLat: number;\n  /**\n   * Starting longitude in degrees.\n   */\n  startLon: number;\n  /**\n   * Ending latitude in degrees.\n   */\n  endLat: number;\n  /**\n   * Ending longitude in degrees.\n   */\n  endLon: number;\n  /**\n   * Radius of the sphere on which the arc is drawn.\n   */\n  radius: number;\n  /**\n   * Duration of the arc animation in milliseconds.\n   * Defaults to 2500ms.\n   */\n  animationDuration?: number;\n  /**\n   * Callback function triggered when the arc animation completes.\n   */\n  onDone?: () => void;\n  /**\n   * Whether the arc persists after drawing or retracts in a two-phase animation.\n   * Defaults to `false`.\n   */\n  onProgressPersist?: boolean;\n}\n\n/**\n * `PartialCurve` extends a base `THREE.Curve` to only render a section (partial curve)\n * between `minT` and `maxT`.\n */\nclass PartialCurve extends THREE.Curve<THREE.Vector3> {\n  baseCurve: THREE.Curve<THREE.Vector3>;\n  minT: number;\n  maxT: number;\n\n  /**\n   * Constructs a `PartialCurve` from a base curve and fractional range [minT, maxT].\n   * @param baseCurve The base curve (e.g., `THREE.CubicBezierCurve3`) to extract from.\n   * @param minT Start fraction of the curve (0.0–1.0).\n   * @param maxT End fraction of the curve (0.0–1.0).\n   */\n  constructor(\n    baseCurve: THREE.Curve<THREE.Vector3>,\n    minT: number,\n    maxT: number\n  ) {\n    super();\n    this.baseCurve = baseCurve;\n    this.minT = minT;\n    this.maxT = maxT;\n  }\n\n  /**\n   * Computes a point on the partial curve given `t` (fractional position).\n   * @param t Fraction along the partial curve (0.0–1.0).\n   * @param optionalTarget Optional target vector for storing the result.\n   * @returns The computed point as a `THREE.Vector3`.\n   */\n  getPoint(t: number, optionalTarget?: THREE.Vector3) {\n    const u = this.minT + (this.maxT - this.minT) * t;\n    return this.baseCurve.getPoint(u, optionalTarget);\n  }\n}\n\n/**\n * `Arc` renders a curved path between two geographic points on a sphere.\n * - Animates the arc over time, optionally showing a landing effect upon completion.\n * - Supports both persistent and retractable animations.\n */\nconst Arc = ({\n  color,\n  startLat,\n  startLon,\n  endLat,\n  endLon,\n  radius,\n  animationDuration = 2500,\n  onDone,\n  onProgressPersist = false,\n}: ArcProps) => {\n  const meshRef = useRef<THREE.Mesh>(null!);\n  const geometryRef = useRef<THREE.TubeGeometry>(null!);\n  const [done, setDone] = useState(false);\n  const [startTime] = useState(() => performance.now());\n  const [showLandingEffect, setShowLandingEffect] = useState(false);\n\n  // Convert lat/lon → 3D vectors on the sphere\n  const startVec = useMemo(\n    () => latLongToVector3(startLat, startLon, radius),\n    [startLat, startLon, radius]\n  );\n  const endVec = useMemo(\n    () => latLongToVector3(endLat, endLon, radius),\n    [endLat, endLon, radius]\n  );\n\n  // Full arc\n  const fullCurve = useMemo(() => {\n    const midPoint = new THREE.Vector3()\n      .addVectors(startVec, endVec)\n      .multiplyScalar(0.5);\n    const distance = startVec.distanceTo(endVec);\n    const arcHeight = distance * 1.5;\n    midPoint.setLength(midPoint.length() + arcHeight);\n\n    const control1 = new THREE.Vector3().lerpVectors(startVec, midPoint, 0.25);\n    const control2 = new THREE.Vector3().lerpVectors(startVec, midPoint, 0.75);\n\n    return new THREE.CubicBezierCurve3(startVec, control1, control2, endVec);\n  }, [startVec, endVec]);\n\n  // Create a (full) TubeGeometry once\n  const tubeGeometry = useMemo(() => {\n    return new THREE.TubeGeometry(fullCurve, 64, 0.5, 8, false);\n  }, [fullCurve]);\n\n  // Store that geometry in geometryRef so we can .setDrawRange() on it\n  useMemo(() => {\n    geometryRef.current = tubeGeometry;\n  }, [tubeGeometry]);\n\n  useFrame(() => {\n    if (done) return;\n\n    const elapsed = performance.now() - startTime;\n    let t = elapsed / animationDuration;\n    if (t > 1) t = 1;\n\n    if (onProgressPersist) {\n      // Single-phase (persist mode), 0->1, using setDrawRange\n      const indexCount = geometryRef.current.index\n        ? geometryRef.current.index.count\n        : geometryRef.current.attributes.position.count;\n      const drawCount = Math.floor(indexCount * t);\n      geometryRef.current.setDrawRange(0, drawCount);\n\n      // Optional: show the effect at t=1 in persist mode\n      if (t >= 1) {\n        geometryRef.current.setDrawRange(0, indexCount);\n        // If you want the landing effect as soon as we fully reach the end:\n        if (!showLandingEffect) {\n          setShowLandingEffect(true);\n        }\n        setDone(true);\n        onDone?.();\n      }\n    } else {\n      // Two-phase: 0..0.5 => extend, 0.5..1 => retract\n      if (!meshRef.current) return;\n\n      let extendP = 0;\n      let retractP = 0;\n\n      if (t <= 0.5) {\n        // extending\n        extendP = t / 0.5; // 0..1\n        retractP = 0;\n      } else {\n        // retracting\n        extendP = 1;\n        retractP = (t - 0.5) / 0.5; // 0..1\n\n        // As soon as the arc hits the end (t >= 0.5) show landing effect\n        if (!showLandingEffect) {\n          setShowLandingEffect(true);\n        }\n      }\n\n      const startParam = retractP; // grows 0..1 in second half\n      const endParam = extendP; // 0..1 in first half, pinned at 1 in second half\n\n      if (endParam <= startParam) {\n        meshRef.current.visible = false;\n      } else {\n        meshRef.current.visible = true;\n        const partialCurve = new PartialCurve(fullCurve, startParam, endParam);\n        const newGeom = new THREE.TubeGeometry(partialCurve, 64, 0.5, 8, false);\n\n        // Dispose old geometry to avoid leaks\n        if (meshRef.current.geometry) {\n          (meshRef.current.geometry as THREE.BufferGeometry).dispose();\n        }\n        meshRef.current.geometry = newGeom;\n      }\n\n      if (t >= 1) {\n        // fully done\n        meshRef.current.visible = false;\n        setDone(true);\n        onDone?.();\n      }\n    }\n  });\n\n  return (\n    <>\n      <mesh ref={meshRef}>\n        {/* For persist arcs, we pass in the stable geometryRef */}\n        {onProgressPersist ? (\n          <primitive object={tubeGeometry} attach=\"geometry\" />\n        ) : null}\n        <meshBasicMaterial color={color} transparent opacity={0.9} />\n      </mesh>\n\n      {/* Show landing effect when showLandingEffect = true */}\n      {showLandingEffect && (\n        <LandingEffect\n          position={endVec}\n          color=\"#ffcd53\"\n          onDone={() => setShowLandingEffect(false)}\n        />\n      )}\n    </>\n  );\n};\n\nexport default Arc;\n","import { useEffect, useState } from \"react\";\nimport {\n  AllArcsBehavior,\n  ArcLocation,\n  OnAllArcsDoneBehavior,\n} from \"../../../../types/earthTypes\";\nimport AllArcsStaticMesh from \"./AllArcsStaticMesh\";\nimport ArcLight from \"./Arc\";\n\nexport interface ArcGroupProps {\n  /**\n   * Array of start and end coordinates for each arc.\n   */\n  locationArray: ArcLocation[];\n\n  /**\n   * If true, arcs animate sequentially one-by-one.\n   * If false, all arcs animate in parallel.\n   */\n  sequential?: boolean;\n\n  /**\n   * Color of the arcs (e.g., hex code, RGB, etc.).\n   */\n  color: string;\n\n  /**\n   * Radius of the globe used to map lat/lon to 3D coordinates.\n   */\n  radius: number;\n\n  /**\n   * Duration of each arc animation in milliseconds.\n   * Default is 2500ms.\n   */\n  animationDuration?: number;\n\n  /**\n   * Duration of the *first* arc animation in milliseconds (optional).\n   * If provided, this overrides the animation duration only for the first arc.\n   */\n  firstAnimationDuration?: number;\n\n  /**\n   * If true, completed arcs remain visible after animation ends.\n   * If false, arcs disappear upon completing their animation.\n   */\n  onProgressPersist?: boolean;\n\n  /**\n   * Behavior when all arcs finish:\n   *  - \"persist\": Keep arcs visible (default).\n   *  - \"remove\": Hide all arcs immediately after completion.\n   *  - \"reset\": Hide arcs and restart the animation sequence.\n   */\n  onAllArcsDone?: OnAllArcsDoneBehavior;\n\n  /**\n   * Determines how arcs behave after persisting in the final state.\n   */\n  persistArcBehavior: AllArcsBehavior;\n}\n\n/**\n * Component for rendering a group of arcs between geographic points.\n * Arcs can animate sequentially or in parallel based on the `sequential` prop.\n *\n * Once an arc finishes:\n *  - If `onProgressPersist` is false, the arc disappears.\n *  - Otherwise, the arc remains visible until all arcs are complete.\n *\n * When all arcs finish:\n *  - Behavior is determined by the `onAllArcsDone` prop.\n */\nconst ArcGroup = ({\n  locationArray,\n  sequential = false,\n  color,\n  radius,\n  animationDuration = 2500,\n  firstAnimationDuration,\n  onProgressPersist = true,\n  onAllArcsDone = \"persist\",\n  persistArcBehavior,\n}: ArcGroupProps) => {\n  /**\n   * currentArcIndex:\n   *  - In sequential mode, the index of the arc currently animating (or just finished).\n   *  - In parallel mode, not really used to limit arcs, but we still track for resetting logic.\n   */\n  const [currentArcIndex, setCurrentArcIndex] = useState(0);\n\n  /**\n   * arcsDoneCount: how many arcs have fully completed their animation.\n   */\n  const [arcsDoneCount, setArcsDoneCount] = useState(0);\n\n  /**\n   * Track which arcs have completed to control per-arc visibility if onProgressPersist=false\n   */\n  const [arcsCompleted, setArcsCompleted] = useState<boolean[]>(\n    Array(locationArray.length).fill(false)\n  );\n\n  const [showFinalArcs, setShowFinalArcs] = useState(false);\n\n  /**\n   * Reset everything if the user chooses \"reset\" after the final arc,\n   * or if we mount fresh.\n   */\n  const resetAll = () => {\n    setCurrentArcIndex(0);\n    setArcsDoneCount(0);\n    setArcsCompleted(Array(locationArray.length).fill(false));\n    setShowFinalArcs(false);\n  };\n\n  /**\n   * Once the final arc is done, handle \"onAllArcsDone\" behavior\n   */\n  useEffect(() => {\n    if (arcsDoneCount === locationArray.length && locationArray.length > 0) {\n      // If we've just completed the final arc:\n      switch (onAllArcsDone) {\n        case \"remove\":\n          // Hide all arcs\n          setArcsCompleted(Array(locationArray.length).fill(true));\n          break;\n        case \"reset\":\n          // Wait a short moment so we can see the final arc\n          setTimeout(() => {\n            resetAll();\n          }, 500);\n          break;\n        case \"persist\":\n          setShowFinalArcs(true);\n          break;\n        default:\n          break;\n      }\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [arcsDoneCount, locationArray.length, onAllArcsDone]);\n\n  return (\n    <>\n      {!showFinalArcs &&\n        locationArray.map((flight, i) => {\n          // If we are in sequential mode, skip arcs beyond currentArcIndex\n          if (sequential && i > currentArcIndex) {\n            return null;\n          }\n\n          // If arc i is done & onProgressPersist is false => hide it\n          if (arcsCompleted[i] && !onProgressPersist) {\n            return null;\n          }\n\n          // Determine the animation duration for each arc:\n          const arcDuration =\n            i === 0 && firstAnimationDuration\n              ? firstAnimationDuration\n              : animationDuration;\n\n          return (\n            <ArcLight\n              key={i}\n              color={color}\n              startLat={flight.start.lat}\n              startLon={flight.start.lon}\n              endLat={flight.end.lat}\n              endLon={flight.end.lon}\n              radius={radius + 0.1}\n              onProgressPersist={onProgressPersist}\n              animationDuration={arcDuration}\n              onDone={() => {\n                setArcsCompleted((prev) => {\n                  const copy = [...prev];\n                  copy[i] = true;\n                  return copy;\n                });\n\n                // Increase arcsDoneCount\n                setArcsDoneCount((prev) => prev + 1);\n\n                // If sequential, move to the next arc in line\n                if (sequential && i === currentArcIndex) {\n                  setTimeout(() => {\n                    setCurrentArcIndex((prev) => prev + 1);\n                  }, 500);\n                }\n              }}\n            />\n          );\n        })}\n      {showFinalArcs && (\n        <AllArcsStaticMesh\n          flights={locationArray}\n          color={color}\n          radius={radius + 0.1}\n          behavior={persistArcBehavior}\n        />\n      )}\n    </>\n  );\n};\n\nexport default ArcGroup;\n","// AtmosphereShader.ts\nimport * as THREE from \"three\";\n\nexport const AtmosphereShader = {\n  uniforms: {\n    uColor: { value: new THREE.Color(\"#00aaff\") },\n    uIntensity: { value: 1.0 }, // how strong the glow is\n    uPower: { value: 2.0 }, // how quickly it falls off\n  },\n  vertexShader: `\n    varying vec3 vNormal;\n    void main() {\n      vNormal = normalize(normal);\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  `,\n  fragmentShader: `\n    uniform vec3 uColor;\n    uniform float uIntensity;\n    uniform float uPower;\n    varying vec3 vNormal;\n    \n    void main() {\n      // Fresnel-like term: how perpendicular the normal is to the view direction\n      float intensity = pow(1.0 - dot(vNormal, vec3(0.0, 0.0, 1.0)), uPower);\n      gl_FragColor = vec4(uColor, intensity * uIntensity);\n    }\n  `,\n};\n","// Atmosphere.tsx\nimport { useRef } from \"react\";\nimport * as THREE from \"three\";\nimport { AtmosphereShader } from \"../utils/AtmosphereShader\";\n\nexport interface AtmosphereProps {\n  earthRadius: number;\n  color: string;\n  opacity: number;\n}\n\n/**\n * `Atmosphere` is a slightly larger, inverted sphere around the Earth for a glowing atmospheric effect.\n * Uses a custom shader from `AtmosphereShader`.\n *\n * @param {AtmosphereProps} props\n *   @prop {number} earthRadius - Base radius of the Earth sphere.\n *   @prop {string} color - Color for the atmosphere glow (hex).\n *   @prop {number} opacity - Opacity level for the atmospheric glow.\n *\n * Renders a sphere with THREE.BackSide and a custom shader material to achieve a radial glow.\n */\nconst Atmosphere = ({ earthRadius, color, opacity }: AtmosphereProps) => {\n  const meshRef = useRef<THREE.Mesh>(null);\n\n  return (\n    <mesh ref={meshRef}>\n      <sphereGeometry args={[earthRadius * 1.018, 80, 80]} />\n      <shaderMaterial\n        side={THREE.BackSide}\n        transparent={true}\n        depthWrite={false}\n        uniforms={{\n          ...AtmosphereShader.uniforms,\n          uColor: { value: new THREE.Color(color) },\n          uIntensity: { value: 1.2 },\n          uPower: { value: 2.0 },\n        }}\n        vertexShader={AtmosphereShader.vertexShader}\n        fragmentShader={AtmosphereShader.fragmentShader}\n        opacity={opacity}\n      />\n    </mesh>\n  );\n};\n\nexport default Atmosphere;\n","interface BaseSphereProps {\n  radius: number;\n}\n\n/**\n * The main Earth sphere mesh, without any atmosphere or land dots.\n *\n * @param {BaseSphereProps} props\n *   @prop {number} radius - Radius of the sphere geometry.\n *\n * Uses a meshStandardMaterial for basic shading, plus a slight emissive glow.\n */\nconst BaseSphere = ({ radius }: BaseSphereProps) => {\n  return (\n    <mesh>\n      <sphereGeometry args={[radius, 64, 64]} />\n      <meshStandardMaterial\n        color=\"#0b2a57\"\n        emissive=\"#081c3c\"\n        emissiveIntensity={0.3}\n        roughness={0.45}\n      />\n    </mesh>\n  );\n};\n\nexport default BaseSphere;\n","import { useFrame } from \"@react-three/fiber\";\nimport { useEffect, useMemo, useRef } from \"react\";\nimport * as THREE from \"three\";\n\ninterface CityMarkerProps {\n  position: THREE.Vector3;\n  color: string;\n  markerSize: number;\n}\n\n/**\n * A single marker that is oriented to face outward from the globe.\n * - Renders a base circle marker plus a pulsing ring effect.\n */\nconst CityMarker = ({ position, color, markerSize }: CityMarkerProps) => {\n  // This is the correct way to define a React Three Fiber ref:\n  const groupRef = useRef<THREE.Group>(null!);\n\n  // Compute the normal only once per position\n  const normal = useMemo(() => position.clone().normalize(), [position]);\n\n  // Once the group is rendered, set its orientation & position\n  useEffect(() => {\n    if (!groupRef.current) return;\n    const zAxis = new THREE.Vector3(0, 0, 1);\n    const quat = new THREE.Quaternion().setFromUnitVectors(zAxis, normal);\n\n    groupRef.current.quaternion.copy(quat);\n    groupRef.current.position.copy(position);\n  }, [normal, position]);\n\n  return (\n    <group ref={groupRef}>\n      {/* Base marker (circle) */}\n      <mesh>\n        <circleGeometry args={[markerSize, 32]} />\n        <meshBasicMaterial color={color} side={THREE.DoubleSide} />\n      </mesh>\n\n      {/* Pulsing ring effect */}\n      <PulseRing baseRadius={markerSize * 1} color={color} />\n    </group>\n  );\n};\n\nexport default CityMarker;\n\n/**\n * A repeatedly-expanding ring that fades out as it grows, then resets.\n * You can tweak the speed, scale, and fade for your desired \"pulse.\"\n */\nfunction PulseRing({\n  baseRadius,\n  color,\n}: {\n  baseRadius: number;\n  color: string;\n}) {\n  const ringRef = useRef<THREE.Mesh>(null!);\n\n  /**\n   * We'll animate a \"phase\" t from 0..1 over some duration, then reset to 0.\n   * - scale = 1 + 1 * t (grows from 1 → 2)\n   * - opacity = 1 - t   (fades from 1 → 0)\n   */\n  const PULSE_DURATION = 2.2; // seconds per pulse\n  const MIN_SCALE = 1;\n  const MAX_SCALE = 2.5;\n\n  useFrame((state, delta) => {\n    if (!ringRef.current) return;\n\n    // We'll track time in ringRef’s userData (or you could use a useRef for the time).\n    // Accumulate delta each frame, loop back when passing PULSE_DURATION.\n    if (!ringRef.current.userData.elapsed) {\n      ringRef.current.userData.elapsed = 0;\n    }\n\n    ringRef.current.userData.elapsed += delta;\n    let t = ringRef.current.userData.elapsed / PULSE_DURATION;\n\n    // If time > PULSE_DURATION, reset\n    if (t > 1) {\n      ringRef.current.userData.elapsed = 0;\n      t = 0;\n    }\n\n    // scale 1..2\n    const scale = MIN_SCALE + (MAX_SCALE - MIN_SCALE) * t;\n    // fade 1..0\n    const opacity = 1 - t;\n\n    ringRef.current.scale.set(scale, scale, scale);\n    const material = ringRef.current.material as THREE.MeshBasicMaterial;\n    material.opacity = opacity;\n  });\n\n  return (\n    <mesh ref={ringRef}>\n      {/* Slightly thin ring geometry so it looks like a halo */}\n      <ringGeometry args={[baseRadius * 1, baseRadius * 1.5, 64]} />\n      <meshBasicMaterial\n        color={color}\n        transparent\n        opacity={1}\n        side={THREE.DoubleSide}\n      />\n    </mesh>\n  );\n}\n","import { useMemo } from \"react\";\nimport { CityLocation } from \"../../../types/earthTypes\";\nimport { latLongToVector3 } from \"../utils/arcs\";\nimport CityMarker from \"./helpers/CityMarker\";\n\nexport interface CityMarkersProps {\n  cities: CityLocation[];\n  radius: number;\n  color?: string;\n  markerSize?: number;\n}\n\nconst CityMarkers = ({\n  cities,\n  radius,\n  color = \"#ffcd53\",\n  markerSize = 1.5,\n}: CityMarkersProps) => {\n  // 1) Deduplicate by name (optional if your data is guaranteed unique):\n  const uniqueCities = useMemo(() => {\n    const map = new Map();\n    for (const city of cities) {\n      map.set(city.name, city);\n    }\n    return Array.from(map.values());\n  }, [cities]);\n\n  return (\n    <>\n      {uniqueCities.map((city, i) => {\n        // Convert lat/lon to Vector3 on the sphere\n        const position = latLongToVector3(city.lat, city.lon, radius);\n\n        return (\n          <CityMarker\n            key={city.name + i}\n            position={position}\n            color={color}\n            markerSize={markerSize}\n          />\n        );\n      })}\n    </>\n  );\n};\n\nexport default CityMarkers;\n","import gsap from \"gsap\";\nimport * as THREE from \"three\";\nimport { OrbitControls as OrbitControlsImpl } from \"three-stdlib\";\nimport { DotInfo } from \"../../../types/earthTypes\";\n\ninterface GetCountryCentroidProps {\n  isoA3: string;\n  dots: DotInfo[];\n}\n\n/**\n * Given an ISO code and an array of DotInfo,\n * compute the average (x, y, z) of all dots for that ISO.\n */\nexport const getCountryCentroid = ({\n  isoA3,\n  dots,\n}: GetCountryCentroidProps): THREE.Vector3 | null => {\n  const countryDots = dots.filter((d) => d.isoA3 === isoA3);\n  if (!countryDots.length) return null;\n\n  let sumX = 0,\n    sumY = 0,\n    sumZ = 0;\n  for (const d of countryDots) {\n    sumX += d.x;\n    sumY += d.y;\n    sumZ += d.z;\n  }\n\n  const count = countryDots.length;\n  return new THREE.Vector3(sumX / count, sumY / count, sumZ / count);\n};\n\ninterface FlyCameraToPointProps {\n  camera: THREE.Camera;\n  controls: OrbitControlsImpl;\n  targetPos: THREE.Vector3;\n  distanceOffset?: number;\n}\n\n/**\n * Fly the camera so that `targetPos` ends up in front of you.\n * - `camera`: your THREE.Camera\n * - `controls`: your OrbitControls reference\n * - `targetPos`: a THREE.Vector3 (e.g. a country centroid)\n * - `distanceOffset`: how far away (in world units) to position the camera from that point\n */\nexport const flyCameraToPoint = ({\n  camera,\n  controls,\n  targetPos,\n  distanceOffset = 300,\n}: FlyCameraToPointProps): void => {\n  // 1) Compute a camera position that is `distanceOffset` away from targetPos\n  const dir = targetPos.clone().normalize();\n  const newCamPos = dir.multiplyScalar(targetPos.length() + distanceOffset);\n\n  // 2) Animate the camera position\n  gsap.to(camera.position, {\n    x: newCamPos.x,\n    y: newCamPos.y,\n    z: newCamPos.z,\n    duration: 1,\n    ease: \"power2.inOut\",\n    onUpdate: () => {\n      controls.update();\n    },\n  });\n};\n\n/** ------------------------------------------------------------------\n *  (OPTIONAL) HELPER #1: Fly camera to a specific ISO code directly.\n * ------------------------------------------------------------------ */\n// This function is purely optional — it’s basically a convenience that\n// wraps getCountryCentroid and flyCameraToPoint together.\nexport function flyCameraToCountry({\n  camera,\n  controls,\n  globe,\n  isoA3,\n  dots,\n  distanceOffset = 300,\n}: {\n  camera: THREE.Camera;\n  controls: OrbitControlsImpl;\n  globe: THREE.Group;\n  isoA3: string;\n  dots: DotInfo[];\n  distanceOffset?: number;\n}) {\n  const centroid = getCountryCentroid({ isoA3, dots });\n  if (!centroid) return;\n  const worldPos = centroid.clone();\n  globe.localToWorld(worldPos);\n  flyCameraToPoint({\n    camera,\n    controls,\n    targetPos: worldPos,\n    distanceOffset,\n  });\n}\n\n/** ------------------------------------------------------------------\n *  (OPTIONAL) HELPER #2: Sort & get the nearest intersection from a pointer event.\n * ------------------------------------------------------------------ */\nexport function getNearestIntersection(\n  e: THREE.Event & { intersections?: THREE.Intersection[] }\n): THREE.Intersection | null {\n  if (!e.intersections || e.intersections.length === 0) {\n    return null;\n  }\n  // Sort by distance ascending\n  const sorted = e.intersections.sort((a, b) => a.distance - b.distance);\n  return sorted[0];\n}\n","import { useFrame } from \"@react-three/fiber\";\nimport {\n  PointerEvent,\n  RefObject,\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\nimport * as THREE from \"three\";\nimport { OrbitControls as OrbitControlsImpl } from \"three-stdlib\";\nimport { selectFocusIso } from \"../../../store/globeSlice\";\nimport { useAppSelector } from \"../../../store/hooks\";\nimport { DotInfo } from \"../../../types/earthTypes\";\nimport useAtOrAboveBreakpoint from \"../../../utils/useAtOrAboveBreakpoint\";\nimport {\n  flyCameraToPoint,\n  getCountryCentroid,\n  getNearestIntersection,\n} from \"../utils/earthMath\";\n\nexport interface ContinentDotsProps {\n  jsonUrl: string;\n  pointSize: number;\n  onCountrySelect?: (iso: string) => void;\n  dotColor: string;\n  highlightColor?: string;\n  onLoaded?: (loaded: boolean) => void;\n  globeRef?: RefObject<THREE.Group | null>;\n  controlsRef?: RefObject<OrbitControlsImpl | null>;\n  cameraRef?: RefObject<THREE.Camera | null>;\n}\n\n/**\n * A point cloud representing countries on the globe.\n * - Fetches dot coordinates (x,y,z).\n * - Handles highlighting & rotation when focusIso changes.\n */\nconst ContinentDots = ({\n  jsonUrl,\n  pointSize,\n  onCountrySelect,\n  onLoaded,\n  dotColor,\n  highlightColor = \"#FFFF00\",\n  globeRef,\n  controlsRef,\n  cameraRef,\n}: ContinentDotsProps) => {\n  const focusIso = useAppSelector(selectFocusIso);\n  const [dots, setDots] = useState<DotInfo[]>([]);\n\n  // -------------------- Highlighting Logic --------------------\n  const highlightRef = useRef<string | null>(null);\n  const highlightTimerRef = useRef<NodeJS.Timeout | null>(null);\n\n  // -------------------- Pointer / Drag Detection --------------------\n  const pointerDownPositionRef = useRef<{ x: number; y: number } | null>(null);\n  const isDraggingRef = useRef<boolean>(false);\n  const pointerDownDotIndexRef = useRef<number | null>(null);\n\n  const isSmUp = useAtOrAboveBreakpoint(\"sm\");\n\n  // -------------------- Pre-Converted Colors (Base & Highlight) --------------------\n  const [baseR, baseG, baseB] = useMemo(() => {\n    const color = new THREE.Color(dotColor);\n    return [color.r, color.g, color.b];\n  }, [dotColor]);\n\n  const [highlightR, highlightG, highlightB] = useMemo(() => {\n    const color = new THREE.Color(highlightColor);\n    return [color.r, color.g, color.b];\n  }, [highlightColor]);\n\n  // -------------------- Fetch Country Dots on Mount --------------------\n  useEffect(() => {\n    const fetchDots = async () => {\n      try {\n        const response = await fetch(jsonUrl);\n        const data: DotInfo[] = await response.json();\n        console.log(\"Loaded landDots.json:\", data);\n        setDots(data);\n        onLoaded?.(true);\n      } catch (err) {\n        console.error(\"Failed to load landDots.json:\", err);\n      }\n    };\n\n    fetchDots();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [jsonUrl]);\n\n  // -------------------- Fly to Country / Focus Handling --------------------\n  const handleFlyToIso = useCallback(\n    (isoCode: string) => {\n      if (!controlsRef?.current || !cameraRef?.current || !globeRef?.current) {\n        return;\n      }\n\n      // 1) Get the 3D centroid of that ISO\n      const centroidVec = getCountryCentroid({ isoA3: isoCode, dots });\n      if (!centroidVec) return;\n\n      // 2) Convert centroid from local space (globeRef) to world space\n      const worldPos = centroidVec.clone();\n      globeRef.current.localToWorld(worldPos);\n\n      // 3) Fly camera to the new position\n      flyCameraToPoint({\n        camera: cameraRef.current,\n        controls: controlsRef.current,\n        targetPos: worldPos,\n        distanceOffset: isSmUp ? 380 : 480,\n      });\n    },\n    [cameraRef, controlsRef, globeRef, dots]\n  );\n\n  // Whenever focusIso changes, highlight + fly\n  useEffect(() => {\n    if (!focusIso || dots.length === 0) {\n      highlightRef.current = null;\n      return;\n    }\n    highlightRef.current = focusIso;\n\n    if (globeRef?.current) {\n      handleFlyToIso(focusIso);\n    }\n  }, [focusIso, dots, globeRef, handleFlyToIso]);\n\n  // -------------------- Geometry: Positions & Colors --------------------\n  const positions = useMemo(() => {\n    if (!dots.length) return new Float32Array(0);\n    const arr = dots.flatMap((d) => [d.x, d.y, d.z]);\n    return new Float32Array(arr);\n  }, [dots]);\n\n  const colors = useMemo(() => {\n    if (!dots.length) return new Float32Array(0);\n    // For each dot, push the base color\n    const arr: number[] = [];\n    for (let i = 0; i < dots.length; i++) {\n      arr.push(baseR, baseG, baseB);\n    }\n    return new Float32Array(arr);\n  }, [dots, baseR, baseG, baseB]);\n\n  // We'll store an explicit ref to the color attribute so we can update it each frame\n  const colorAttrRef = useRef<THREE.BufferAttribute>(null);\n\n  // -------------------- Pointer Events --------------------\n  const handlePointerDown = useCallback((event: PointerEvent) => {\n    pointerDownPositionRef.current = { x: event.clientX, y: event.clientY };\n    isDraggingRef.current = false;\n    pointerDownDotIndexRef.current = null;\n\n    const nearestIntersection = getNearestIntersection(event);\n    pointerDownDotIndexRef.current = nearestIntersection?.index ?? null;\n\n    event.stopPropagation();\n  }, []);\n\n  const handlePointerMove = useCallback((event: PointerEvent) => {\n    if (!pointerDownPositionRef.current) return;\n    const dx = event.clientX - pointerDownPositionRef.current.x;\n    const dy = event.clientY - pointerDownPositionRef.current.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    // If we moved the pointer a certain threshold, treat it as a drag\n    if (distance > 20) {\n      isDraggingRef.current = true;\n    }\n    event.stopPropagation();\n  }, []);\n\n  const handlePointerUp = useCallback(\n    (event: PointerEvent) => {\n      if (!dots.length || !pointerDownDotIndexRef.current) return;\n\n      // If there's no intersection, do nothing\n      const nearestIntersection = getNearestIntersection(event);\n      if (!nearestIntersection) return;\n\n      // Is the dot the same one we pointer-downed on?\n      if (\n        nearestIntersection.index !== pointerDownDotIndexRef.current ||\n        isDraggingRef.current\n      ) {\n        // We either dragged or clicked a different dot\n        pointerDownPositionRef.current = null;\n        pointerDownDotIndexRef.current = null;\n        return;\n      }\n\n      // We are clicking on the same dot\n      const idx = nearestIntersection.index;\n      const dot = dots[idx];\n      if (!dot) return;\n\n      console.log(\n        `Clicked dot #${idx} → Country=${dot.countryName}, ISO=${dot.isoA3}`\n      );\n\n      // 1) Fire onCountrySelect if needed\n      onCountrySelect?.(dot.isoA3);\n\n      // 2) Fly to it\n      handleFlyToIso(dot.isoA3);\n\n      // 3) Temporarily highlight this country\n      highlightRef.current = dot.isoA3;\n      if (highlightTimerRef.current) {\n        clearTimeout(highlightTimerRef.current);\n      }\n      highlightTimerRef.current = setTimeout(() => {\n        highlightRef.current = null;\n      }, 2000);\n\n      // Reset\n      pointerDownPositionRef.current = null;\n      pointerDownDotIndexRef.current = null;\n      isDraggingRef.current = false;\n      event.stopPropagation();\n    },\n    [dots, onCountrySelect, handleFlyToIso]\n  );\n\n  // -------------------- Animate the Dot Colors --------------------\n  useFrame(() => {\n    if (!colorAttrRef.current || !dots.length) return;\n    const colorArray = colorAttrRef.current.array as Float32Array;\n\n    for (let i = 0; i < dots.length; i++) {\n      const dot = dots[i];\n      const offset = i * 3;\n\n      // If dot isoA3 matches the highlightRef, use highlight color\n      if (highlightRef.current === dot.isoA3) {\n        colorArray[offset] = highlightR;\n        colorArray[offset + 1] = highlightG;\n        colorArray[offset + 2] = highlightB;\n      } else {\n        // revert to base color\n        colorArray[offset] = baseR;\n        colorArray[offset + 1] = baseG;\n        colorArray[offset + 2] = baseB;\n      }\n    }\n    colorAttrRef.current.needsUpdate = true;\n  });\n\n  // -------------------- Early return if no dots loaded --------------------\n  if (!dots.length) return null;\n\n  // -------------------- Render the Point Cloud --------------------\n  return (\n    <points\n      onPointerDown={handlePointerDown}\n      onPointerMove={handlePointerMove}\n      onPointerUp={handlePointerUp}\n    >\n      <bufferGeometry>\n        <bufferAttribute\n          attach=\"attributes-position\"\n          args={[positions, 3]}\n          count={positions.length / 3}\n          itemSize={3}\n        />\n        <bufferAttribute\n          ref={colorAttrRef}\n          attach=\"attributes-color\"\n          args={[colors, 3]}\n          count={colors.length / 3}\n          itemSize={3}\n        />\n      </bufferGeometry>\n      <pointsMaterial\n        vertexColors\n        size={pointSize}\n        sizeAttenuation\n        transparent\n        opacity={0.8}\n      />\n    </points>\n  );\n};\n\nexport default ContinentDots;\n","import { useFrame } from \"@react-three/fiber\";\nimport { useEffect, useRef, useState } from \"react\";\nimport * as THREE from \"three\";\nimport { lerp } from \"three/src/math/MathUtils\";\nimport { selectFocusIso } from \"../../../store/globeSlice\";\nimport { useAppSelector } from \"../../../store/hooks\";\nimport { AllArcsBehavior, ArcLocation } from \"../../../types/earthTypes\";\nimport useAtOrAboveBreakpoint from \"../../../utils/useAtOrAboveBreakpoint\";\nimport { EARTH_RADIUS } from \"../EarthScene\";\nimport { getArcsFromTrip } from \"../utils/tripMath\";\nimport { trips } from \"../utils/trips\";\nimport ArcGroup, { ArcGroupProps } from \"./arcs/ArcGroup\";\nimport Atmosphere, { AtmosphereProps } from \"./Atmosphere\";\nimport BaseSphere from \"./BaseSphere\";\nimport CityMarkers, { CityMarkersProps } from \"./CityMarkerGroup\";\nimport ContinentDots, { ContinentDotsProps } from \"./ContinentDots\";\n\ninterface GlobeProps {\n  radius: number;\n  rotationSpeed: number;\n  isInteracting: boolean;\n  dots?: ContinentDotsProps;\n  atmosphere?: AtmosphereProps;\n  arcs?: ArcGroupProps & { persistArcBehavior: AllArcsBehavior };\n  cityMarkers?: CityMarkersProps;\n}\n\n/**\n * 3D Interactive Globe Component\n * - Features: Earth's sphere, atmosphere, continent dots, and animated arcs.\n * - Responsive Scaling: Adjusts based on breakpoints (XS, SM, MD).\n * - Animation: Handles rotation and smooth scaling after data loads.\n *\n * Props:\n * - radius: Base radius of the globe.\n * - rotationSpeed: Speed of Y-axis rotation (radians/frame).\n * - isInteracting: Pauses auto-rotation when true.\n * - dots: Configuration for continent dots.\n * - atmosphere: Atmospheric glow configuration.\n * - arcs: Flight arc animation configuration.\n */\nconst Globe = ({\n  radius,\n  rotationSpeed,\n  arcs,\n  atmosphere,\n  dots,\n  cityMarkers,\n  isInteracting,\n}: GlobeProps) => {\n  const globeRef = useRef<THREE.Group>(null);\n\n  // Breakpoints for final scale\n  const isMdUp = useAtOrAboveBreakpoint(\"md\");\n  const isSmUp = useAtOrAboveBreakpoint(\"sm\");\n  const isXSUp = useAtOrAboveBreakpoint(\"xs\");\n\n  let targetScale = 1.0;\n  if (isMdUp) {\n    targetScale = 1.0;\n  } else if (isSmUp) {\n    targetScale = 0.8;\n  } else if (isXSUp) {\n    targetScale = 0.7;\n  } else {\n    targetScale = 0.6;\n  }\n\n  const [currentScale, setCurrentScale] = useState(0.55);\n  const [dotsLoaded, setDotsLoaded] = useState(false);\n\n  // 1) Read the currently selected ISO from Redux\n  const focusIso = useAppSelector(selectFocusIso);\n\n  // 2) State for \"ephemeral\" arcs triggered by a country button\n  const [highlightArcs, setHighlightArcs] = useState<ArcLocation[]>([]);\n  const [highlightArcKey, setHighlightArcKey] = useState(0);\n\n  useEffect(() => {\n    setHighlightArcs([]);\n    if (!focusIso) return;\n    console.log(\"ISO FOCUSED!\", focusIso);\n    // Filter trips that have this iso in trip.countries\n    const matchedTrips = trips.filter((t) => t.countries.includes(focusIso));\n    console.log(\"Matched trips\", matchedTrips);\n    setHighlightArcKey((prev) => prev + 1);\n\n    // Flatten all matched trips into arcs\n    const allArcs = matchedTrips.flatMap((trip) => getArcsFromTrip(trip));\n    console.log(\"All arcs\", allArcs);\n    // Store them in state\n    setHighlightArcs(allArcs);\n    if (\n      !dots?.controlsRef?.current ||\n      !dots?.cameraRef?.current ||\n      !globeRef.current\n    )\n      return;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [focusIso]);\n\n  useFrame((_, delta) => {\n    if (!globeRef.current) return;\n\n    // 1) Only rotate if not interacting\n    if (!focusIso) {\n      globeRef.current.rotation.y += rotationSpeed;\n    }\n\n    const scaleSpeed = 2.0;\n    setCurrentScale((prev) => lerp(prev, targetScale, delta * scaleSpeed));\n  });\n\n  return (\n    <group visible={dotsLoaded} ref={globeRef} scale={currentScale}>\n      <BaseSphere radius={radius - 1} />\n      {!!atmosphere && (\n        <Atmosphere\n          earthRadius={radius - 2}\n          color={atmosphere.color}\n          opacity={atmosphere.opacity}\n        />\n      )}\n      {!!dots && (\n        <ContinentDots\n          jsonUrl={dots.jsonUrl}\n          dotColor={dots.dotColor}\n          pointSize={dots.pointSize}\n          onLoaded={(isLoaded) => setDotsLoaded(isLoaded)}\n          globeRef={globeRef}\n          controlsRef={dots.controlsRef}\n          cameraRef={dots.cameraRef}\n          highlightColor=\"white\"\n        />\n      )}\n\n      {!!cityMarkers && (\n        <CityMarkers\n          cities={cityMarkers.cities}\n          radius={cityMarkers.radius}\n          color={cityMarkers.color}\n          markerSize={cityMarkers.markerSize}\n        />\n      )}\n      {!!arcs && !highlightArcs.length && (\n        <ArcGroup\n          animationDuration={arcs.animationDuration}\n          color={arcs.color}\n          locationArray={arcs.locationArray}\n          onAllArcsDone={arcs.onAllArcsDone}\n          onProgressPersist={arcs.onProgressPersist}\n          radius={arcs.radius}\n          sequential={arcs.sequential}\n          persistArcBehavior={arcs.persistArcBehavior}\n        />\n      )}\n      {highlightArcs.length > 0 && !!arcs && (\n        <ArcGroup\n          key={highlightArcKey}\n          locationArray={highlightArcs}\n          color={arcs.color}\n          radius={EARTH_RADIUS}\n          firstAnimationDuration={1500}\n          animationDuration={500}\n          sequential={true}\n          onProgressPersist={false}\n          onAllArcsDone=\"remove\"\n          persistArcBehavior={undefined}\n        />\n      )}\n    </group>\n  );\n};\n\nexport default Globe;\n","import { useFrame, useThree } from \"@react-three/fiber\";\nimport { useEffect, useRef } from \"react\";\nimport * as THREE from \"three\";\nimport { EffectComposer } from \"three/examples/jsm/postprocessing/EffectComposer\";\nimport { RenderPass } from \"three/examples/jsm/postprocessing/RenderPass\";\nimport { UnrealBloomPass } from \"three/examples/jsm/postprocessing/UnrealBloomPass\";\n\ninterface ManualBloomProps {\n  bloomStrength?: number;\n  bloomRadius?: number;\n  bloomThreshold?: number;\n}\n/**\n * A custom post-processing bloom effect that uses:\n * - `EffectComposer` to chain multiple post-processing passes.\n * - `RenderPass` for the base scene rendering.\n * - `UnrealBloomPass` for the bloom effect.\n *\n * @param {ManualBloomProps} props\n * @prop {number} [bloomStrength=0.7] - Controls brightness of bloom highlights.\n * @prop {number} [bloomRadius=0.5] - Determines how large or soft the bloom edges appear.\n * @prop {number} [bloomThreshold=0.0] - Threshold above which areas start to bloom.\n *\n * Rendering order (the second arg in `useFrame`) is set to 1 so the bloom\n * pass happens after the scene renders. Returns null since all rendering\n * is handled via EffectComposer.\n */\nconst ManualBloom = ({\n  bloomStrength = 0.7,\n  bloomRadius = 0.5,\n  bloomThreshold = 0.0,\n}: ManualBloomProps) => {\n  const composer = useRef<EffectComposer | null>(null);\n  const { gl, scene, camera, size } = useThree();\n\n  useEffect(() => {\n    // Create EffectComposer once on mount\n    const effectComposer = new EffectComposer(gl);\n    effectComposer.setSize(size.width, size.height);\n\n    // 1. Render pass (renders the scene normally)\n    const renderScene = new RenderPass(scene, camera);\n    effectComposer.addPass(renderScene);\n\n    // 2. UnrealBloomPass\n    const bloomPass = new UnrealBloomPass(\n      new THREE.Vector2(size.width, size.height),\n      bloomStrength, // strength (how bright the bloom is)\n      bloomRadius, // radius (how wide or soft the bloom edges are)\n      bloomThreshold // threshold (how bright an area must be before it blooms)\n    );\n    effectComposer.addPass(bloomPass);\n\n    composer.current = effectComposer;\n  }, [gl, scene, camera, size, bloomStrength, bloomRadius, bloomThreshold]);\n\n  // Render the composer on every frame\n  useFrame(() => {\n    composer.current?.render();\n  }, 1);\n\n  return null;\n};\n\nexport default ManualBloom;\n","import { RefObject, useEffect } from \"react\";\nimport * as THREE from \"three\";\nimport { EARTH_RADIUS } from \"./EarthScene\";\n\ninterface SceneHelpersProps {\n  axesHelperRef: RefObject<THREE.AxesHelper | null>;\n  cameraRef: RefObject<THREE.Camera | null>;\n}\n\nconst SceneHelpers = ({ axesHelperRef, cameraRef }: SceneHelpersProps) => {\n  useEffect(() => {\n    if (axesHelperRef.current) {\n      axesHelperRef.current.visible = true;\n    }\n  }, [axesHelperRef]);\n\n  return (\n    <>\n      <primitive\n        ref={axesHelperRef}\n        object={new THREE.AxesHelper(500).setColors(\"red\", \"white\", \"blue\")}\n      />\n      <gridHelper args={[1000, 50]} />\n      <primitive\n        object={\n          new THREE.BoxHelper(\n            new THREE.Mesh(new THREE.SphereGeometry(EARTH_RADIUS))\n          )\n        }\n      />\n      {cameraRef.current && (\n        <primitive object={new THREE.CameraHelper(cameraRef.current)} />\n      )}\n      <polarGridHelper args={[EARTH_RADIUS, 16, 8, 64]} />\n    </>\n  );\n};\n\nexport default SceneHelpers;\n","import { useTheme } from \"@nextui-org/use-theme\";\nimport { OrbitControls } from \"@react-three/drei\";\nimport { Canvas } from \"@react-three/fiber\";\nimport { Suspense, useEffect, useRef, useState } from \"react\";\nimport * as THREE from \"three\";\nimport { OrbitControls as OrbitControlsImpl } from \"three-stdlib\";\nimport useAtOrAboveBreakpoint from \"../../utils/useAtOrAboveBreakpoint\";\nimport Globe from \"./layers/Globe\";\nimport ManualBloom from \"./layers/ManualBlooms\";\nimport SceneHelpers from \"./SceneHelpers\";\nimport { flattenAllTrips, getArcCities } from \"./utils/tripMath\";\nimport { trips } from \"./utils/trips\";\n\nconst MAX_ZOOMED_OUT = 700;\nexport const EARTH_RADIUS = 150;\n\ninterface EarthSceneProps {\n  enableHelpers?: boolean;\n}\n\n/**\n * A top-level 3D Earth component that:\n * - Sets up a Three.js Canvas with OrbitControls and performance stats.\n * - Renders the `Globe` component and optional post-processing (ManualBloom).\n */\nconst EarthScene = ({ enableHelpers }: EarthSceneProps) => {\n  // Refs for Three.js objects\n  const controlsRef = useRef<OrbitControlsImpl>(null);\n  const axesHelperRef = useRef<THREE.AxesHelper | null>(null);\n  const cameraRef = useRef<THREE.Camera | null>(null);\n\n  const { theme, setTheme } = useTheme();\n\n  useEffect(() => {\n    if (theme !== \"dark\") {\n      setTheme(\"dark\");\n    }\n  }, [theme, setTheme]);\n\n  const isSmallUp = useAtOrAboveBreakpoint(\"sm\");\n  const jsonUrl = isSmallUp\n    ? \"/landDots-150rad-40k.json\" // more dots\n    : \"/landDots-150rad-30k.json\"; // fewer dots\n\n  const [isInteracting, setIsInteracting] = useState(false);\n  const resumeRotationTimeout = useRef<NodeJS.Timeout | null>(null);\n\n  const handleInteractionStart = () => {\n    // Clear any existing timeouts\n    if (resumeRotationTimeout.current) {\n      clearTimeout(resumeRotationTimeout.current);\n      resumeRotationTimeout.current = null;\n    }\n    setIsInteracting(true);\n  };\n\n  const handleInteractionEnd = () => {\n    // Wait 1 second before resuming\n    resumeRotationTimeout.current = setTimeout(() => {\n      setIsInteracting(false);\n    }, 1000);\n  };\n\n  const isXLUp = useAtOrAboveBreakpoint(\"xl\");\n  const isSmUp = useAtOrAboveBreakpoint(\"sm\");\n\n  return (\n    <Canvas\n      gl={{ alpha: true }}\n      style={{ background: \"transparent\" }}\n      camera={{ position: [0, 150, 900], fov: 35 }}\n      onCreated={(state) => {\n        cameraRef.current = state.camera; // Store camera reference\n        state.camera.updateProjectionMatrix();\n        const offsetX = isXLUp ? state.size.width * 0.2 : 0;\n        const offsetY = isSmUp ? 0 : state.size.height * 0.07;\n        state.camera.setViewOffset(\n          /* fullWidth  */ state.size.width,\n          /* fullHeight */ state.size.height,\n          /* offsetX    */ offsetX,\n          /* offsetY    */ offsetY,\n          /* width      */ state.size.width,\n          /* height     */ state.size.height\n        );\n\n        state.raycaster.params.Points.threshold = 2;\n      }}\n    >\n      <OrbitControls\n        ref={controlsRef}\n        enableDamping={true}\n        minDistance={300}\n        minPolarAngle={0.3} // ~17 degrees\n        maxPolarAngle={Math.PI - 0.3} // ~163 degrees\n        enablePan={false}\n        maxDistance={MAX_ZOOMED_OUT}\n        onStart={handleInteractionStart}\n        onEnd={handleInteractionEnd}\n      />\n      <ambientLight intensity={1} />\n      <hemisphereLight intensity={0.2} position={[0, 50, 0]} />\n      <Suspense fallback={null}>\n        <Globe\n          isInteracting={isInteracting}\n          rotationSpeed={0.001}\n          radius={EARTH_RADIUS}\n          dots={{\n            dotColor: \"#00aaff\",\n            pointSize: 2.5,\n            jsonUrl,\n            controlsRef,\n            cameraRef,\n          }}\n          atmosphere={{\n            color: \"#00aaff\",\n            opacity: 0.03, // I fear this isn't hooked up to anything\n            earthRadius: EARTH_RADIUS,\n          }}\n          arcs={{\n            locationArray: flattenAllTrips(trips),\n            color: \"#dd6ff0\",\n            radius: EARTH_RADIUS,\n            animationDuration: 700,\n            sequential: false,\n            onProgressPersist: true,\n            onAllArcsDone: \"persist\",\n            persistArcBehavior: undefined,\n          }}\n          cityMarkers={{\n            cities: getArcCities(flattenAllTrips(trips)),\n            radius: EARTH_RADIUS,\n            color: \"#dd6ff0\",\n            markerSize: 1,\n          }}\n        />\n        <ManualBloom bloomStrength={1.2} bloomRadius={1} bloomThreshold={0.3} />\n      </Suspense>\n      {enableHelpers && (\n        <SceneHelpers axesHelperRef={axesHelperRef} cameraRef={cameraRef} />\n      )}\n    </Canvas>\n  );\n};\n\nexport default EarthScene;\n","import { Button } from \"@nextui-org/react\";\nimport Flag from \"react-flagpack\";\nimport { selectFocusIso, setFocusIso } from \"../../store/globeSlice\";\nimport { useAppDispatch, useAppSelector } from \"../../store/hooks\";\n\ninterface CountryButtonProps {\n  isos: string[] /** Must be alpha-3 */;\n}\nconst CountryButtons = ({ isos }: CountryButtonProps) => {\n  const dispatch = useAppDispatch();\n  const focusedISO = useAppSelector(selectFocusIso);\n  const handleClick = (iso: string) => {\n    iso === focusedISO\n      ? dispatch(setFocusIso(undefined))\n      : dispatch(setFocusIso(iso));\n  };\n  return (\n    <>\n      {isos.map((iso) => (\n        <Button\n          size=\"md\"\n          variant=\"light\"\n          key={iso}\n          isIconOnly\n          onPress={() => handleClick(iso)}\n        >\n          <Flag code={iso} hasBorder={false} size=\"l\" />\n        </Button>\n      ))}\n    </>\n  );\n};\n\nexport default CountryButtons;\n","import EarthScene from \"../../components/earth/EarthScene\";\nimport {\n  flattenAllIsos,\n  flattenAllTrips,\n  getArcCities,\n} from \"../../components/earth/utils/tripMath\";\nimport { trips } from \"../../components/earth/utils/trips\";\nimport Typewriter from \"../../components/Typewriter\";\nimport CountryButtons from \"./CountryButtons\";\n\nconst TheGlobeProject = () => {\n  const isos = flattenAllIsos(trips);\n  const cities = Array.from(new Set(getArcCities(flattenAllTrips(trips))));\n  return (\n    <div className=\"relative w-screen h-screen overflow-hidden\">\n      {/* Full-screen Earth in the background */}\n      <div className=\"absolute inset-0 pointer-events-auto\">\n        <EarthScene />\n      </div>\n      {/* Right half overlay (non-blocking by default) */}\n      <div className=\"flex absolute top-0 right-0 w-full sm:w-1/2 h-full items-end sm:items-center justify-center pointer-events-none z-10\">\n        {/* Make the actual text clickable */}\n        <div className=\"flex flex-col pointer-events-auto text-2xl items-center px-2 pb-8 sm:text-4xl sm:flex-start sm:pb-0 sm:px-0\">\n          <div className=\"flex mb-2 sm:mb-4\">\n            <Typewriter\n              phrases={[\n                \"2024 Travel:\",\n                `2024 Travel: 3 continents`, // TODO: calculate this\n                `2024 Travel: ${isos.length} countries`,\n                `2024 Travel: ${cities.length} cities`,\n              ]}\n              loop={false}\n              typingSpeed={100}\n              deletingSpeed={50}\n            />\n          </div>\n          <div className=\"flex flex-row gap-2\">\n            <CountryButtons isos={isos} />\n          </div>\n          <p className=\"text-medium sm:text-xl mt-2 max-w-md text-left\">\n            Looking back on a year of travel and adventure.\n          </p>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default TheGlobeProject;\n","import { useParams } from \"react-router-dom\";\nimport TheGlobeProject from \"../../projects/globe-project/TheGlobeProjects\";\n\nconst ProjectDetails = () => {\n  const { projectSlug } = useParams();\n\n  switch (projectSlug) {\n    case \"earth\":\n      return <TheGlobeProject />;\n    default:\n      return <div>Oops! Project not found.</div>;\n  }\n};\n\nexport default ProjectDetails;\n","import { useEffect, useState } from \"react\";\n\n// Tailwind's default breakpoints in pixels\nconst BREAKPOINTS = {\n  xs: 320,\n  sm: 640,\n  md: 768,\n  lg: 1024,\n  xl: 1280,\n  \"2xl\": 1536,\n};\n\ntype TailwindBreakpoint = keyof typeof BREAKPOINTS;\n\n/**\n * Usage:\n *   const isLargeUp = useTailwindBreakpoint(\"lg\");\n *   // returns true if window width >= 1024\n */\nconst useAtOrAboveBreakpoint = (breakpoint: TailwindBreakpoint) => {\n  const [matches, setMatches] = useState(false);\n\n  useEffect(() => {\n    function handleResize() {\n      const newMatches = window.innerWidth >= BREAKPOINTS[breakpoint];\n      // Only update state if the value actually changed\n      setMatches((old) => {\n        if (old !== newMatches) {\n          return newMatches;\n        }\n        return old;\n      });\n    }\n\n    window.addEventListener(\"resize\", handleResize);\n    handleResize();\n    return () => window.removeEventListener(\"resize\", handleResize);\n  }, [breakpoint]);\n\n  return matches;\n};\n\nexport default useAtOrAboveBreakpoint;\n"],"names":["_ref","_phrases$index","phrases","period","typingSpeed","deletingSpeed","loop","preserveTrailingNewlines","phase","setPhase","useState","index","setIndex","charIndex","setCharIndex","linkColor","useLinkColor","useEffect","isLastPhrase","length","currentPhrase","nextPhrase","overlapLength","a","b","i","findPrefixOverlap","rawOverlapLength","leftover","slice","test","preserveTrailingNewlinesInOverlap","nextChar","currentTypingSpeed","timeoutId","setTimeout","c","clearTimeout","pauseId","prevChar","currentDeletingSpeed","display","_jsxs","children","text","split","map","segment","arr","_jsx","className","concat","styles","style","borderColor","useAppSelector","useSelector","flattenAllTrips","trips","flatMap","trip","legs","arcs","push","start","end","getArcsFromLegs","getArcCities","cities","id","title","description","startDate","endDate","images","countries","lat","lon","name","iso","latLongToVector3","radius","phi","Math","PI","theta","x","sin","cos","z","y","THREE","flights","color","behavior","opacity","setOpacity","elapsed","flickerInterval","totalDuration","intervalId","setInterval","random","clearInterval","frameId","startTime","performance","now","duration","animate","t","min","requestAnimationFrame","cancelAnimationFrame","arcGeometries","useMemo","flight","buildAllArcs","startLat","startLon","endLat","endLon","startVec","endVec","midPoint","addVectors","multiplyScalar","arcHeight","distanceTo","setLength","control1","lerpVectors","control2","curve","_Fragment","geometry","transparent","position","onDone","groupRef","useRef","dotRef","ringRef","FINAL_SCALE","dotScale","setDotScale","ringScale","setRingScale","ringOpacity","setRingOpacity","lengthSq","normal","clone","normalize","zAxis","quat","setFromUnitVectors","current","quaternion","copy","useFrame","newRingScale","ref","scale","args","side","depthTest","PartialCurve","constructor","baseCurve","minT","maxT","super","this","getPoint","optionalTarget","u","animationDuration","onProgressPersist","meshRef","geometryRef","done","setDone","showLandingEffect","setShowLandingEffect","fullCurve","tubeGeometry","indexCount","count","attributes","drawCount","floor","setDrawRange","extendP","retractP","startParam","endParam","visible","partialCurve","newGeom","dispose","object","attach","LandingEffect","locationArray","sequential","firstAnimationDuration","onAllArcsDone","persistArcBehavior","currentArcIndex","setCurrentArcIndex","arcsDoneCount","setArcsDoneCount","arcsCompleted","setArcsCompleted","Array","fill","showFinalArcs","setShowFinalArcs","arcDuration","ArcLight","prev","AllArcsStaticMesh","AtmosphereShader","uniforms","uColor","value","uIntensity","uPower","vertexShader","fragmentShader","earthRadius","depthWrite","_objectSpread","emissive","emissiveIntensity","roughness","markerSize","PulseRing","baseRadius","_ref2","state","delta","userData","set","material","uniqueCities","Map","city","from","values","CityMarker","getCountryCentroid","isoA3","dots","countryDots","filter","d","sumX","sumY","sumZ","flyCameraToPoint","camera","controls","targetPos","distanceOffset","newCamPos","gsap","to","ease","onUpdate","update","getNearestIntersection","e","intersections","sort","distance","jsonUrl","pointSize","onCountrySelect","onLoaded","dotColor","highlightColor","globeRef","controlsRef","cameraRef","focusIso","selectFocusIso","setDots","highlightRef","highlightTimerRef","pointerDownPositionRef","isDraggingRef","pointerDownDotIndexRef","isSmUp","useAtOrAboveBreakpoint","baseR","baseG","baseB","r","g","highlightR","highlightG","highlightB","async","response","fetch","data","json","console","log","err","error","fetchDots","handleFlyToIso","useCallback","isoCode","centroidVec","worldPos","localToWorld","positions","Float32Array","colors","colorAttrRef","handlePointerDown","event","_nearestIntersection$","clientX","clientY","nearestIntersection","stopPropagation","handlePointerMove","dx","dy","sqrt","handlePointerUp","idx","dot","countryName","colorArray","array","offset","needsUpdate","onPointerDown","onPointerMove","onPointerUp","itemSize","vertexColors","size","sizeAttenuation","rotationSpeed","atmosphere","cityMarkers","isInteracting","isMdUp","isXSUp","targetScale","currentScale","setCurrentScale","dotsLoaded","setDotsLoaded","highlightArcs","setHighlightArcs","highlightArcKey","setHighlightArcKey","_dots$controlsRef","_dots$cameraRef","matchedTrips","includes","allArcs","getArcsFromTrip","_","rotation","lerp","BaseSphere","Atmosphere","ContinentDots","isLoaded","CityMarkers","ArcGroup","EARTH_RADIUS","undefined","bloomStrength","bloomRadius","bloomThreshold","composer","gl","scene","useThree","effectComposer","EffectComposer","setSize","width","height","renderScene","RenderPass","addPass","bloomPass","UnrealBloomPass","_composer$current","render","axesHelperRef","setColors","enableHelpers","theme","setTheme","useTheme","setIsInteracting","resumeRotationTimeout","isXLUp","Canvas","alpha","background","fov","onCreated","updateProjectionMatrix","offsetX","offsetY","setViewOffset","raycaster","params","Points","threshold","OrbitControls","enableDamping","minDistance","minPolarAngle","maxPolarAngle","enablePan","maxDistance","onStart","handleInteractionStart","onEnd","handleInteractionEnd","intensity","Suspense","fallback","Globe","ManualBloom","SceneHelpers","isos","dispatch","useDispatch","focusedISO","Button","variant","isIconOnly","onPress","setFocusIso","handleClick","Flag","code","hasBorder","TheGlobeProject","Set","_trip$countries","flattenAllIsos","EarthScene","Typewriter","CountryButtons","ProjectDetails","projectSlug","useParams","BREAKPOINTS","xs","sm","md","lg","xl","breakpoint","matches","setMatches","handleResize","newMatches","window","innerWidth","old","addEventListener","removeEventListener"],"sourceRoot":""}