{"version":3,"file":"static/js/156.4f02c463.chunk.js","mappings":"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","sources":["store/hooks.ts","components/earth/utils/tripMath.ts","components/earth/utils/trips.ts","components/earth/utils/arcs.ts","components/earth/layers/arcs/AllArcsStaticMesh.tsx","components/earth/layers/arcs/LandingEffect.tsx","components/earth/layers/arcs/ArcLight.tsx","components/earth/layers/arcs/ArcGroup.tsx","components/earth/utils/AtmosphereShader.ts","components/earth/layers/Atmosphere.tsx","components/earth/layers/BaseSphere.tsx","components/earth/utils/earthMath.ts","components/earth/layers/ContinentDots.tsx","components/earth/layers/Halo.tsx","components/earth/layers/Globe.tsx","components/earth/SceneHelpers.tsx","components/earth/EarthScene.tsx","projects/globe-project/TheGlobeProjects.tsx","pages/project-details/ProjectDetails.tsx","utils/useAtOrAboveBreakpoint.ts"],"sourcesContent":["import { TypedUseSelectorHook, useDispatch, useSelector } from \"react-redux\";\nimport type { AppDispatch, RootState } from \"./store\";\n\n// Use throughout your app instead of plain `useDispatch` and `useSelector`\nexport const useAppDispatch = () => useDispatch<AppDispatch>();\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;\n","import { ArcLocation, CityLocation, Trip } from \"../../../types/earthTypes\";\n\nexport function getArcsFromTrip(trip: Trip): ArcLocation[] {\n  const arcs: ArcLocation[] = [];\n  const legs = trip.legs; // an array of CityLocation\n\n  for (let i = 0; i < legs.length - 1; i++) {\n    arcs.push({\n      start: legs[i],\n      end: legs[i + 1],\n    });\n  }\n  return arcs;\n}\n\n/**\n * Converts an ordered list of city stops [C0, C1, C2, ... Cn]\n * into [Arc(C0->C1), Arc(C1->C2), ..., Arc(Cn-1->Cn)].\n */\nexport function getArcsFromLegs(legs: CityLocation[]): ArcLocation[] {\n  const arcs: ArcLocation[] = [];\n  for (let i = 0; i < legs.length - 1; i++) {\n    arcs.push({\n      start: legs[i],\n      end: legs[i + 1],\n    });\n  }\n  return arcs;\n}\n\n/**\n * Flatten arcs from all trips into a single array.\n */\nexport function flattenAllTrips(trips: Trip[]): ArcLocation[] {\n  return trips.flatMap((trip) => getArcsFromLegs(trip.legs));\n}\n\n/**\n * Each arc has start + end city.\n * We want to produce [Arc0.start, Arc0.end, Arc1.end, Arc2.end, ...].\n */\nexport function getArcCities(arcs: ArcLocation[]): CityLocation[] {\n  if (arcs.length === 0) return [];\n\n  const cities: CityLocation[] = [];\n  // Push the first arc's start city\n  cities.push(arcs[0].start);\n\n  // Then for each arc, push the end city\n  for (let i = 0; i < arcs.length; i++) {\n    cities.push(arcs[i].end);\n  }\n\n  return cities;\n}\n\nexport function flattenAllIsos(trips: Trip[]): string[] {\n  return Array.from(new Set(trips.flatMap((trip) => trip.countries ?? [])));\n}\n\n/**\n * Example stats: totalMiles, distinctCities, countries, etc.\n */\nexport interface TripStats {\n  numberOfDistinctCities: number;\n  totalMiles: number;\n  countriesVisited: string[];\n  continentsVisited: string[];\n}\n\nexport function getTripStats(\n  trip: Trip,\n  isoToContinent?: Record<string, string>\n): TripStats {\n  // Distinct city names\n  const distinctCities = new Set<string>();\n  trip.legs.forEach((city) => {\n    if (city.name) distinctCities.add(city.name);\n  });\n\n  // Summation of distances between consecutive legs\n  let totalMiles = 0;\n  for (let i = 0; i < trip.legs.length - 1; i++) {\n    const start = trip.legs[i];\n    const end = trip.legs[i + 1];\n    totalMiles += haversineMiles(start.lat, start.lon, end.lat, end.lon);\n  }\n\n  // Countries visited\n  const countriesVisited = trip.countries ?? [];\n\n  // Continents visited (optional)\n  let continentsVisited: string[] = [];\n  if (isoToContinent) {\n    const contSet = new Set<string>();\n    for (const iso of countriesVisited) {\n      const continent = isoToContinent[iso];\n      if (continent) {\n        contSet.add(continent);\n      }\n    }\n    continentsVisited = Array.from(contSet);\n  }\n\n  return {\n    numberOfDistinctCities: distinctCities.size,\n    totalMiles,\n    countriesVisited,\n    continentsVisited,\n  };\n}\n\nfunction haversineMiles(\n  lat1: number,\n  lon1: number,\n  lat2: number,\n  lon2: number\n) {\n  const R = 3958.8; // Earth radius in miles\n  const dLat = toRad(lat2 - lat1);\n  const dLon = toRad(lon2 - lon1);\n  const a =\n    Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n    Math.cos(toRad(lat1)) *\n      Math.cos(toRad(lat2)) *\n      Math.sin(dLon / 2) *\n      Math.sin(dLon / 2);\n\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  return R * c;\n}\nfunction toRad(value: number) {\n  return (value * Math.PI) / 180;\n}\n","import { Trip } from \"../../../types/earthTypes\";\n\nexport const trips: Trip[] = [\n  {\n    id: \"nyc-dallas\",\n    title: \"NYC → Dallas\",\n    description: \"A short trip to Dallas to escape the winter cold.\",\n    startDate: \"2021-01-05\",\n    endDate: \"2021-01-10\",\n    images: [\n      \"https://example.com/dallas1.jpg\",\n      \"https://example.com/dallas2.jpg\",\n    ],\n    countries: [\"USA\"],\n    legs: [\n      { lat: 40.7128, lon: -74.006, name: \"New York City\", iso: \"USA\" },\n      { lat: 32.7767, lon: -96.797, name: \"Dallas\", iso: \"USA\" },\n    ],\n  },\n  {\n    id: \"nyc-sf\",\n    title: \"NYC → San Francisco\",\n    description: \"Coast-to-coast weekend getaway.\",\n    startDate: \"2021-02-10\",\n    endDate: \"2021-02-15\",\n    images: [\"https://example.com/sf1.jpg\", \"https://example.com/sf2.jpg\"],\n    countries: [\"USA\"],\n    legs: [\n      { lat: 40.7128, lon: -74.006, name: \"New York City\", iso: \"USA\" },\n      { lat: 37.7749, lon: -122.4194, name: \"San Francisco\", iso: \"USA\" },\n    ],\n  },\n  {\n    id: \"nyc-louisville-1\",\n    title: \"NYC → Louisville\",\n    description: \"A quick trip for bourbon and horse racing.\",\n    startDate: \"2021-03-05\",\n    endDate: \"2021-03-10\",\n    images: [\"https://example.com/louisville1.jpg\"],\n    countries: [\"USA\"],\n    legs: [\n      { lat: 40.7128, lon: -74.006, name: \"New York City\", iso: \"USA\" },\n      { lat: 38.2527, lon: -85.7585, name: \"Louisville\", iso: \"USA\" },\n    ],\n  },\n  {\n    id: \"nyc-seattle\",\n    title: \"NYC → Seattle\",\n    description: \"Coffee and rain in the Pacific Northwest.\",\n    startDate: \"2021-04-01\",\n    endDate: \"2021-04-07\",\n    images: [],\n    countries: [\"USA\"],\n    legs: [\n      { lat: 40.7128, lon: -74.006, name: \"New York City\", iso: \"USA\" },\n      { lat: 47.6062, lon: -122.3321, name: \"Seattle\", iso: \"USA\" },\n    ],\n  },\n  {\n    id: \"nyc-bogota-cumaral-cartagena\",\n    title: \"NYC → Bogota → Cumaral → Cartagena\",\n    description:\n      \"Exploring Colombia, from the capital to the countryside to the coast.\",\n    startDate: \"2021-05-10\",\n    endDate: \"2021-05-25\",\n    images: [\n      \"https://example.com/bogota.jpg\",\n      \"https://example.com/cartagena.jpg\",\n    ],\n    countries: [\"COL\"],\n    legs: [\n      { lat: 40.7128, lon: -74.006, name: \"New York City\", iso: \"USA\" },\n      { lat: 4.711, lon: -74.0721, name: \"Bogota\", iso: \"COL\" },\n      { lat: 4.2702, lon: -73.4772, name: \"Cumaral\", iso: \"COL\" },\n      { lat: 10.391, lon: -75.4794, name: \"Cartagena\", iso: \"COL\" },\n    ],\n  },\n  {\n    id: \"nyc-destin\",\n    title: \"NYC → Destin\",\n    description: \"Relaxing on the Emerald Coast.\",\n    startDate: \"2021-06-01\",\n    endDate: \"2021-06-05\",\n    images: [\"https://example.com/destin.jpg\"],\n    countries: [\"USA\"],\n    legs: [\n      { lat: 40.7128, lon: -74.006, name: \"New York City\", iso: \"USA\" },\n      { lat: 30.3935, lon: -86.4958, name: \"Destin\", iso: \"USA\" },\n    ],\n  },\n  {\n    id: \"nyc-sanjose\",\n    title: \"NYC → San Jose, CA\",\n    description: \"Visiting Silicon Valley.\",\n    startDate: \"2021-07-01\",\n    endDate: \"2021-07-07\",\n    images: [],\n    countries: [\"USA\"],\n    legs: [\n      { lat: 40.7128, lon: -74.006, name: \"New York City\", iso: \"USA\" },\n      { lat: 37.3382, lon: -121.8863, name: \"San Jose, CA\", iso: \"USA\" },\n    ],\n  },\n  {\n    id: \"nyc-nashville-louisville\",\n    title: \"NYC → Nashville → Louisville\",\n    description: \"From Music City to Derby City.\",\n    startDate: \"2021-08-10\",\n    endDate: \"2021-08-20\",\n    images: [\n      \"https://example.com/nashville.jpg\",\n      \"https://example.com/louisville2.jpg\",\n    ],\n    countries: [\"USA\"],\n    legs: [\n      { lat: 40.7128, lon: -74.006, name: \"New York City\", iso: \"USA\" },\n      { lat: 36.1627, lon: -86.7816, name: \"Nashville\", iso: \"USA\" },\n      { lat: 38.2527, lon: -85.7585, name: \"Louisville\", iso: \"USA\" },\n    ],\n  },\n  {\n    id: \"nyc-london-zurich-copenhagen-bern\",\n    title: \"NYC → London → Zurich → Copenhagen → Bern\",\n    description: \"European adventure through the UK, Switzerland, and Denmark.\",\n    startDate: \"2021-09-05\",\n    endDate: \"2021-09-25\",\n    images: [\n      \"https://example.com/london.jpg\",\n      \"https://example.com/zurich.jpg\",\n    ],\n    countries: [\"GBR\", \"CHE\", \"DNK\"],\n    legs: [\n      { lat: 40.7128, lon: -74.006, name: \"New York City\", iso: \"USA\" },\n      { lat: 51.5074, lon: -0.1278, name: \"London\", iso: \"GBR\" },\n      { lat: 47.3769, lon: 8.5417, name: \"Zurich\", iso: \"CHE\" },\n      { lat: 55.6761, lon: 12.5683, name: \"Copenhagen\", iso: \"DNK\" },\n      { lat: 46.948, lon: 7.4474, name: \"Bern\", iso: \"CHE\" },\n    ],\n  },\n  {\n    id: \"nyc-reykjavik\",\n    title: \"NYC → Reykjavik\",\n    description: \"Checking out Iceland's capital city.\",\n    startDate: \"2021-10-01\",\n    endDate: \"2021-10-05\",\n    images: [\"https://example.com/reykjavik.jpg\"],\n    countries: [\"ISL\"],\n    legs: [\n      { lat: 40.7128, lon: -74.006, name: \"New York City\", iso: \"USA\" },\n      { lat: 64.1466, lon: -21.9426, name: \"Reykjavik\", iso: \"ISL\" },\n    ],\n  },\n  {\n    id: \"nyc-louisville-2\",\n    title: \"NYC → Louisville\",\n    description: \"A second trip back for more Kentucky experiences.\",\n    startDate: \"2021-11-01\",\n    endDate: \"2021-11-05\",\n    images: [],\n    countries: [\"USA\"],\n    legs: [\n      { lat: 40.7128, lon: -74.006, name: \"New York City\", iso: \"USA\" },\n      { lat: 38.2527, lon: -85.7585, name: \"Louisville\", iso: \"USA\" },\n    ],\n  },\n  {\n    id: \"nyc-louisville-3\",\n    title: \"NYC → Louisville (Part 3)\",\n    description: \"Yet another Louisville trip.\",\n    startDate: \"2021-12-05\",\n    endDate: \"2021-12-10\",\n    images: [\"https://example.com/louisville3.jpg\"],\n    countries: [\"USA\"],\n    legs: [\n      { lat: 40.7128, lon: -74.006, name: \"New York City\", iso: \"USA\" },\n      { lat: 38.2527, lon: -85.7585, name: \"Louisville\", iso: \"USA\" },\n    ],\n  },\n];\n","import * as THREE from \"three\";\n\n/**\n * Convert latitude & longitude to a THREE.Vector3 on a sphere.\n * @param lat   latitude in degrees\n * @param lon   longitude in degrees\n * @param radius sphere radius\n */\nexport const latLongToVector3 = (lat: number, lon: number, radius: number) => {\n  const phi = (90 - lat) * (Math.PI / 180);\n  const theta = (lon + 180) * (Math.PI / 180);\n\n  const x = -radius * Math.sin(phi) * Math.cos(theta);\n  const z = radius * Math.sin(phi) * Math.sin(theta);\n  const y = radius * Math.cos(phi);\n\n  return new THREE.Vector3(x, y, z);\n};\n\n/**\n * buildFullArcGeometry\n *\n * Creates a THREE.TubeGeometry for a 3D arc using the same\n * cubic-bezier control logic that your animated ArcLight uses.\n */\nexport const buildAllArcs = (\n  startLat: number,\n  startLon: number,\n  endLat: number,\n  endLon: number,\n  radius: number\n) => {\n  const startVec = latLongToVector3(startLat, startLon, radius);\n  const endVec = latLongToVector3(endLat, endLon, radius);\n\n  // Approx midpoint logic\n  const midPoint = new THREE.Vector3()\n    .addVectors(startVec, endVec)\n    .multiplyScalar(0.5);\n  const distance = startVec.distanceTo(endVec);\n  const arcHeight = distance * 1.5;\n  midPoint.setLength(midPoint.length() + arcHeight);\n\n  const control1 = new THREE.Vector3().lerpVectors(startVec, midPoint, 0.25);\n  const control2 = new THREE.Vector3().lerpVectors(startVec, midPoint, 0.75);\n\n  // Build a cubic bezier arc\n  const curve = new THREE.CubicBezierCurve3(\n    startVec,\n    control1,\n    control2,\n    endVec\n  );\n\n  return new THREE.TubeGeometry(curve, 64, 0.5, 8, false);\n};\n","import { useEffect, useMemo, useState } from \"react\";\nimport { AllArcsBehavior, ArcLocation } from \"../../../../types/earthTypes\";\nimport { buildAllArcs } from \"../../utils/arcs\";\n\nexport interface AllArcsStaticMeshProps {\n  /**\n   * Array of flight arc locations with start and end coordinates.\n   */\n  flights: ArcLocation[];\n  /**\n   * Base color of the arcs.\n   */\n  color: string;\n  /**\n   * Radius of the sphere on which the arcs are drawn.\n   */\n  radius: number;\n  /**\n   * Animation behavior for the arcs.\n   */\n  behavior?: AllArcsBehavior;\n}\n\n/**\n * `AllArcsStaticMesh` renders multiple arcs as static or animated meshes.\n * - Animates opacity based on the specified `behavior`.\n * - Generates arc geometries dynamically for each flight in the `flights` array.\n */\nconst AllArcsStaticMesh = ({\n  flights,\n  color,\n  radius,\n  behavior,\n}: AllArcsStaticMeshProps) => {\n  // Single opacity state shared by all arcs\n  const [opacity, setOpacity] = useState(!behavior ? 1 : 0);\n\n  useEffect(() => {\n    // If flicker is true, we do the old-timey rapid toggling.\n    if (behavior === \"flicker\") {\n      // Flicker for 1 second (1000 ms), toggling every 100 ms\n      let elapsed = 0;\n      const flickerInterval = 100;\n      const totalDuration = 1000;\n      const intervalId = setInterval(() => {\n        elapsed += flickerInterval;\n        // Randomly go 0 or 1\n        setOpacity(Math.random() < 0.5 ? 0 : 1);\n\n        // After flicker finishes, set full\n        if (elapsed >= totalDuration) {\n          clearInterval(intervalId);\n          setOpacity(1);\n        }\n      }, flickerInterval);\n\n      return () => clearInterval(intervalId);\n\n      // Else if smoothOn is true, do a modern fade from 0 to 1\n    } else if (behavior === \"smooth\") {\n      // We'll animate from 0 to 1 over 1 second\n      let frameId: number | null = null;\n      const startTime = performance.now();\n      const duration = 1000; // 1 second\n\n      const animate = (now: number) => {\n        const elapsed = now - startTime;\n        const t = Math.min(elapsed / duration, 1); // clamp 0..1\n        setOpacity(t);\n\n        if (t < 1) {\n          frameId = requestAnimationFrame(animate);\n        }\n      };\n\n      frameId = requestAnimationFrame(animate);\n      return () => {\n        if (frameId) cancelAnimationFrame(frameId);\n      };\n\n      // Otherwise, show immediately at full opacity\n    } else {\n      setOpacity(1);\n    }\n  }, [behavior]);\n\n  // Precompute the geometries\n  const arcGeometries = useMemo(() => {\n    return flights.map((flight) => {\n      return buildAllArcs(\n        flight.start.lat,\n        flight.start.lon,\n        flight.end.lat,\n        flight.end.lon,\n        radius\n      );\n    });\n  }, [flights, radius]);\n\n  return (\n    <>\n      {arcGeometries.map((geometry, index) => (\n        <mesh key={index} geometry={geometry}>\n          <meshBasicMaterial color={color} transparent opacity={opacity} />\n        </mesh>\n      ))}\n    </>\n  );\n};\n\nexport default AllArcsStaticMesh;\n","import { useFrame } from \"@react-three/fiber\";\nimport { useEffect, useRef, useState } from \"react\";\nimport * as THREE from \"three\";\n\ninterface ArcLandingEffectProps {\n  position: THREE.Vector3;\n  color: string;\n  onDone?: () => void;\n}\n\nconst LandingEffect = ({ position, color, onDone }: ArcLandingEffectProps) => {\n  const groupRef = useRef<THREE.Group>(null!);\n\n  // If you want separate references to tweak them individually:\n  const dotRef = useRef<THREE.Mesh>(null!);\n  const ringRef = useRef<THREE.Mesh>(null!);\n\n  // Circle’s *base* radius (the dot):\n  const BASE_RADIUS = 1.5;\n\n  // How large do we want them to expand? (1 = same size as base, 2 = double, etc.)\n  const FINAL_SCALE = 1.3;\n\n  // Local state for scale & opacity\n  const [dotScale, setDotScale] = useState(0); // for the solid circle\n  const [ringScale, setRingScale] = useState(0); // for the expanding ring\n  const [ringOpacity, setRingOpacity] = useState(1);\n\n  // Orient the group’s +Z axis toward the point on the globe\n  useEffect(() => {\n    if (position.lengthSq() === 0) return;\n    const normal = position.clone().normalize();\n    const zAxis = new THREE.Vector3(0, 0, 1);\n    const quat = new THREE.Quaternion().setFromUnitVectors(zAxis, normal);\n    groupRef.current.quaternion.copy(quat);\n  }, [position]);\n\n  useFrame(() => {\n    // Animate dot scale: step ~6% closer to 1\n    const newDotScale = dotScale + (1 - dotScale) * 0.06;\n    setDotScale(newDotScale);\n\n    // Animate ring scale: step ~6% closer to 1\n    const newRingScale = ringScale + (1 - ringScale) * 0.06;\n    setRingScale(newRingScale);\n\n    // Fade ring out as it nears full scale\n    const newOpacity = 1 - newRingScale;\n    setRingOpacity(newOpacity);\n\n    // Once it's mostly expanded, remove it\n    if (newRingScale > 0.98) {\n      onDone?.();\n    }\n  });\n\n  return (\n    <group ref={groupRef} position={position}>\n      {/* Dot (solid circle) */}\n      <mesh\n        ref={dotRef}\n        scale={[\n          dotScale * FINAL_SCALE,\n          dotScale * FINAL_SCALE,\n          dotScale * FINAL_SCALE,\n        ]}\n      >\n        <circleGeometry args={[BASE_RADIUS, 64]} />\n        <meshBasicMaterial color={color} transparent opacity={1} />\n      </mesh>\n\n      <mesh\n        ref={ringRef}\n        scale={[\n          ringScale * FINAL_SCALE,\n          ringScale * FINAL_SCALE,\n          ringScale * FINAL_SCALE,\n        ]}\n      >\n        <ringGeometry args={[10, 3.1, 64]} />\n        <meshBasicMaterial\n          color={color}\n          transparent\n          opacity={ringOpacity}\n          side={THREE.DoubleSide}\n          depthTest={true}\n        />\n      </mesh>\n    </group>\n  );\n};\n\nexport default LandingEffect;\n","import { useFrame } from \"@react-three/fiber\";\nimport { useMemo, useRef, useState } from \"react\";\nimport * as THREE from \"three\";\nimport { latLongToVector3 } from \"../../utils/arcs\";\nimport LandingEffect from \"./LandingEffect\";\n\ninterface ArcProps {\n  /**\n   * Color of the arc.\n   */\n  color: string;\n  /**\n   * Starting latitude in degrees.\n   */\n  startLat: number;\n  /**\n   * Starting longitude in degrees.\n   */\n  startLon: number;\n  /**\n   * Ending latitude in degrees.\n   */\n  endLat: number;\n  /**\n   * Ending longitude in degrees.\n   */\n  endLon: number;\n  /**\n   * Radius of the sphere on which the arc is drawn.\n   */\n  radius: number;\n  /**\n   * Duration of the arc animation in milliseconds.\n   * Defaults to 2500ms.\n   */\n  animationDuration?: number;\n  /**\n   * Callback function triggered when the arc animation completes.\n   */\n  onDone?: () => void;\n  /**\n   * Whether the arc persists after drawing or retracts in a two-phase animation.\n   * Defaults to `false`.\n   */\n  onProgressPersist?: boolean;\n}\n\n/**\n * `PartialCurve` extends a base `THREE.Curve` to only render a section (partial curve)\n * between `minT` and `maxT`.\n */\nclass PartialCurve extends THREE.Curve<THREE.Vector3> {\n  baseCurve: THREE.Curve<THREE.Vector3>;\n  minT: number;\n  maxT: number;\n\n  /**\n   * Constructs a `PartialCurve` from a base curve and fractional range [minT, maxT].\n   * @param baseCurve The base curve (e.g., `THREE.CubicBezierCurve3`) to extract from.\n   * @param minT Start fraction of the curve (0.0–1.0).\n   * @param maxT End fraction of the curve (0.0–1.0).\n   */\n  constructor(\n    baseCurve: THREE.Curve<THREE.Vector3>,\n    minT: number,\n    maxT: number\n  ) {\n    super();\n    this.baseCurve = baseCurve;\n    this.minT = minT;\n    this.maxT = maxT;\n  }\n\n  /**\n   * Computes a point on the partial curve given `t` (fractional position).\n   * @param t Fraction along the partial curve (0.0–1.0).\n   * @param optionalTarget Optional target vector for storing the result.\n   * @returns The computed point as a `THREE.Vector3`.\n   */\n  getPoint(t: number, optionalTarget?: THREE.Vector3) {\n    const u = this.minT + (this.maxT - this.minT) * t;\n    return this.baseCurve.getPoint(u, optionalTarget);\n  }\n}\n\n/**\n * `Arc` renders a curved path between two geographic points on a sphere.\n * - Animates the arc over time, optionally showing a landing effect upon completion.\n * - Supports both persistent and retractable animations.\n */\nconst Arc = ({\n  color,\n  startLat,\n  startLon,\n  endLat,\n  endLon,\n  radius,\n  animationDuration = 2500,\n  onDone,\n  onProgressPersist = false,\n}: ArcProps) => {\n  const meshRef = useRef<THREE.Mesh>(null!);\n  const geometryRef = useRef<THREE.TubeGeometry>(null!);\n  const [done, setDone] = useState(false);\n  const [startTime] = useState(() => performance.now());\n  const [showLandingEffect, setShowLandingEffect] = useState(false);\n\n  // Convert lat/lon → 3D vectors on the sphere\n  const startVec = useMemo(\n    () => latLongToVector3(startLat, startLon, radius),\n    [startLat, startLon, radius]\n  );\n  const endVec = useMemo(\n    () => latLongToVector3(endLat, endLon, radius),\n    [endLat, endLon, radius]\n  );\n\n  // Full arc\n  const fullCurve = useMemo(() => {\n    const midPoint = new THREE.Vector3()\n      .addVectors(startVec, endVec)\n      .multiplyScalar(0.5);\n    const distance = startVec.distanceTo(endVec);\n    const arcHeight = distance;\n    midPoint.setLength(midPoint.length() + arcHeight);\n\n    const control1 = new THREE.Vector3().lerpVectors(startVec, midPoint, 0.25);\n    const control2 = new THREE.Vector3().lerpVectors(startVec, midPoint, 0.75);\n\n    return new THREE.CubicBezierCurve3(startVec, control1, control2, endVec);\n  }, [startVec, endVec]);\n\n  // Create a (full) TubeGeometry once\n  const tubeGeometry = useMemo(() => {\n    return new THREE.TubeGeometry(fullCurve, 64, 0.5, 8, false);\n  }, [fullCurve]);\n\n  // Store that geometry in geometryRef so we can .setDrawRange() on it\n  useMemo(() => {\n    geometryRef.current = tubeGeometry;\n  }, [tubeGeometry]);\n\n  useFrame(() => {\n    if (done) return;\n\n    const elapsed = performance.now() - startTime;\n    let t = elapsed / animationDuration;\n    if (t > 1) t = 1;\n\n    if (onProgressPersist) {\n      // Single-phase (persist mode), 0->1, using setDrawRange\n      const indexCount = geometryRef.current.index\n        ? geometryRef.current.index.count\n        : geometryRef.current.attributes.position.count;\n      const drawCount = Math.floor(indexCount * t);\n      geometryRef.current.setDrawRange(0, drawCount);\n\n      // Optional: show the effect at t=1 in persist mode\n      if (t >= 1) {\n        geometryRef.current.setDrawRange(0, indexCount);\n        // If you want the landing effect as soon as we fully reach the end:\n        if (!showLandingEffect) {\n          setShowLandingEffect(true);\n        }\n        setDone(true);\n        onDone?.();\n      }\n    } else {\n      // Two-phase: 0..0.5 => extend, 0.5..1 => retract\n      if (!meshRef.current) return;\n\n      let extendP = 0;\n      let retractP = 0;\n\n      if (t <= 0.5) {\n        // extending\n        extendP = t / 0.5; // 0..1\n        retractP = 0;\n      } else {\n        // retracting\n        extendP = 1;\n        retractP = (t - 0.5) / 0.5; // 0..1\n\n        // As soon as the arc hits the end (t >= 0.5) show landing effect\n        if (!showLandingEffect) {\n          setShowLandingEffect(true);\n        }\n      }\n\n      const startParam = retractP; // grows 0..1 in second half\n      const endParam = extendP; // 0..1 in first half, pinned at 1 in second half\n\n      if (endParam <= startParam) {\n        meshRef.current.visible = false;\n      } else {\n        meshRef.current.visible = true;\n        const partialCurve = new PartialCurve(fullCurve, startParam, endParam);\n        const newGeom = new THREE.TubeGeometry(partialCurve, 64, 0.5, 8, false);\n\n        // Dispose old geometry to avoid leaks\n        if (meshRef.current.geometry) {\n          (meshRef.current.geometry as THREE.BufferGeometry).dispose();\n        }\n        meshRef.current.geometry = newGeom;\n      }\n\n      if (t >= 1) {\n        // fully done\n        meshRef.current.visible = false;\n        setDone(true);\n        onDone?.();\n      }\n    }\n  });\n\n  return (\n    <>\n      <mesh ref={meshRef}>\n        {/* For persist arcs, we pass in the stable geometryRef */}\n        {!!onProgressPersist ? (\n          <primitive object={tubeGeometry} attach=\"geometry\" />\n        ) : null}\n        <meshBasicMaterial color={color} transparent opacity={0.9} />\n      </mesh>\n\n      {/* Show landing effect when showLandingEffect = true */}\n      {showLandingEffect && (\n        <LandingEffect\n          position={endVec}\n          color=\"#dd6ff0\"\n          onDone={() => setShowLandingEffect(false)}\n        />\n      )}\n    </>\n  );\n};\n\nexport default Arc;\n","import { useEffect, useRef, useState } from \"react\";\nimport {\n  AllArcsBehavior,\n  ArcLocation,\n  CityLocation,\n  OnAllArcsDoneBehavior,\n} from \"../../../../types/earthTypes\";\nimport { getArcCities } from \"../../utils/tripMath\";\nimport AllArcsStaticMesh from \"./AllArcsStaticMesh\";\nimport ArcLight from \"./ArcLight\";\n\nexport interface ArcGroupProps {\n  /**\n   * Array of start/end coords or city stops.\n   * In normal mode, we draw arcs from locationArray.\n   * In infiniteRandom mode, we *extract* the cities from these arcs\n   * and treat them as our set of available points.\n   */\n  locationArray: ArcLocation[];\n\n  /**\n   * If true, arcs animate sequentially one-by-one.\n   * If false, all arcs animate in parallel (in normal mode).\n   * (Might ignore this if we’re doing infinite random firing.)\n   */\n  sequential?: boolean;\n\n  color: string;\n  radius: number;\n  animationDuration?: number;\n  firstAnimationDuration?: number;\n  onProgressPersist?: boolean;\n  onAllArcsDone?: OnAllArcsDoneBehavior;\n  persistArcBehavior: AllArcsBehavior;\n\n  /**\n   * If true, we continuously generate arcs between any pairs\n   * of the available points (derived from locationArray).\n   */\n  infiniteRandom?: boolean;\n  /**\n   * How often (in ms) to create a new random arc.\n   * (If infiniteRandom is true)\n   */\n  spawnInterval?: number;\n}\n\nfunction randomInt(max: number) {\n  return Math.floor(Math.random() * max);\n}\n\nfunction createRandomArc(allPoints: CityLocation[]): ArcLocation {\n  const startIdx = randomInt(allPoints.length);\n  let endIdx = randomInt(allPoints.length);\n  while (endIdx === startIdx) {\n    endIdx = randomInt(allPoints.length);\n  }\n  return {\n    start: allPoints[startIdx],\n    end: allPoints[endIdx],\n  };\n}\n\nexport default function ArcGroup({\n  locationArray,\n  color,\n  radius,\n  animationDuration = 2500,\n  firstAnimationDuration,\n  onProgressPersist = true,\n  onAllArcsDone = \"persist\",\n  persistArcBehavior,\n  infiniteRandom = false,\n  spawnInterval = 1500, // default 2 sec between spawns\n}: ArcGroupProps) {\n  // “All arcs we want to show in the scene right now”\n  const [arcsToRender, setArcsToRender] = useState<ArcLocation[]>([]);\n  // Track which arcs have started animating\n  const [arcsTriggered, setArcsTriggered] = useState<boolean[]>([]);\n  // Track which arcs have completed animation\n  const [arcsCompleted, setArcsCompleted] = useState<boolean[]>([]);\n  // Show final arcs as static?\n  const [showFinalArcs, setShowFinalArcs] = useState(false);\n\n  // If not infiniteRandom, once we finish all arcs, increment this\n  const [arcsDoneCount, setArcsDoneCount] = useState(0);\n\n  // For an interval-based approach, we may keep a ref to the interval ID\n  const spawnIntervalRef = useRef<NodeJS.Timeout | null>(null);\n\n  /**\n   * One-time reset if we are NOT infinite random.\n   * In normal mode, we generate arcs from the locationArray\n   * (or do whatever “random” logic you had before).\n   */\n  const normalResetAll = () => {\n    // Possibly your existing function that\n    // picks random arcs from locationArray\n    const coordinatePoints = getArcCities(locationArray);\n\n    // Example: we just generate 1 arc per city, etc.\n    const newArcs: ArcLocation[] = [];\n    for (let i = 0; i < coordinatePoints.length - 1; i++) {\n      newArcs.push({\n        start: coordinatePoints[i],\n        end: coordinatePoints[i + 1],\n      });\n    }\n\n    setArcsToRender(newArcs);\n    setArcsTriggered(Array(newArcs.length).fill(false));\n    setArcsCompleted(Array(newArcs.length).fill(false));\n    setArcsDoneCount(0);\n    setShowFinalArcs(false);\n  };\n\n  /**\n   * If infiniteRandom, spin up an interval to spawn a new arc every X seconds.\n   * We spawn arcs from the *city list* derived from locationArray.\n   */\n  const infiniteStart = () => {\n    const coordinatePoints = getArcCities(locationArray);\n\n    // Clean up any existing arcs, or maybe keep them\n    setArcsToRender([]);\n    setArcsTriggered([]);\n    setArcsCompleted([]);\n    setShowFinalArcs(false);\n\n    // Start interval that spawns new arcs\n    if (!spawnIntervalRef.current) {\n      spawnIntervalRef.current = setInterval(() => {\n        const newArc = createRandomArc(coordinatePoints);\n\n        // Add the new arc to our arcsToRender\n        setArcsToRender((prev) => [...prev, newArc]);\n        // Also expand arcsTriggered / arcsCompleted\n        setArcsTriggered((prev) => [...prev, false]);\n        setArcsCompleted((prev) => [...prev, false]);\n      }, spawnInterval);\n    }\n  };\n\n  /**\n   * On mount:\n   * - If infiniteRandom, start the spawn interval\n   * - Else do normalResetAll\n   */\n  useEffect(() => {\n    if (infiniteRandom) {\n      infiniteStart();\n    } else {\n      normalResetAll();\n    }\n\n    return () => {\n      // Cleanup: if we had an interval going, clear it\n      if (spawnIntervalRef.current) {\n        clearInterval(spawnIntervalRef.current);\n        spawnIntervalRef.current = null;\n      }\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [infiniteRandom, spawnInterval]);\n\n  /**\n   * Whenever arcsToRender changes (new arcs added),\n   * schedule each *newly added* arc to start at a random delay.\n   * (So they don’t all begin animating the moment they appear.)\n   */\n  useEffect(() => {\n    // For each arc, if it’s not yet triggered, schedule it\n    arcsToRender.forEach((_arc, i) => {\n      if (!arcsTriggered[i]) {\n        const delay = Math.random() * 200; // up to 1s\n        setTimeout(() => {\n          setArcsTriggered((prev) => {\n            const copy = [...prev];\n            copy[i] = true;\n            return copy;\n          });\n        }, delay);\n      }\n    });\n  }, [arcsToRender, arcsTriggered]);\n\n  /**\n   * In normal (non-infinite) mode, once all arcs are done, handle onAllArcsDone\n   */\n  useEffect(() => {\n    if (!infiniteRandom) {\n      if (arcsDoneCount === arcsToRender.length && arcsToRender.length > 0) {\n        switch (onAllArcsDone) {\n          case \"remove\":\n            setArcsCompleted(Array(arcsToRender.length).fill(true));\n            break;\n          case \"reset\":\n            setTimeout(() => {\n              normalResetAll();\n            }, 500);\n            break;\n          case \"persist\":\n            setShowFinalArcs(true);\n            break;\n          default:\n            break;\n        }\n      }\n    }\n  }, [arcsDoneCount, arcsToRender.length, onAllArcsDone, infiniteRandom]);\n\n  /**\n   * Clean up arcs for infinite mode if we’re *not* persisting.\n   * (So we don’t get an unbounded array of old arcs in memory.)\n   */\n  useEffect(() => {\n    if (infiniteRandom && !onProgressPersist) {\n      // Filter out arcs that have completed\n      const stillActiveArcs = arcsToRender.filter((_a, i) => !arcsCompleted[i]);\n      if (stillActiveArcs.length !== arcsToRender.length) {\n        setArcsToRender(stillActiveArcs);\n\n        // We also need to keep arcsTriggered/arcsCompleted\n        // in sync with the *new* array’s ordering.\n        const stillActiveTriggered: boolean[] = [];\n        const stillActiveCompleted: boolean[] = [];\n        arcsToRender.forEach((arc, i) => {\n          if (!arcsCompleted[i]) {\n            stillActiveTriggered.push(arcsTriggered[i]);\n            stillActiveCompleted.push(arcsCompleted[i]);\n          }\n        });\n        setArcsTriggered(stillActiveTriggered);\n        setArcsCompleted(stillActiveCompleted);\n      }\n    }\n  }, [arcsCompleted, arcsToRender, infiniteRandom, onProgressPersist]);\n\n  return (\n    <>\n      {/* If we are showing final arcs in normal mode, \n          or if we ever wanted to “persist” for infinite mode, \n          you could show a single static mesh. */}\n      {showFinalArcs && (\n        <AllArcsStaticMesh\n          flights={arcsToRender}\n          color={color}\n          radius={radius + 0.1}\n          behavior={persistArcBehavior}\n        />\n      )}\n\n      {/* Otherwise, render all arcs that are triggered. */}\n      {!showFinalArcs &&\n        arcsToRender.map((arc, i) => {\n          if (!arcsTriggered[i]) {\n            return null; // not started yet\n          }\n\n          // If arc completed & onProgressPersist=false => hide\n          if (arcsCompleted[i] && !onProgressPersist) {\n            return null;\n          }\n\n          // Possibly first arc special duration\n          const arcDuration =\n            i === 0 && firstAnimationDuration\n              ? firstAnimationDuration\n              : animationDuration;\n\n          return (\n            <ArcLight\n              key={i}\n              color={color}\n              startLat={arc.start.lat}\n              startLon={arc.start.lon}\n              endLat={arc.end.lat}\n              endLon={arc.end.lon}\n              radius={radius + 0.1}\n              onProgressPersist={onProgressPersist}\n              animationDuration={arcDuration}\n              onDone={() => {\n                setArcsCompleted((prev) => {\n                  const copy = [...prev];\n                  copy[i] = true;\n                  return copy;\n                });\n                setArcsDoneCount((prev) => prev + 1);\n              }}\n            />\n          );\n        })}\n    </>\n  );\n}\n","import * as THREE from \"three\";\nexport const AtmosphereShader = {\n  uniforms: {\n    uColor: { value: new THREE.Color(\"#00aaff\") },\n    uIntensity: { value: 1.0 },\n    uPower: { value: 2.0 },\n    uOpacity: { value: 0.3 },\n  },\n  vertexShader: `\n    varying vec3 vNormal;\n    varying vec3 vWorldPos;\n\n    void main() {\n      // Flip the normal so it faces outward on a back-sided sphere\n      vNormal = -normalize(normal);\n\n      vec4 worldPos = modelMatrix * vec4(position, 1.0);\n      vWorldPos = worldPos.xyz;\n\n      gl_Position = projectionMatrix * viewMatrix * worldPos;\n    }\n  `,\n  fragmentShader: `\n    uniform vec3 uColor;\n    uniform float uIntensity;\n    uniform float uPower;\n    uniform float uOpacity;\n    \n    varying vec3 vNormal;\n    varying vec3 vWorldPos;\n\n    void main() {\n      // Calculate the view direction from fragment to camera\n      vec3 viewDir = normalize(cameraPosition - vWorldPos);\n\n      // Because we flipped the normal, this is a more direct Fresnel\n      float fresnelTerm = dot(vNormal, viewDir);\n      fresnelTerm = clamp(fresnelTerm, 0.0, 1.0);\n\n      // Exponential falloff\n      float intensity = pow(fresnelTerm, uPower) * uIntensity;\n\n      // Final color with alpha\n      gl_FragColor = vec4(uColor, intensity * uOpacity);\n    }\n  `,\n};\n","import { useRef } from \"react\";\nimport * as THREE from \"three\";\nimport { AtmosphereShader } from \"../utils/AtmosphereShader\";\n\nexport interface AtmosphereProps {\n  earthRadius: number;\n  color: string;\n  opacity: number;\n}\n\nconst Atmosphere = ({ earthRadius, color, opacity }: AtmosphereProps) => {\n  const meshRef = useRef<THREE.Mesh>(null);\n\n  return (\n    <mesh ref={meshRef}>\n      {/* Make the sphere slightly bigger than Earth */}\n      <sphereGeometry args={[150 * 1.03, 64, 64]} />\n      <shaderMaterial\n        side={THREE.BackSide}\n        transparent={true}\n        depthWrite={false}\n        blending={THREE.AdditiveBlending}\n        uniforms={{\n          ...AtmosphereShader.uniforms,\n          uColor: { value: new THREE.Color(color) },\n          uIntensity: { value: 1.0 },\n          uPower: { value: 1.5 },\n          uOpacity: { value: opacity }, // e.g. 0.3\n        }}\n        vertexShader={AtmosphereShader.vertexShader}\n        fragmentShader={AtmosphereShader.fragmentShader}\n      />\n    </mesh>\n  );\n};\n\nexport default Atmosphere;\n","interface BaseSphereProps {\n  radius: number;\n}\n\n/**\n * The main Earth sphere mesh, without any atmosphere or land dots.\n *\n * @param {BaseSphereProps} props\n *   @prop {number} radius - Radius of the sphere geometry.\n *\n * Uses a meshStandardMaterial for basic shading, plus a slight emissive glow.\n */\nconst BaseSphere = ({ radius }: BaseSphereProps) => {\n  return (\n    <mesh>\n      <sphereGeometry args={[radius, 64, 64]} />\n      <meshPhongMaterial\n        color=\"#063985\"\n        emissive=\"#081c3c\"\n        shininess={5}\n        emissiveIntensity={0.4}\n        specular={0x222222}\n      />\n    </mesh>\n  );\n};\n\nexport default BaseSphere;\n","import gsap from \"gsap\";\nimport * as THREE from \"three\";\nimport { OrbitControls as OrbitControlsImpl } from \"three-stdlib\";\nimport { DotInfo } from \"../../../types/earthTypes\";\n\ninterface GetCountryCentroidProps {\n  isoA3: string;\n  dots: DotInfo[];\n}\n\n/**\n * Given an ISO code and an array of DotInfo,\n * compute the average (x, y, z) of all dots for that ISO.\n */\nexport const getCountryCentroid = ({\n  isoA3,\n  dots,\n}: GetCountryCentroidProps): THREE.Vector3 | null => {\n  const countryDots = dots.filter((d) => d.isoA3 === isoA3);\n  if (!countryDots.length) return null;\n\n  let sumX = 0,\n    sumY = 0,\n    sumZ = 0;\n  for (const d of countryDots) {\n    sumX += d.x;\n    sumY += d.y;\n    sumZ += d.z;\n  }\n\n  const count = countryDots.length;\n  return new THREE.Vector3(sumX / count, sumY / count, sumZ / count);\n};\n\ninterface FlyCameraToPointProps {\n  camera: THREE.Camera;\n  controls: OrbitControlsImpl;\n  targetPos: THREE.Vector3;\n  distanceOffset?: number;\n}\n\n/**\n * Fly the camera so that `targetPos` ends up in front of you.\n * - `camera`: your THREE.Camera\n * - `controls`: your OrbitControls reference\n * - `targetPos`: a THREE.Vector3 (e.g. a country centroid)\n * - `distanceOffset`: how far away (in world units) to position the camera from that point\n */\nexport const flyCameraToPoint = ({\n  camera,\n  controls,\n  targetPos,\n  distanceOffset = 300,\n}: FlyCameraToPointProps): void => {\n  // 1) Compute a camera position that is `distanceOffset` away from targetPos\n  const dir = targetPos.clone().normalize();\n  const newCamPos = dir.multiplyScalar(targetPos.length() + distanceOffset);\n\n  // 2) Animate the camera position\n  gsap.to(camera.position, {\n    x: newCamPos.x,\n    y: newCamPos.y,\n    z: newCamPos.z,\n    duration: 1.5,\n    ease: \"power1\",\n    onUpdate: () => {\n      controls.update();\n    },\n  });\n};\n\n/** ------------------------------------------------------------------\n *  (OPTIONAL) HELPER #1: Fly camera to a specific ISO code directly.\n * ------------------------------------------------------------------ */\n// This function is purely optional — it’s basically a convenience that\n// wraps getCountryCentroid and flyCameraToPoint together.\nexport function flyCameraToCountry({\n  camera,\n  controls,\n  globe,\n  isoA3,\n  dots,\n  distanceOffset = 300,\n}: {\n  camera: THREE.Camera;\n  controls: OrbitControlsImpl;\n  globe: THREE.Group;\n  isoA3: string;\n  dots: DotInfo[];\n  distanceOffset?: number;\n}) {\n  const centroid = getCountryCentroid({ isoA3, dots });\n  if (!centroid) return;\n  const worldPos = centroid.clone();\n  globe.localToWorld(worldPos);\n  flyCameraToPoint({\n    camera,\n    controls,\n    targetPos: worldPos,\n    distanceOffset,\n  });\n}\n\n/** ------------------------------------------------------------------\n *  (OPTIONAL) HELPER #2: Sort & get the nearest intersection from a pointer event.\n * ------------------------------------------------------------------ */\nexport function getNearestIntersection(\n  e: THREE.Event & { intersections?: THREE.Intersection[] }\n): THREE.Intersection | null {\n  if (!e.intersections || e.intersections.length === 0) {\n    return null;\n  }\n  // Sort by distance ascending\n  const sorted = e.intersections.sort((a, b) => a.distance - b.distance);\n  return sorted[0];\n}\n","import { useFrame } from \"@react-three/fiber\";\nimport {\n  PointerEvent,\n  RefObject,\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\nimport * as THREE from \"three\";\nimport { OrbitControls as OrbitControlsImpl } from \"three-stdlib\";\nimport { selectFocusIso } from \"../../../store/globeSlice\";\nimport { useAppSelector } from \"../../../store/hooks\";\nimport { DotInfo } from \"../../../types/earthTypes\";\nimport useAtOrAboveBreakpoint from \"../../../utils/useAtOrAboveBreakpoint\";\nimport {\n  flyCameraToPoint,\n  getCountryCentroid,\n  getNearestIntersection,\n} from \"../utils/earthMath\";\n\nexport interface ContinentDotsProps {\n  jsonUrl: string;\n  pointSize: number;\n  onCountrySelect?: (iso: string) => void;\n  dotColor: string;\n  highlightColor: string;\n  onLoaded?: (loaded: boolean) => void;\n  globeRef?: RefObject<THREE.Group | null>;\n  controlsRef?: RefObject<OrbitControlsImpl | null>;\n  cameraRef?: RefObject<THREE.Camera | null>;\n}\n\n/**\n * A point cloud representing countries on the globe.\n * - Fetches dot coordinates (x,y,z).\n * - Handles highlighting & rotation when focusIso changes.\n */\nconst ContinentDots = ({\n  jsonUrl,\n  pointSize,\n  onCountrySelect,\n  onLoaded,\n  dotColor,\n  highlightColor,\n  globeRef,\n  controlsRef,\n  cameraRef,\n}: ContinentDotsProps) => {\n  const focusIso = useAppSelector(selectFocusIso);\n  const [dots, setDots] = useState<DotInfo[]>([]);\n\n  // -------------------- Highlighting Logic --------------------\n  const highlightRef = useRef<string | null>(null);\n  const highlightTimerRef = useRef<NodeJS.Timeout | null>(null);\n\n  // -------------------- Pointer / Drag Detection --------------------\n  const pointerDownPositionRef = useRef<{ x: number; y: number } | null>(null);\n  const isDraggingRef = useRef<boolean>(false);\n  const pointerDownDotIndexRef = useRef<number | null>(null);\n\n  const isSmUp = useAtOrAboveBreakpoint(\"sm\");\n\n  // -------------------- Pre-Converted Colors (Base & Highlight) --------------------\n  const [baseR, baseG, baseB] = useMemo(() => {\n    const color = new THREE.Color(dotColor);\n    return [color.r, color.g, color.b];\n  }, [dotColor]);\n\n  const [highlightR, highlightG, highlightB] = useMemo(() => {\n    const color = new THREE.Color(highlightColor);\n    return [color.r, color.g, color.b];\n  }, [highlightColor]);\n\n  // -------------------- Fetch Country Dots on Mount --------------------\n  useEffect(() => {\n    const fetchDots = async () => {\n      try {\n        const response = await fetch(jsonUrl);\n        const data: DotInfo[] = await response.json();\n        console.log(\"Loaded landDots.json:\", data);\n        setDots(data);\n        onLoaded?.(true);\n      } catch (err) {\n        console.error(\"Failed to load landDots.json:\", err);\n      }\n    };\n\n    fetchDots();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [jsonUrl]);\n\n  // -------------------- Fly to Country / Focus Handling --------------------\n  const handleFlyToIso = useCallback(\n    (isoCode: string) => {\n      if (!controlsRef?.current || !cameraRef?.current || !globeRef?.current) {\n        return;\n      }\n\n      // 1) Get the 3D centroid of that ISO\n      const centroidVec = getCountryCentroid({ isoA3: isoCode, dots });\n      if (!centroidVec) return;\n\n      // 2) Convert centroid from local space (globeRef) to world space\n      const worldPos = centroidVec.clone();\n      globeRef.current.localToWorld(worldPos);\n\n      // 3) Fly camera to the new position\n      flyCameraToPoint({\n        camera: cameraRef.current,\n        controls: controlsRef.current,\n        targetPos: worldPos,\n        distanceOffset: isSmUp ? 380 : 480,\n      });\n    },\n    [cameraRef, controlsRef, globeRef, dots]\n  );\n\n  // Whenever focusIso changes, highlight + fly\n  useEffect(() => {\n    if (!focusIso || dots.length === 0) {\n      highlightRef.current = null;\n      return;\n    }\n    highlightRef.current = focusIso;\n\n    if (globeRef?.current) {\n      handleFlyToIso(focusIso);\n    }\n  }, [focusIso, dots, globeRef, handleFlyToIso]);\n\n  // -------------------- Geometry: Positions & Colors --------------------\n  const positions = useMemo(() => {\n    if (!dots.length) return new Float32Array(0);\n    const arr = dots.flatMap((d) => [d.x, d.y, d.z]);\n    return new Float32Array(arr);\n  }, [dots]);\n\n  const colors = useMemo(() => {\n    if (!dots.length) return new Float32Array(0);\n    // For each dot, push the base color\n    const arr: number[] = [];\n    for (let i = 0; i < dots.length; i++) {\n      arr.push(baseR, baseG, baseB);\n    }\n    return new Float32Array(arr);\n  }, [dots, baseR, baseG, baseB]);\n\n  // We'll store an explicit ref to the color attribute so we can update it each frame\n  const colorAttrRef = useRef<THREE.BufferAttribute>(null);\n\n  // -------------------- Pointer Events --------------------\n  const handlePointerDown = useCallback((event: PointerEvent) => {\n    pointerDownPositionRef.current = { x: event.clientX, y: event.clientY };\n    isDraggingRef.current = false;\n    pointerDownDotIndexRef.current = null;\n\n    const nearestIntersection = getNearestIntersection(event);\n    pointerDownDotIndexRef.current = nearestIntersection?.index ?? null;\n\n    event.stopPropagation();\n  }, []);\n\n  const handlePointerMove = useCallback((event: PointerEvent) => {\n    if (!pointerDownPositionRef.current) return;\n    const dx = event.clientX - pointerDownPositionRef.current.x;\n    const dy = event.clientY - pointerDownPositionRef.current.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    // If we moved the pointer a certain threshold, treat it as a drag\n    if (distance > 20) {\n      isDraggingRef.current = true;\n    }\n    event.stopPropagation();\n  }, []);\n\n  const handlePointerUp = useCallback(\n    (event: PointerEvent) => {\n      if (!dots.length || !pointerDownDotIndexRef.current) return;\n\n      // If there's no intersection, do nothing\n      const nearestIntersection = getNearestIntersection(event);\n      if (!nearestIntersection) return;\n\n      // Is the dot the same one we pointer-downed on?\n      if (\n        nearestIntersection.index !== pointerDownDotIndexRef.current ||\n        isDraggingRef.current\n      ) {\n        // We either dragged or clicked a different dot\n        pointerDownPositionRef.current = null;\n        pointerDownDotIndexRef.current = null;\n        return;\n      }\n\n      // We are clicking on the same dot\n      const idx = nearestIntersection.index;\n      const dot = dots[idx];\n      if (!dot) return;\n\n      console.log(\n        `Clicked dot #${idx} → Country=${dot.countryName}, ISO=${dot.isoA3}`\n      );\n\n      // 1) Fire onCountrySelect if needed\n      onCountrySelect?.(dot.isoA3);\n\n      // 2) Fly to it\n      handleFlyToIso(dot.isoA3);\n\n      // 3) Temporarily highlight this country\n      highlightRef.current = dot.isoA3;\n      if (highlightTimerRef.current) {\n        clearTimeout(highlightTimerRef.current);\n      }\n      highlightTimerRef.current = setTimeout(() => {\n        highlightRef.current = null;\n      }, 2000);\n\n      // Reset\n      pointerDownPositionRef.current = null;\n      pointerDownDotIndexRef.current = null;\n      isDraggingRef.current = false;\n      event.stopPropagation();\n    },\n    [dots, onCountrySelect, handleFlyToIso]\n  );\n\n  // -------------------- Animate the Dot Colors --------------------\n  useFrame(() => {\n    if (!colorAttrRef.current || !dots.length) return;\n    const colorArray = colorAttrRef.current.array as Float32Array;\n\n    for (let i = 0; i < dots.length; i++) {\n      const dot = dots[i];\n      const offset = i * 3;\n\n      // If dot isoA3 matches the highlightRef, use highlight color\n      if (highlightRef.current === dot.isoA3) {\n        colorArray[offset] = highlightR;\n        colorArray[offset + 1] = highlightG;\n        colorArray[offset + 2] = highlightB;\n      } else {\n        // revert to base color\n        colorArray[offset] = baseR;\n        colorArray[offset + 1] = baseG;\n        colorArray[offset + 2] = baseB;\n      }\n    }\n    colorAttrRef.current.needsUpdate = true;\n  });\n\n  // -------------------- Early return if no dots loaded --------------------\n  if (!dots.length) return null;\n\n  // -------------------- Render the Point Cloud --------------------\n  return (\n    <points\n      onPointerDown={handlePointerDown}\n      onPointerMove={handlePointerMove}\n      onPointerUp={handlePointerUp}\n    >\n      <bufferGeometry>\n        <bufferAttribute\n          attach=\"attributes-position\"\n          args={[positions, 3]}\n          count={positions.length / 3}\n          itemSize={3}\n        />\n        <bufferAttribute\n          ref={colorAttrRef}\n          attach=\"attributes-color\"\n          args={[colors, 3]}\n          count={colors.length / 3}\n          itemSize={3}\n        />\n      </bufferGeometry>\n      <pointsMaterial\n        vertexColors\n        size={pointSize}\n        sizeAttenuation\n        transparent\n        opacity={0.8}\n      />\n    </points>\n  );\n};\n\nexport default ContinentDots;\n","import { useRef } from \"react\";\nimport * as THREE from \"three\";\n\ninterface HaloProps {\n  radius?: number;\n  scaleFactor?: number;\n  color?: string;\n  power?: number;\n  intensity?: number;\n  opacity?: number;\n}\n\nexport default function Halo({\n  radius = 150,\n  scaleFactor = 1.009,\n  color = \"#00aaff\",\n  power = 5.0,\n  intensity = 1.5,\n  opacity = 0.8,\n}: HaloProps) {\n  const meshRef = useRef<THREE.Mesh>(null);\n\n  return (\n    <mesh ref={meshRef} scale={[scaleFactor, scaleFactor, scaleFactor]}>\n      <sphereGeometry args={[radius, 128, 128]} />\n      <shaderMaterial\n        vertexShader={`\n          varying vec3 vNormal;\n          varying vec3 vViewPosition;\n          \n          void main() {\n            vNormal = normalize(normalMatrix * normal);\n            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n            vViewPosition = -mvPosition.xyz;\n            gl_Position = projectionMatrix * mvPosition;\n          }\n        `}\n        fragmentShader={`\n          uniform vec3 uColor;\n          uniform float uIntensity;\n          uniform float uOpacity;\n          uniform float uPower;\n          \n          varying vec3 vNormal;\n          varying vec3 vViewPosition;\n          \n          void main() {\n            vec3 normal = normalize(vNormal);\n            vec3 viewDir = normalize(vViewPosition);\n            \n            float rim = 1.0 - abs(dot(viewDir, normal));\n            rim = pow(rim, uPower) * uIntensity;\n            \n            gl_FragColor = vec4(uColor * rim, rim * uOpacity);\n          }\n        `}\n        uniforms={{\n          uColor: { value: new THREE.Color(color) },\n          uIntensity: { value: intensity },\n          uOpacity: { value: opacity },\n          uPower: { value: power },\n        }}\n        transparent={true}\n        side={THREE.BackSide}\n        depthWrite={false}\n        blending={THREE.AdditiveBlending}\n      />\n    </mesh>\n  );\n}\n","import { useFrame } from \"@react-three/fiber\";\nimport { useEffect, useRef, useState } from \"react\";\nimport * as THREE from \"three\";\nimport { lerp } from \"three/src/math/MathUtils\";\nimport { selectFocusIso } from \"../../../store/globeSlice\";\nimport { useAppSelector } from \"../../../store/hooks\";\nimport { AllArcsBehavior, ArcLocation } from \"../../../types/earthTypes\";\nimport useAtOrAboveBreakpoint from \"../../../utils/useAtOrAboveBreakpoint\";\nimport { EARTH_RADIUS } from \"../EarthScene\";\nimport { getArcsFromTrip } from \"../utils/tripMath\";\nimport { trips } from \"../utils/trips\";\nimport ArcGroup, { ArcGroupProps } from \"./arcs/ArcGroup\";\nimport Atmosphere, { AtmosphereProps } from \"./Atmosphere\";\nimport BaseSphere from \"./BaseSphere\";\nimport { CityMarkersProps } from \"./CityMarkerGroup\";\nimport ContinentDots, { ContinentDotsProps } from \"./ContinentDots\";\nimport Halo from \"./Halo\";\n\ninterface GlobeProps {\n  radius: number;\n  rotationSpeed: number;\n  dots?: ContinentDotsProps;\n  atmosphere?: AtmosphereProps;\n  arcs?: ArcGroupProps & { persistArcBehavior: AllArcsBehavior };\n  cityMarkers?: CityMarkersProps;\n}\n\n/**\n * 3D Interactive Globe Component\n * - Features: Earth's sphere, atmosphere, continent dots, and animated arcs.\n * - Responsive Scaling: Adjusts based on breakpoints (XS, SM, MD).\n * - Animation: Handles rotation and smooth scaling after data loads.\n *\n * Props:\n * - radius: Base radius of the globe.\n * - rotationSpeed: Speed of Y-axis rotation (radians/frame).\n * - isInteracting: Pauses auto-rotation when true.\n * - dots: Configuration for continent dots.\n * - atmosphere: Atmospheric glow configuration.\n * - arcs: Flight arc animation configuration.\n */\nconst Globe = ({\n  radius,\n  rotationSpeed,\n  arcs,\n  atmosphere,\n  dots,\n  cityMarkers,\n}: GlobeProps) => {\n  const globeRef = useRef<THREE.Group>(null);\n\n  // Breakpoints for final scale\n  const isMdUp = useAtOrAboveBreakpoint(\"md\");\n  const isSmUp = useAtOrAboveBreakpoint(\"sm\");\n  const isXSUp = useAtOrAboveBreakpoint(\"xs\");\n\n  let targetScale = 1.0;\n  if (isMdUp) {\n    targetScale = 1.0;\n  } else if (isSmUp) {\n    targetScale = 0.8;\n  } else if (isXSUp) {\n    targetScale = 0.7;\n  } else {\n    targetScale = 0.6;\n  }\n\n  const [currentScale, setCurrentScale] = useState(0.55);\n  const [dotsLoaded, setDotsLoaded] = useState(false);\n\n  // 1) Read the currently selected ISO from Redux\n  const focusIso = useAppSelector(selectFocusIso);\n\n  // 2) State for \"ephemeral\" arcs triggered by a country button\n  const [highlightArcs, setHighlightArcs] = useState<ArcLocation[]>([]);\n  const [highlightArcKey, setHighlightArcKey] = useState(0);\n\n  useEffect(() => {\n    setHighlightArcs([]);\n    if (!focusIso) return;\n    console.log(\"ISO FOCUSED!\", focusIso);\n    // Filter trips that have this iso in trip.countries\n    const matchedTrips = trips.filter((t) => t.countries.includes(focusIso));\n    console.log(\"Matched trips\", matchedTrips);\n    setHighlightArcKey((prev) => prev + 1);\n\n    // Flatten all matched trips into arcs\n    const allArcs = matchedTrips.flatMap((trip) => getArcsFromTrip(trip));\n    console.log(\"All arcs\", allArcs);\n    // Store them in state\n    setHighlightArcs(allArcs);\n    if (\n      !dots?.controlsRef?.current ||\n      !dots?.cameraRef?.current ||\n      !globeRef.current\n    )\n      return;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [focusIso]);\n\n  useFrame((_, delta) => {\n    if (!globeRef.current) return;\n\n    // 1) Only rotate if not interacting\n    if (!focusIso) {\n      globeRef.current.rotation.y += rotationSpeed;\n    }\n\n    const scaleSpeed = 2.0;\n    setCurrentScale((prev) => lerp(prev, targetScale, delta * scaleSpeed));\n  });\n\n  return (\n    <group visible={dotsLoaded} ref={globeRef} scale={currentScale}>\n      <BaseSphere radius={radius - 1} />\n      {!!atmosphere && (\n        <Atmosphere\n          earthRadius={radius - 2}\n          color={atmosphere.color}\n          opacity={atmosphere.opacity}\n        />\n      )}\n      <Halo radius={150} />\n      {!!dots && (\n        <ContinentDots\n          jsonUrl={dots.jsonUrl}\n          dotColor={dots.dotColor}\n          pointSize={dots.pointSize}\n          onLoaded={(isLoaded) => setDotsLoaded(isLoaded)}\n          globeRef={globeRef}\n          controlsRef={dots.controlsRef}\n          cameraRef={dots.cameraRef}\n          highlightColor={dots.highlightColor}\n        />\n      )}\n\n      {/* {!!cityMarkers && (\n        <CityMarkers\n          cities={cityMarkers.cities}\n          radius={cityMarkers.radius}\n          color={cityMarkers.color}\n          markerSize={cityMarkers.markerSize}\n        />\n      )} */}\n      {!!arcs && !highlightArcs.length && (\n        <ArcGroup\n          animationDuration={arcs.animationDuration}\n          color={arcs.color}\n          locationArray={arcs.locationArray}\n          onAllArcsDone={arcs.onAllArcsDone}\n          onProgressPersist={arcs.onProgressPersist}\n          radius={arcs.radius}\n          infiniteRandom={arcs.infiniteRandom}\n          persistArcBehavior={arcs.persistArcBehavior}\n        />\n      )}\n      {highlightArcs.length > 0 && !!arcs && (\n        <ArcGroup\n          key={highlightArcKey}\n          locationArray={highlightArcs}\n          color={arcs.color}\n          radius={EARTH_RADIUS}\n          firstAnimationDuration={1500}\n          animationDuration={500}\n          // arcMode={\"sequential\"}\n          onProgressPersist={false}\n          onAllArcsDone=\"remove\"\n          persistArcBehavior={undefined}\n        />\n      )}\n      {/* <ManualBloom bloomStrength={1.2} bloomRadius={1} bloomThreshold={0.3} /> */}\n    </group>\n  );\n};\n\nexport default Globe;\n","import { RefObject, useEffect } from \"react\";\nimport * as THREE from \"three\";\nimport { EARTH_RADIUS } from \"./EarthScene\";\n\ninterface SceneHelpersProps {\n  axesHelperRef: RefObject<THREE.AxesHelper | null>;\n  cameraRef: RefObject<THREE.Camera | null>;\n}\n\nconst SceneHelpers = ({ axesHelperRef, cameraRef }: SceneHelpersProps) => {\n  useEffect(() => {\n    if (axesHelperRef.current) {\n      axesHelperRef.current.visible = true;\n    }\n  }, [axesHelperRef]);\n\n  return (\n    <>\n      <primitive\n        ref={axesHelperRef}\n        object={new THREE.AxesHelper(500).setColors(\"red\", \"white\", \"blue\")}\n      />\n      <gridHelper args={[1000, 50]} />\n      <primitive\n        object={\n          new THREE.BoxHelper(\n            new THREE.Mesh(new THREE.SphereGeometry(EARTH_RADIUS))\n          )\n        }\n      />\n      {cameraRef.current && (\n        <primitive object={new THREE.CameraHelper(cameraRef.current)} />\n      )}\n      <polarGridHelper args={[EARTH_RADIUS, 16, 8, 64]} />\n    </>\n  );\n};\n\nexport default SceneHelpers;\n","import { OrbitControls } from \"@react-three/drei\";\nimport { Canvas } from \"@react-three/fiber\";\nimport { Suspense, useRef } from \"react\";\nimport * as THREE from \"three\";\nimport { OrbitControls as OrbitControlsImpl } from \"three-stdlib\";\nimport useAtOrAboveBreakpoint from \"../../utils/useAtOrAboveBreakpoint\";\nimport Globe from \"./layers/Globe\";\nimport SceneHelpers from \"./SceneHelpers\";\nimport { flattenAllTrips, getArcCities } from \"./utils/tripMath\";\nimport { trips } from \"./utils/trips\";\n\nconst MAX_ZOOMED_OUT = 600;\nexport const EARTH_RADIUS = 150;\n\ninterface EarthSceneProps {\n  enableHelpers?: boolean;\n}\n\n/**\n * A top-level 3D Earth component that:\n * - Sets up a Three.js Canvas with OrbitControls and performance stats.\n * - Renders the `Globe` component and optional post-processing (ManualBloom).\n */\nconst EarthScene = ({ enableHelpers }: EarthSceneProps) => {\n  // Refs for Three.js objects\n  const controlsRef = useRef<OrbitControlsImpl>(null);\n  const axesHelperRef = useRef<THREE.AxesHelper | null>(null);\n  const cameraRef = useRef<THREE.Camera | null>(null);\n  // const isoFocused = useAppSelector(selectFocusIso);\n\n  const isSmallUp = useAtOrAboveBreakpoint(\"sm\");\n  const jsonUrl = isSmallUp\n    ? \"/landDots-150rad-40k.json\" // more dots\n    : \"/landDots-150rad-30k.json\"; // fewer dots\n\n  const isXLUp = useAtOrAboveBreakpoint(\"xl\");\n  const isSmUp = useAtOrAboveBreakpoint(\"sm\");\n\n  // useEffect(() => {\n  //   if (!!isoFocused) {\n  //     // Get markers from cities const cities = getArcCities(get)\n  //   }\n  // }, [isoFocused]);\n\n  return (\n    <Canvas\n      gl={{ alpha: true }}\n      style={{ background: \"transparent\" }}\n      camera={{ position: [0, 400, 900], fov: 35 }}\n      onCreated={(state) => {\n        cameraRef.current = state.camera; // Store camera reference\n        state.camera.updateProjectionMatrix();\n        const offsetX = isXLUp ? state.size.width * 0.2 : 0;\n        const offsetY = isSmUp ? 0 : state.size.height * 0.07;\n        state.camera.setViewOffset(\n          /* fullWidth  */ state.size.width,\n          /* fullHeight */ state.size.height,\n          /* offsetX    */ offsetX,\n          /* offsetY    */ offsetY,\n          /* width      */ state.size.width,\n          /* height     */ state.size.height\n        );\n\n        state.raycaster.params.Points.threshold = 2;\n      }}\n    >\n      <OrbitControls\n        ref={controlsRef}\n        enableDamping={true}\n        minDistance={300}\n        minPolarAngle={0.3} // ~17 degrees\n        maxPolarAngle={Math.PI - 0.3} // ~163 degrees\n        enablePan={false}\n        maxDistance={MAX_ZOOMED_OUT}\n      />\n      <directionalLight\n        intensity={2.0}\n        position={[-300, 200, 100]} // Some offset from Earth\n      />\n      <hemisphereLight intensity={0.5} position={[100, 100, 0]} />\n      <Suspense fallback={null}>\n        <Globe\n          rotationSpeed={0.0002}\n          radius={EARTH_RADIUS}\n          dots={{\n            dotColor: \"#44ff00\",\n            highlightColor: \"#86d4fc\",\n            pointSize: 2.5,\n            jsonUrl,\n            controlsRef,\n            cameraRef,\n          }}\n          atmosphere={{\n            color: \"#00aaff\",\n            opacity: 0.03, // I fear this isn't hooked up to anything\n            earthRadius: EARTH_RADIUS,\n          }}\n          arcs={{\n            locationArray: flattenAllTrips(trips),\n            color: \"#dd6ff0\",\n            radius: EARTH_RADIUS,\n            animationDuration: 1000,\n            onProgressPersist: false,\n            infiniteRandom: true,\n            persistArcBehavior: undefined,\n          }}\n          cityMarkers={{\n            cities: getArcCities(flattenAllTrips(trips)),\n            radius: EARTH_RADIUS,\n            color: \"#dd6ff0\",\n            markerSize: 1,\n          }}\n        />\n      </Suspense>\n      {enableHelpers && (\n        <SceneHelpers axesHelperRef={axesHelperRef} cameraRef={cameraRef} />\n      )}\n    </Canvas>\n  );\n};\n\nexport default EarthScene;\n","import EarthScene from \"../../components/earth/EarthScene\";\nimport {\n  flattenAllIsos,\n  flattenAllTrips,\n  getArcCities,\n} from \"../../components/earth/utils/tripMath\";\nimport { trips } from \"../../components/earth/utils/trips\";\n\nconst TheGlobeProject = () => {\n  const isos = flattenAllIsos(trips);\n  const cities = Array.from(new Set(getArcCities(flattenAllTrips(trips))));\n  return (\n    <div className=\"relative w-full h-full\">\n      {/* Full-screen Earth in the background */}\n      <div className=\"absolute inset-0 pointer-events-auto\">\n        <EarthScene />\n      </div>\n      {/* Right half overlay (non-blocking by default) */}\n      <div className=\"flex absolute top-0 right-0 w-full lg:w-1/2 h-full items-end lg:items-center justify-center pointer-events-none z-10\">\n        {/* Make the actual text clickable */}\n        <div className=\"flex flex-col pointer-events-auto text-2xl items-center px-2 pb-8 sm:text-4xl sm:flex-start lg:pb-0 sm:px-0\">\n          <div className=\"flex mb-2 sm:mb-4\">Travels in 2024</div>\n          <div className=\"flex flex-row gap-2\">\n            {/* <CountryButtons isos={isos} /> */}\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default TheGlobeProject;\n","import { useParams } from \"react-router-dom\";\nimport TheGlobeProject from \"../../projects/globe-project/TheGlobeProjects\";\n\nconst ProjectDetails = () => {\n  const { projectSlug } = useParams();\n\n  switch (projectSlug) {\n    case \"earth\":\n      return <TheGlobeProject />;\n    default:\n      return <div>Oops! Project not found.</div>;\n  }\n};\n\nexport default ProjectDetails;\n","import { useEffect, useState } from \"react\";\n\n// Tailwind's default breakpoints in pixels\nconst BREAKPOINTS = {\n  xs: 320,\n  sm: 640,\n  md: 768,\n  lg: 1024,\n  xl: 1280,\n  \"2xl\": 1536,\n};\n\ntype TailwindBreakpoint = keyof typeof BREAKPOINTS;\n\n/**\n * Usage:\n *   const isLargeUp = useTailwindBreakpoint(\"lg\");\n *   // returns true if window width >= 1024\n */\nconst useAtOrAboveBreakpoint = (breakpoint: TailwindBreakpoint) => {\n  const [matches, setMatches] = useState(false);\n\n  useEffect(() => {\n    function handleResize() {\n      const newMatches = window.innerWidth >= BREAKPOINTS[breakpoint];\n      // Only update state if the value actually changed\n      setMatches((old) => {\n        if (old !== newMatches) {\n          return newMatches;\n        }\n        return old;\n      });\n    }\n\n    window.addEventListener(\"resize\", handleResize);\n    handleResize();\n    return () => window.removeEventListener(\"resize\", handleResize);\n  }, [breakpoint]);\n\n  return matches;\n};\n\nexport default useAtOrAboveBreakpoint;\n"],"names":["useAppSelector","useSelector","flattenAllTrips","trips","flatMap","trip","legs","arcs","i","length","push","start","end","getArcsFromLegs","getArcCities","cities","id","title","description","startDate","endDate","images","countries","lat","lon","name","iso","latLongToVector3","radius","phi","Math","PI","theta","x","sin","cos","z","y","THREE","_ref","flights","color","behavior","opacity","setOpacity","useState","useEffect","elapsed","flickerInterval","totalDuration","intervalId","setInterval","random","clearInterval","frameId","startTime","performance","now","duration","animate","t","min","requestAnimationFrame","cancelAnimationFrame","arcGeometries","useMemo","map","flight","buildAllArcs","startLat","startLon","endLat","endLon","startVec","endVec","midPoint","addVectors","multiplyScalar","arcHeight","distanceTo","setLength","control1","lerpVectors","control2","curve","_jsx","_Fragment","children","geometry","index","transparent","position","onDone","groupRef","useRef","dotRef","ringRef","FINAL_SCALE","dotScale","setDotScale","ringScale","setRingScale","ringOpacity","setRingOpacity","lengthSq","normal","clone","normalize","zAxis","quat","setFromUnitVectors","current","quaternion","copy","useFrame","newRingScale","_jsxs","ref","scale","args","side","depthTest","PartialCurve","constructor","baseCurve","minT","maxT","super","this","getPoint","optionalTarget","u","animationDuration","onProgressPersist","meshRef","geometryRef","done","setDone","showLandingEffect","setShowLandingEffect","fullCurve","tubeGeometry","indexCount","count","attributes","drawCount","floor","setDrawRange","extendP","retractP","startParam","endParam","visible","partialCurve","newGeom","dispose","object","attach","LandingEffect","randomInt","max","ArcGroup","locationArray","firstAnimationDuration","onAllArcsDone","persistArcBehavior","infiniteRandom","spawnInterval","arcsToRender","setArcsToRender","arcsTriggered","setArcsTriggered","arcsCompleted","setArcsCompleted","showFinalArcs","setShowFinalArcs","arcsDoneCount","setArcsDoneCount","spawnIntervalRef","normalResetAll","coordinatePoints","newArcs","Array","fill","infiniteStart","newArc","allPoints","startIdx","endIdx","createRandomArc","prev","forEach","_arc","delay","setTimeout","stillActiveArcs","filter","_a","stillActiveTriggered","stillActiveCompleted","arc","AllArcsStaticMesh","arcDuration","ArcLight","AtmosphereShader","uniforms","uColor","value","uIntensity","uPower","uOpacity","vertexShader","fragmentShader","earthRadius","depthWrite","blending","_objectSpread","emissive","shininess","emissiveIntensity","specular","getCountryCentroid","isoA3","dots","countryDots","d","sumX","sumY","sumZ","flyCameraToPoint","_ref2","camera","controls","targetPos","distanceOffset","newCamPos","gsap","to","ease","onUpdate","update","getNearestIntersection","e","intersections","sort","a","b","distance","jsonUrl","pointSize","onCountrySelect","onLoaded","dotColor","highlightColor","globeRef","controlsRef","cameraRef","focusIso","selectFocusIso","setDots","highlightRef","highlightTimerRef","pointerDownPositionRef","isDraggingRef","pointerDownDotIndexRef","isSmUp","useAtOrAboveBreakpoint","baseR","baseG","baseB","r","g","highlightR","highlightG","highlightB","async","response","fetch","data","json","console","log","err","error","fetchDots","handleFlyToIso","useCallback","isoCode","centroidVec","worldPos","localToWorld","positions","Float32Array","arr","colors","colorAttrRef","handlePointerDown","event","_nearestIntersection$","clientX","clientY","nearestIntersection","stopPropagation","handlePointerMove","dx","dy","sqrt","handlePointerUp","idx","dot","concat","countryName","clearTimeout","colorArray","array","offset","needsUpdate","onPointerDown","onPointerMove","onPointerUp","itemSize","vertexColors","size","sizeAttenuation","Halo","scaleFactor","power","intensity","rotationSpeed","atmosphere","cityMarkers","isMdUp","isXSUp","targetScale","currentScale","setCurrentScale","dotsLoaded","setDotsLoaded","highlightArcs","setHighlightArcs","highlightArcKey","setHighlightArcKey","_dots$controlsRef","_dots$cameraRef","matchedTrips","includes","allArcs","getArcsFromTrip","_","delta","rotation","lerp","BaseSphere","Atmosphere","ContinentDots","isLoaded","EARTH_RADIUS","undefined","axesHelperRef","setColors","enableHelpers","isXLUp","Canvas","gl","alpha","style","background","fov","onCreated","state","updateProjectionMatrix","offsetX","width","offsetY","height","setViewOffset","raycaster","params","Points","threshold","OrbitControls","enableDamping","minDistance","minPolarAngle","maxPolarAngle","enablePan","maxDistance","Suspense","fallback","Globe","markerSize","SceneHelpers","TheGlobeProject","from","Set","_trip$countries","flattenAllIsos","className","EarthScene","ProjectDetails","projectSlug","useParams","BREAKPOINTS","xs","sm","md","lg","xl","breakpoint","matches","setMatches","handleResize","newMatches","window","innerWidth","old","addEventListener","removeEventListener"],"sourceRoot":""}