{"version":3,"file":"static/js/621.1705dfeb.chunk.js","mappings":"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","sources":["webpack://homebase/./src/css/typewriter.module.css?13c8","components/Typewriter.tsx","components/earth/utils/arcs.ts","components/earth/layers/arcs/AllArcsStaticMesh.tsx","components/earth/layers/arcs/LandingEffect.tsx","components/earth/layers/arcs/Arc.tsx","components/earth/layers/arcs/ArcGroup.tsx","components/earth/utils/AtmosphereShader.ts","components/earth/layers/Atmosphere.tsx","components/earth/layers/BaseSphere.tsx","components/earth/layers/helpers/CityMarker.tsx","components/earth/layers/CityMarkerGroup.tsx","components/earth/layers/ContinentDots.tsx","components/earth/layers/Globe.tsx","components/earth/layers/ManualBlooms.tsx","components/earth/utils/flightPaths.ts","components/earth/Earth.tsx","projects/TheGlobeProjects.tsx","pages/project-details/ProjectDetails.tsx","utils/useAtOrAboveBreakpoint.ts"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport default {\"blink\":\"typewriter_blink__KoZUv\"};","import { useEffect, useState } from \"react\";\nimport styles from \"../css/typewriter.module.css\";\nimport { useLinkColor } from \"../utils/ColorContext\";\n\ninterface TypewriterProps {\n  phrases: string[];\n  period?: number;\n  typingSpeed: number;\n  deletingSpeed: number;\n  loop?: boolean;\n  preserveTrailingNewlines?: boolean;\n}\n\nfunction findPrefixOverlap(a: string, b: string): number {\n  let i = 0;\n  while (i < a.length && i < b.length && a[i] === b[i]) {\n    i++;\n  }\n  return i;\n}\n\nfunction preserveTrailingNewlinesInOverlap(\n  currentPhrase: string,\n  rawOverlapLength: number\n) {\n  if (rawOverlapLength >= currentPhrase.length) return rawOverlapLength;\n  const leftover = currentPhrase.slice(rawOverlapLength);\n  if (/^[\\n\\s]+$/.test(leftover)) {\n    return currentPhrase.length;\n  }\n  return rawOverlapLength;\n}\n\nconst Typewriter = ({\n  phrases,\n  period = 2000,\n  typingSpeed,\n  deletingSpeed,\n  loop = true,\n  preserveTrailingNewlines = false,\n}: TypewriterProps) => {\n  const [phase, setPhase] = useState<\"typing\" | \"deleting\" | \"pause\">(\"typing\");\n  const [index, setIndex] = useState(0);\n  const [charIndex, setCharIndex] = useState(0);\n\n  const { linkColor } = useLinkColor();\n\n  // Whenever phrases changes, reset the typewriter\n  useEffect(() => {\n    setPhase(\"typing\");\n    setIndex(0);\n    setCharIndex(0);\n  }, [phrases]);\n\n  const isLastPhrase = !loop && index === phrases.length - 1;\n\n  const currentPhrase = phrases[index] ?? \"\";\n  const nextPhrase = isLastPhrase ? \"\" : phrases[(index + 1) % phrases.length];\n\n  let overlapLength = findPrefixOverlap(currentPhrase, nextPhrase);\n  if (preserveTrailingNewlines) {\n    overlapLength = preserveTrailingNewlinesInOverlap(\n      currentPhrase,\n      overlapLength\n    );\n  }\n\n  useEffect(() => {\n    if (phase === \"typing\") {\n      if (charIndex < currentPhrase.length) {\n        // Slow down for newlines / periods\n        const nextChar = currentPhrase[charIndex];\n        let currentTypingSpeed = typingSpeed;\n        if (nextChar === \".\" || nextChar === \"\\n\") {\n          currentTypingSpeed *= 2;\n        }\n\n        const timeoutId = setTimeout(() => {\n          setCharIndex((c) => c + 1);\n        }, currentTypingSpeed);\n        return () => clearTimeout(timeoutId);\n      } else {\n        // Done typing; pause\n        const pauseId = setTimeout(() => {\n          setPhase(\"pause\");\n        }, period);\n        return () => clearTimeout(pauseId);\n      }\n    } else if (phase === \"pause\") {\n      if (isLastPhrase) return;\n      setPhase(\"deleting\");\n    } else if (phase === \"deleting\") {\n      if (charIndex > overlapLength) {\n        // Slow down for newlines / periods\n        const prevChar = currentPhrase[charIndex - 1];\n        let currentDeletingSpeed = deletingSpeed;\n        if (prevChar === \".\" || prevChar === \"\\n\") {\n          currentDeletingSpeed *= 2;\n        }\n\n        const timeoutId = setTimeout(() => {\n          setCharIndex((c) => c - 1);\n        }, currentDeletingSpeed);\n        return () => clearTimeout(timeoutId);\n      } else {\n        // If looping, move on; otherwise just end\n        setIndex((i) => (loop ? (i + 1) % phrases.length : i + 1));\n        setPhase(\"typing\");\n      }\n    }\n  }, [\n    phase,\n    charIndex,\n    currentPhrase,\n    overlapLength,\n    period,\n    typingSpeed,\n    deletingSpeed,\n    index,\n    nextPhrase,\n    isLastPhrase,\n    loop,\n    phrases.length,\n  ]);\n\n  const display = currentPhrase.slice(0, charIndex);\n\n  function renderWithLineBreaks(text: string) {\n    return text.split(\"\\n\").map((segment, i, arr) => (\n      <span key={i}>\n        {segment}\n        {i < arr.length - 1 && <br />}\n      </span>\n    ));\n  }\n\n  return (\n    <div>\n      {renderWithLineBreaks(display)}\n      <span\n        className={`border-r-[2.5px] solid ml-[1.8px] ${styles.blink}`}\n        style={{ borderColor: linkColor }}\n      />\n    </div>\n  );\n};\n\nexport default Typewriter;\n","import * as THREE from \"three\";\n\n/**\n * Convert latitude & longitude to a THREE.Vector3 on a sphere.\n * @param lat   latitude in degrees\n * @param lon   longitude in degrees\n * @param radius sphere radius\n */\nexport const latLongToVector3 = (lat: number, lon: number, radius: number) => {\n  const phi = (90 - lat) * (Math.PI / 180);\n  const theta = (lon + 180) * (Math.PI / 180);\n\n  const x = -radius * Math.sin(phi) * Math.cos(theta);\n  const z = radius * Math.sin(phi) * Math.sin(theta);\n  const y = radius * Math.cos(phi);\n\n  return new THREE.Vector3(x, y, z);\n};\n\n/**\n * buildFullArcGeometry\n *\n * Creates a THREE.TubeGeometry for a 3D arc using the same\n * cubic-bezier control logic that your animated ArcLight uses.\n */\nexport const buildAllArcs = (\n  startLat: number,\n  startLon: number,\n  endLat: number,\n  endLon: number,\n  radius: number\n) => {\n  const startVec = latLongToVector3(startLat, startLon, radius);\n  const endVec = latLongToVector3(endLat, endLon, radius);\n\n  // Approx midpoint logic\n  const midPoint = new THREE.Vector3()\n    .addVectors(startVec, endVec)\n    .multiplyScalar(0.5);\n  const distance = startVec.distanceTo(endVec);\n  const arcHeight = distance * 1.5;\n  midPoint.setLength(midPoint.length() + arcHeight);\n\n  const control1 = new THREE.Vector3().lerpVectors(startVec, midPoint, 0.25);\n  const control2 = new THREE.Vector3().lerpVectors(startVec, midPoint, 0.75);\n\n  // Build a cubic bezier arc\n  const curve = new THREE.CubicBezierCurve3(\n    startVec,\n    control1,\n    control2,\n    endVec\n  );\n\n  return new THREE.TubeGeometry(curve, 64, 0.5, 8, false);\n};\n","import { useEffect, useMemo, useState } from \"react\";\nimport { AllArcsBehavior, ArcLocation } from \"../../../../types/earthTypes\";\nimport { buildAllArcs } from \"../../utils/arcs\";\n\nexport interface AllArcsStaticMeshProps {\n  /**\n   * Array of flight arc locations with start and end coordinates.\n   */\n  flights: ArcLocation[];\n  /**\n   * Base color of the arcs.\n   */\n  color: string;\n  /**\n   * Radius of the sphere on which the arcs are drawn.\n   */\n  radius: number;\n  /**\n   * Animation behavior for the arcs.\n   */\n  behavior?: AllArcsBehavior;\n}\n\n/**\n * `AllArcsStaticMesh` renders multiple arcs as static or animated meshes.\n * - Animates opacity based on the specified `behavior`.\n * - Generates arc geometries dynamically for each flight in the `flights` array.\n */\nconst AllArcsStaticMesh = ({\n  flights,\n  color,\n  radius,\n  behavior,\n}: AllArcsStaticMeshProps) => {\n  // Single opacity state shared by all arcs\n  const [opacity, setOpacity] = useState(!behavior ? 1 : 0);\n\n  useEffect(() => {\n    // If flicker is true, we do the old-timey rapid toggling.\n    if (behavior === \"flicker\") {\n      // Flicker for 1 second (1000 ms), toggling every 100 ms\n      let elapsed = 0;\n      const flickerInterval = 100;\n      const totalDuration = 1000;\n      const intervalId = setInterval(() => {\n        elapsed += flickerInterval;\n        // Randomly go 0 or 1\n        setOpacity(Math.random() < 0.5 ? 0 : 1);\n\n        // After flicker finishes, set full\n        if (elapsed >= totalDuration) {\n          clearInterval(intervalId);\n          setOpacity(1);\n        }\n      }, flickerInterval);\n\n      return () => clearInterval(intervalId);\n\n      // Else if smoothOn is true, do a modern fade from 0 to 1\n    } else if (behavior === \"smooth\") {\n      // We'll animate from 0 to 1 over 1 second\n      let frameId: number | null = null;\n      const startTime = performance.now();\n      const duration = 1000; // 1 second\n\n      const animate = (now: number) => {\n        const elapsed = now - startTime;\n        const t = Math.min(elapsed / duration, 1); // clamp 0..1\n        setOpacity(t);\n\n        if (t < 1) {\n          frameId = requestAnimationFrame(animate);\n        }\n      };\n\n      frameId = requestAnimationFrame(animate);\n      return () => {\n        if (frameId) cancelAnimationFrame(frameId);\n      };\n\n      // Otherwise, show immediately at full opacity\n    } else {\n      setOpacity(1);\n    }\n  }, [behavior]);\n\n  // Precompute the geometries\n  const arcGeometries = useMemo(() => {\n    return flights.map((flight) => {\n      return buildAllArcs(\n        flight.start.lat,\n        flight.start.lon,\n        flight.end.lat,\n        flight.end.lon,\n        radius\n      );\n    });\n  }, [flights, radius]);\n\n  return (\n    <>\n      {arcGeometries.map((geometry, index) => (\n        <mesh key={index} geometry={geometry}>\n          <meshBasicMaterial color={color} transparent opacity={opacity} />\n        </mesh>\n      ))}\n    </>\n  );\n};\n\nexport default AllArcsStaticMesh;\n","import { useFrame } from \"@react-three/fiber\";\nimport { useEffect, useRef, useState } from \"react\";\nimport * as THREE from \"three\";\n\ninterface ArcLandingEffectProps {\n  position: THREE.Vector3;\n  color?: string;\n  onDone?: () => void;\n}\n\nconst LandingEffect = ({\n  position,\n  color = \"#ffffff\",\n  onDone,\n}: ArcLandingEffectProps) => {\n  const groupRef = useRef<THREE.Group>(null!);\n\n  // If you want separate references to tweak them individually:\n  const dotRef = useRef<THREE.Mesh>(null!);\n  const ringRef = useRef<THREE.Mesh>(null!);\n\n  // Circle’s *base* radius (the dot):\n  const BASE_RADIUS = 1;\n\n  // How large do we want them to expand? (1 = same size as base, 2 = double, etc.)\n  const FINAL_SCALE = 1.3;\n\n  // Local state for scale & opacity\n  const [dotScale, setDotScale] = useState(0); // for the solid circle\n  const [ringScale, setRingScale] = useState(0); // for the expanding ring\n  const [ringOpacity, setRingOpacity] = useState(1);\n\n  // Orient the group’s +Z axis toward the point on the globe\n  useEffect(() => {\n    if (position.lengthSq() === 0) return;\n    const normal = position.clone().normalize();\n    const zAxis = new THREE.Vector3(0, 0, 1);\n    const quat = new THREE.Quaternion().setFromUnitVectors(zAxis, normal);\n    groupRef.current.quaternion.copy(quat);\n  }, [position]);\n\n  useFrame(() => {\n    // Animate dot scale: step ~6% closer to 1\n    const newDotScale = dotScale + (1 - dotScale) * 0.06;\n    setDotScale(newDotScale);\n\n    // Animate ring scale: step ~6% closer to 1\n    const newRingScale = ringScale + (1 - ringScale) * 0.06;\n    setRingScale(newRingScale);\n\n    // Fade ring out as it nears full scale\n    const newOpacity = 1 - newRingScale;\n    setRingOpacity(newOpacity);\n\n    // Once it's mostly expanded, remove it\n    if (newRingScale > 0.98) {\n      onDone?.();\n    }\n  });\n\n  return (\n    <group ref={groupRef} position={position}>\n      {/* Dot (solid circle) */}\n      <mesh\n        ref={dotRef}\n        scale={[\n          dotScale * FINAL_SCALE,\n          dotScale * FINAL_SCALE,\n          dotScale * FINAL_SCALE,\n        ]}\n      >\n        <circleGeometry args={[BASE_RADIUS, 64]} />\n        <meshBasicMaterial color={color} transparent opacity={1} />\n      </mesh>\n\n      <mesh\n        ref={ringRef}\n        scale={[\n          ringScale * FINAL_SCALE,\n          ringScale * FINAL_SCALE,\n          ringScale * FINAL_SCALE,\n        ]}\n      >\n        <ringGeometry args={[2.95, 3.1, 64]} />\n        <meshBasicMaterial\n          color={color}\n          transparent\n          opacity={ringOpacity}\n          side={THREE.DoubleSide}\n          depthTest={true}\n        />\n      </mesh>\n    </group>\n  );\n};\n\nexport default LandingEffect;\n","import { useFrame } from \"@react-three/fiber\";\nimport { useMemo, useRef, useState } from \"react\";\nimport * as THREE from \"three\";\nimport { latLongToVector3 } from \"../../utils/arcs\";\nimport LandingEffect from \"./LandingEffect\";\n\ninterface ArcProps {\n  /**\n   * Color of the arc.\n   */\n  color: string;\n  /**\n   * Starting latitude in degrees.\n   */\n  startLat: number;\n  /**\n   * Starting longitude in degrees.\n   */\n  startLon: number;\n  /**\n   * Ending latitude in degrees.\n   */\n  endLat: number;\n  /**\n   * Ending longitude in degrees.\n   */\n  endLon: number;\n  /**\n   * Radius of the sphere on which the arc is drawn.\n   */\n  radius: number;\n  /**\n   * Duration of the arc animation in milliseconds.\n   * Defaults to 2500ms.\n   */\n  animationDuration?: number;\n  /**\n   * Callback function triggered when the arc animation completes.\n   */\n  onDone?: () => void;\n  /**\n   * Whether the arc persists after drawing or retracts in a two-phase animation.\n   * Defaults to `false`.\n   */\n  onProgressPersist?: boolean;\n}\n\n/**\n * `PartialCurve` extends a base `THREE.Curve` to only render a section (partial curve)\n * between `minT` and `maxT`.\n */\nclass PartialCurve extends THREE.Curve<THREE.Vector3> {\n  baseCurve: THREE.Curve<THREE.Vector3>;\n  minT: number;\n  maxT: number;\n\n  /**\n   * Constructs a `PartialCurve` from a base curve and fractional range [minT, maxT].\n   * @param baseCurve The base curve (e.g., `THREE.CubicBezierCurve3`) to extract from.\n   * @param minT Start fraction of the curve (0.0–1.0).\n   * @param maxT End fraction of the curve (0.0–1.0).\n   */\n  constructor(\n    baseCurve: THREE.Curve<THREE.Vector3>,\n    minT: number,\n    maxT: number\n  ) {\n    super();\n    this.baseCurve = baseCurve;\n    this.minT = minT;\n    this.maxT = maxT;\n  }\n\n  /**\n   * Computes a point on the partial curve given `t` (fractional position).\n   * @param t Fraction along the partial curve (0.0–1.0).\n   * @param optionalTarget Optional target vector for storing the result.\n   * @returns The computed point as a `THREE.Vector3`.\n   */\n  getPoint(t: number, optionalTarget?: THREE.Vector3) {\n    const u = this.minT + (this.maxT - this.minT) * t;\n    return this.baseCurve.getPoint(u, optionalTarget);\n  }\n}\n\n/**\n * `Arc` renders a curved path between two geographic points on a sphere.\n * - Animates the arc over time, optionally showing a landing effect upon completion.\n * - Supports both persistent and retractable animations.\n */\nconst Arc = ({\n  color,\n  startLat,\n  startLon,\n  endLat,\n  endLon,\n  radius,\n  animationDuration = 2500,\n  onDone,\n  onProgressPersist = false,\n}: ArcProps) => {\n  const meshRef = useRef<THREE.Mesh>(null!);\n  const geometryRef = useRef<THREE.TubeGeometry>(null!);\n  const [done, setDone] = useState(false);\n  const [startTime] = useState(() => performance.now());\n  const [showLandingEffect, setShowLandingEffect] = useState(false);\n\n  // Convert lat/lon → 3D vectors on the sphere\n  const startVec = useMemo(\n    () => latLongToVector3(startLat, startLon, radius),\n    [startLat, startLon, radius]\n  );\n  const endVec = useMemo(\n    () => latLongToVector3(endLat, endLon, radius),\n    [endLat, endLon, radius]\n  );\n\n  // Full arc\n  const fullCurve = useMemo(() => {\n    const midPoint = new THREE.Vector3()\n      .addVectors(startVec, endVec)\n      .multiplyScalar(0.5);\n    const distance = startVec.distanceTo(endVec);\n    const arcHeight = distance * 1.5;\n    midPoint.setLength(midPoint.length() + arcHeight);\n\n    const control1 = new THREE.Vector3().lerpVectors(startVec, midPoint, 0.25);\n    const control2 = new THREE.Vector3().lerpVectors(startVec, midPoint, 0.75);\n\n    return new THREE.CubicBezierCurve3(startVec, control1, control2, endVec);\n  }, [startVec, endVec]);\n\n  // Create a (full) TubeGeometry once\n  const tubeGeometry = useMemo(() => {\n    return new THREE.TubeGeometry(fullCurve, 64, 0.5, 8, false);\n  }, [fullCurve]);\n\n  // Store that geometry in geometryRef so we can .setDrawRange() on it\n  useMemo(() => {\n    geometryRef.current = tubeGeometry;\n  }, [tubeGeometry]);\n\n  useFrame(() => {\n    if (done) return;\n\n    const elapsed = performance.now() - startTime;\n    let t = elapsed / animationDuration;\n    if (t > 1) t = 1;\n\n    if (onProgressPersist) {\n      // Single-phase (persist mode), 0->1, using setDrawRange\n      const indexCount = geometryRef.current.index\n        ? geometryRef.current.index.count\n        : geometryRef.current.attributes.position.count;\n      const drawCount = Math.floor(indexCount * t);\n      geometryRef.current.setDrawRange(0, drawCount);\n\n      // Optional: show the effect at t=1 in persist mode\n      if (t >= 1) {\n        geometryRef.current.setDrawRange(0, indexCount);\n        // If you want the landing effect as soon as we fully reach the end:\n        if (!showLandingEffect) {\n          setShowLandingEffect(true);\n        }\n        setDone(true);\n        onDone?.();\n      }\n    } else {\n      // Two-phase: 0..0.5 => extend, 0.5..1 => retract\n      if (!meshRef.current) return;\n\n      let extendP = 0;\n      let retractP = 0;\n\n      if (t <= 0.5) {\n        // extending\n        extendP = t / 0.5; // 0..1\n        retractP = 0;\n      } else {\n        // retracting\n        extendP = 1;\n        retractP = (t - 0.5) / 0.5; // 0..1\n\n        // As soon as the arc hits the end (t >= 0.5) show landing effect\n        if (!showLandingEffect) {\n          setShowLandingEffect(true);\n        }\n      }\n\n      const startParam = retractP; // grows 0..1 in second half\n      const endParam = extendP; // 0..1 in first half, pinned at 1 in second half\n\n      if (endParam <= startParam) {\n        meshRef.current.visible = false;\n      } else {\n        meshRef.current.visible = true;\n        const partialCurve = new PartialCurve(fullCurve, startParam, endParam);\n        const newGeom = new THREE.TubeGeometry(partialCurve, 64, 0.5, 8, false);\n\n        // Dispose old geometry to avoid leaks\n        if (meshRef.current.geometry) {\n          (meshRef.current.geometry as THREE.BufferGeometry).dispose();\n        }\n        meshRef.current.geometry = newGeom;\n      }\n\n      if (t >= 1) {\n        // fully done\n        meshRef.current.visible = false;\n        setDone(true);\n        onDone?.();\n      }\n    }\n  });\n\n  return (\n    <>\n      <mesh ref={meshRef}>\n        {/* For persist arcs, we pass in the stable geometryRef */}\n        {onProgressPersist ? (\n          <primitive object={tubeGeometry} attach=\"geometry\" />\n        ) : null}\n        <meshBasicMaterial color={color} transparent opacity={0.9} />\n      </mesh>\n\n      {/* Show landing effect when showLandingEffect = true */}\n      {showLandingEffect && (\n        <LandingEffect\n          position={endVec}\n          color=\"#ffcd53\"\n          onDone={() => setShowLandingEffect(false)}\n        />\n      )}\n    </>\n  );\n};\n\nexport default Arc;\n","import { useEffect, useState } from \"react\";\nimport {\n  AllArcsBehavior,\n  ArcLocation,\n  OnAllArcsDoneBehavior,\n} from \"../../../../types/earthTypes\";\nimport AllArcsStaticMesh from \"./AllArcsStaticMesh\";\nimport ArcLight from \"./Arc\";\n\nexport interface ArcGroupProps {\n  /**\n   * Array of start and end coordinates for each arc.\n   */\n  locationArray: ArcLocation[];\n\n  /**\n   * If true, arcs animate sequentially one-by-one.\n   * If false, all arcs animate in parallel.\n   */\n  sequential?: boolean;\n\n  /**\n   * Color of the arcs (e.g., hex code, RGB, etc.).\n   */\n  color: string;\n\n  /**\n   * Radius of the globe used to map lat/lon to 3D coordinates.\n   */\n  radius: number;\n\n  /**\n   * Duration of each arc animation in milliseconds.\n   * Default is 2500ms.\n   */\n  animationDuration?: number;\n\n  /**\n   * If true, completed arcs remain visible after animation ends.\n   * If false, arcs disappear upon completing their animation.\n   */\n  onProgressPersist?: boolean;\n\n  /**\n   * Behavior when all arcs finish:\n   *  - \"persist\": Keep arcs visible (default).\n   *  - \"remove\": Hide all arcs immediately after completion.\n   *  - \"reset\": Hide arcs and restart the animation sequence.\n   */\n  onAllArcsDone?: OnAllArcsDoneBehavior;\n\n  /**\n   * Determines how arcs behave after persisting in the final state.\n   */\n  persistArcBehavior: AllArcsBehavior;\n}\n\n/**\n * Component for rendering a group of arcs between geographic points.\n * Arcs can animate sequentially or in parallel based on the `sequential` prop.\n *\n * Once an arc finishes:\n *  - If `onProgressPersist` is false, the arc disappears.\n *  - Otherwise, the arc remains visible until all arcs are complete.\n *\n * When all arcs finish:\n *  - Behavior is determined by the `onAllArcsDone` prop.\n */\nconst ArcGroup = ({\n  locationArray,\n  sequential = false,\n  color,\n  radius,\n  animationDuration = 2500,\n  onProgressPersist = true,\n  onAllArcsDone = \"persist\",\n  persistArcBehavior,\n}: ArcGroupProps) => {\n  /**\n   * currentArcIndex:\n   *  - In sequential mode, the index of the arc currently animating (or just finished).\n   *  - In parallel mode, not really used to limit arcs, but we still track for resetting logic.\n   */\n  const [currentArcIndex, setCurrentArcIndex] = useState(0);\n\n  /**\n   * arcsDoneCount: how many arcs have fully completed their animation.\n   */\n  const [arcsDoneCount, setArcsDoneCount] = useState(0);\n\n  /**\n   * Track which arcs have completed to control per-arc visibility if onProgressPersist=false\n   */\n  const [arcsCompleted, setArcsCompleted] = useState<boolean[]>(\n    Array(locationArray.length).fill(false)\n  );\n\n  const [showFinalArcs, setShowFinalArcs] = useState(false);\n\n  /**\n   * Reset everything if the user chooses \"reset\" after the final arc,\n   * or if we mount fresh.\n   */\n  const resetAll = () => {\n    setCurrentArcIndex(0);\n    setArcsDoneCount(0);\n    setArcsCompleted(Array(locationArray.length).fill(false));\n  };\n\n  /**\n   * Once the final arc is done, handle \"onAllArcsDone\" behavior\n   */\n  useEffect(() => {\n    if (arcsDoneCount === locationArray.length && locationArray.length > 0) {\n      // If we've just completed the final arc:\n      switch (onAllArcsDone) {\n        case \"remove\":\n          // Hide all arcs\n          setArcsCompleted(Array(locationArray.length).fill(true));\n          // But \"onProgressPersist\" logic here means we set arcsCompleted to show them as \"done\"\n          // Actually, we want them hidden, so let's do a separate \"removeAll\" approach:\n          setTimeout(() => {\n            // Instantly hide all arcs\n            setArcsCompleted(Array(locationArray.length).fill(false));\n          }, 0);\n          break;\n        case \"reset\":\n          // Wait a short moment so we can see the final arc\n          setTimeout(() => {\n            resetAll();\n          }, 500);\n          break;\n        case \"persist\":\n          setShowFinalArcs(true);\n          break;\n        default:\n          break;\n      }\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [arcsDoneCount, locationArray.length, onAllArcsDone]);\n\n  return (\n    <>\n      {!showFinalArcs &&\n        locationArray.map((flight, i) => {\n          // If we are in sequential mode, skip arcs beyond currentArcIndex\n          if (sequential && i > currentArcIndex) {\n            return null;\n          }\n\n          // If arc i is done & onProgressPersist is false => hide it\n          if (arcsCompleted[i] && !onProgressPersist) {\n            return null;\n          }\n\n          return (\n            <ArcLight\n              key={i}\n              color={color}\n              startLat={flight.start.lat}\n              startLon={flight.start.lon}\n              endLat={flight.end.lat}\n              endLon={flight.end.lon}\n              radius={radius + 0.1}\n              onProgressPersist={onProgressPersist}\n              animationDuration={animationDuration}\n              onDone={() => {\n                setArcsCompleted((prev) => {\n                  const copy = [...prev];\n                  copy[i] = true;\n                  return copy;\n                });\n\n                // Increase arcsDoneCount\n                setArcsDoneCount((prev) => prev + 1);\n\n                // If sequential, move to the next arc in line\n                if (sequential && i === currentArcIndex) {\n                  setTimeout(() => {\n                    setCurrentArcIndex((prev) => prev + 1);\n                  }, 500);\n                }\n              }}\n            />\n          );\n        })}\n      {showFinalArcs && (\n        <AllArcsStaticMesh\n          flights={locationArray}\n          color={color}\n          radius={radius + 0.1}\n          behavior={persistArcBehavior}\n        />\n      )}\n    </>\n  );\n};\n\nexport default ArcGroup;\n","// AtmosphereShader.ts\nimport * as THREE from \"three\";\n\nexport const AtmosphereShader = {\n  uniforms: {\n    uColor: { value: new THREE.Color(\"#00aaff\") },\n    uIntensity: { value: 1.0 }, // how strong the glow is\n    uPower: { value: 2.0 }, // how quickly it falls off\n  },\n  vertexShader: `\n    varying vec3 vNormal;\n    void main() {\n      vNormal = normalize(normal);\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  `,\n  fragmentShader: `\n    uniform vec3 uColor;\n    uniform float uIntensity;\n    uniform float uPower;\n    varying vec3 vNormal;\n    \n    void main() {\n      // Fresnel-like term: how perpendicular the normal is to the view direction\n      float intensity = pow(1.0 - dot(vNormal, vec3(0.0, 0.0, 1.0)), uPower);\n      gl_FragColor = vec4(uColor, intensity * uIntensity);\n    }\n  `,\n};\n","// Atmosphere.tsx\nimport { useRef } from \"react\";\nimport * as THREE from \"three\";\nimport { AtmosphereShader } from \"../utils/AtmosphereShader\";\n\nexport interface AtmosphereProps {\n  earthRadius: number;\n  color: string;\n  opacity: number;\n}\n\n/**\n * `Atmosphere` is a slightly larger, inverted sphere around the Earth for a glowing atmospheric effect.\n * Uses a custom shader from `AtmosphereShader`.\n *\n * @param {AtmosphereProps} props\n *   @prop {number} earthRadius - Base radius of the Earth sphere.\n *   @prop {string} color - Color for the atmosphere glow (hex).\n *   @prop {number} opacity - Opacity level for the atmospheric glow.\n *\n * Renders a sphere with THREE.BackSide and a custom shader material to achieve a radial glow.\n */\nconst Atmosphere = ({ earthRadius, color, opacity }: AtmosphereProps) => {\n  const meshRef = useRef<THREE.Mesh>(null);\n\n  return (\n    <mesh ref={meshRef}>\n      <sphereGeometry args={[earthRadius * 1.018, 80, 80]} />\n      <shaderMaterial\n        side={THREE.BackSide}\n        transparent={true}\n        depthWrite={false}\n        uniforms={{\n          ...AtmosphereShader.uniforms,\n          uColor: { value: new THREE.Color(color) },\n          uIntensity: { value: 1.2 },\n          uPower: { value: 2.0 },\n        }}\n        vertexShader={AtmosphereShader.vertexShader}\n        fragmentShader={AtmosphereShader.fragmentShader}\n        opacity={opacity}\n      />\n    </mesh>\n  );\n};\n\nexport default Atmosphere;\n","import { useRef } from \"react\";\nimport * as THREE from \"three\";\n\ninterface BaseSphereProps {\n  radius: number;\n}\n\n/**\n * The main Earth sphere mesh, without any atmosphere or land dots.\n *\n * @param {BaseSphereProps} props\n *   @prop {number} radius - Radius of the sphere geometry.\n *\n * Uses a meshStandardMaterial for basic shading, plus a slight emissive glow.\n */\nconst BaseSphere = ({ radius }: BaseSphereProps) => {\n  const earthRef = useRef<THREE.Mesh>(null!);\n  return (\n    <mesh ref={earthRef}>\n      <sphereGeometry args={[radius, 64, 64]} />\n      <meshStandardMaterial\n        color=\"#0b2a57\"\n        emissive=\"#081c3c\"\n        emissiveIntensity={0.3}\n        roughness={0.45}\n      />\n    </mesh>\n  );\n};\n\nexport default BaseSphere;\n","import { useFrame } from \"@react-three/fiber\";\nimport { useEffect, useMemo, useRef } from \"react\";\nimport * as THREE from \"three\";\n\ninterface CityMarkerProps {\n  position: THREE.Vector3;\n  color: string;\n  markerSize: number;\n}\n\n/**\n * A single marker that is oriented to face outward from the globe.\n * - Renders a base circle marker plus a pulsing ring effect.\n */\nconst CityMarker = ({ position, color, markerSize }: CityMarkerProps) => {\n  // This is the correct way to define a React Three Fiber ref:\n  const groupRef = useRef<THREE.Group>(null!);\n\n  // Compute the normal only once per position\n  const normal = useMemo(() => position.clone().normalize(), [position]);\n\n  // Once the group is rendered, set its orientation & position\n  useEffect(() => {\n    if (!groupRef.current) return;\n    const zAxis = new THREE.Vector3(0, 0, 1);\n    const quat = new THREE.Quaternion().setFromUnitVectors(zAxis, normal);\n\n    groupRef.current.quaternion.copy(quat);\n    groupRef.current.position.copy(position);\n  }, [normal, position]);\n\n  return (\n    <group ref={groupRef}>\n      {/* Base marker (circle) */}\n      <mesh>\n        <circleGeometry args={[markerSize, 32]} />\n        <meshBasicMaterial color={color} side={THREE.DoubleSide} />\n      </mesh>\n\n      {/* Pulsing ring effect */}\n      <PulseRing baseRadius={markerSize * 1} color={color} />\n    </group>\n  );\n};\n\nexport default CityMarker;\n\n/**\n * A repeatedly-expanding ring that fades out as it grows, then resets.\n * You can tweak the speed, scale, and fade for your desired \"pulse.\"\n */\nfunction PulseRing({\n  baseRadius,\n  color,\n}: {\n  baseRadius: number;\n  color: string;\n}) {\n  const ringRef = useRef<THREE.Mesh>(null!);\n\n  /**\n   * We'll animate a \"phase\" t from 0..1 over some duration, then reset to 0.\n   * - scale = 1 + 1 * t (grows from 1 → 2)\n   * - opacity = 1 - t   (fades from 1 → 0)\n   */\n  const PULSE_DURATION = 2.2; // seconds per pulse\n  const MIN_SCALE = 1;\n  const MAX_SCALE = 2.5;\n\n  useFrame((state, delta) => {\n    if (!ringRef.current) return;\n\n    // We'll track time in ringRef’s userData (or you could use a useRef for the time).\n    // Accumulate delta each frame, loop back when passing PULSE_DURATION.\n    if (!ringRef.current.userData.elapsed) {\n      ringRef.current.userData.elapsed = 0;\n    }\n\n    ringRef.current.userData.elapsed += delta;\n    let t = ringRef.current.userData.elapsed / PULSE_DURATION;\n\n    // If time > PULSE_DURATION, reset\n    if (t > 1) {\n      ringRef.current.userData.elapsed = 0;\n      t = 0;\n    }\n\n    // scale 1..2\n    const scale = MIN_SCALE + (MAX_SCALE - MIN_SCALE) * t;\n    // fade 1..0\n    const opacity = 1 - t;\n\n    ringRef.current.scale.set(scale, scale, scale);\n    const material = ringRef.current.material as THREE.MeshBasicMaterial;\n    material.opacity = opacity;\n  });\n\n  return (\n    <mesh ref={ringRef}>\n      {/* Slightly thin ring geometry so it looks like a halo */}\n      <ringGeometry args={[baseRadius * 1, baseRadius * 1.5, 64]} />\n      <meshBasicMaterial\n        color={color}\n        transparent\n        opacity={1}\n        side={THREE.DoubleSide}\n      />\n    </mesh>\n  );\n}\n","import { useMemo } from \"react\";\nimport { CityLocation } from \"../../../types/earthTypes\";\nimport { latLongToVector3 } from \"../utils/arcs\";\nimport CityMarker from \"./helpers/CityMarker\";\n\nexport interface CityMarkersProps {\n  cities: CityLocation[];\n  radius: number;\n  color?: string;\n  markerSize?: number;\n}\n\nconst CityMarkers = ({\n  cities,\n  radius,\n  color = \"#ffcd53\",\n  markerSize = 1.5,\n}: CityMarkersProps) => {\n  // 1) Deduplicate by name (optional if your data is guaranteed unique):\n  const uniqueCities = useMemo(() => {\n    const map = new Map();\n    for (const city of cities) {\n      map.set(city.name, city);\n    }\n    return Array.from(map.values());\n  }, [cities]);\n\n  return (\n    <>\n      {uniqueCities.map((city, i) => {\n        // Convert lat/lon to Vector3 on the sphere\n        const position = latLongToVector3(city.lat, city.lon, radius);\n\n        return (\n          <CityMarker\n            key={city.name + i}\n            position={position}\n            color={color}\n            markerSize={markerSize}\n          />\n        );\n      })}\n    </>\n  );\n};\n\nexport default CityMarkers;\n","import { useFrame } from \"@react-three/fiber\";\nimport { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\nimport * as THREE from \"three\";\nimport { DotInfo } from \"../../../types/earthTypes\";\n\n// Optional: A quick, minimal debounce helper\nfunction debounce<T extends (...args: any[]) => void>(fn: T, delay: number): T {\n  let timeoutId: ReturnType<typeof setTimeout> | null = null;\n  return function (this: any, ...args: Parameters<T>) {\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n    }\n    timeoutId = setTimeout(() => fn.apply(this, args), delay);\n  } as T;\n}\n\nexport interface ContinentDotsProps {\n  jsonUrl: string;\n  pointSize: number;\n  onCountrySelect?: (iso: string) => void;\n  dotColor: string;\n  highlightColor?: string;\n  onLoaded?: (loaded: boolean) => void;\n}\n\n/**\n * A point cloud representing countries on the globe.\n * Fetches dot coordinates (x,y,z) from a JSON file, then displays them as points.\n * Allows clicking a point to highlight it briefly and optionally call onCountrySelect.\n *\n * @param {ContinentDotsProps} props\n *   @prop {string} jsonUrl - URL of the JSON data containing dot positions & country info.\n *   @prop {number} pointSize - Visual size of each point.\n *   @prop {(iso: string) => void} [onCountrySelect] - Callback invoked on country dot click.\n *   @prop {string} dotColor - Base color (hex) for the dots.\n *   @prop {string} [highlightColor] - Color (hex) to highlight the clicked dot with.\n *   @prop {(loaded: boolean) => void} onLoaded - Informs the parent when data is finished loading.\n *\n * Internally uses a BufferGeometry with position and color attributes.\n * On click, changes color to highlightColor for 2 seconds, then reverts.\n */\nconst ContinentDots = ({\n  jsonUrl,\n  pointSize,\n  onCountrySelect,\n  onLoaded,\n  dotColor,\n  highlightColor = \"#FFFF00\", // fallback if not provided\n}: ContinentDotsProps) => {\n  const [dots, setDots] = useState<DotInfo[]>([]);\n  const highlightRef = useRef<string | null>(null);\n  const highlightTimerRef = useRef<NodeJS.Timeout | null>(null);\n\n  const pointerDownRef = useRef<{ x: number; y: number } | null>(null);\n  const isDraggingRef = useRef(false);\n  const pointerDownDotIndexRef = useRef<number | null>(null);\n\n  // Pre-convert the base color into an RGB triple\n  const [baseR, baseG, baseB] = useMemo(() => {\n    const c = new THREE.Color(dotColor);\n    return [c.r, c.g, c.b]; // each is 0-1 float\n  }, [dotColor]);\n\n  // Pre-convert the highlight color into an RGB triple\n  const [highlightR, highlightG, highlightB] = useMemo(() => {\n    const c = new THREE.Color(highlightColor);\n    return [c.r, c.g, c.b]; // each is 0-1 float\n  }, [highlightColor]);\n\n  useEffect(() => {\n    const fetchDots = async () => {\n      try {\n        const res = await fetch(jsonUrl);\n        const data = await res.json();\n        console.log(\"Loaded landDots.json:\", data);\n        setDots(data);\n        !!onLoaded && onLoaded(true);\n      } catch (err) {\n        console.error(\"Failed to load landDots.json:\", err);\n      }\n    };\n    fetchDots();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [jsonUrl]);\n\n  // Positions\n  const positions = useMemo(() => {\n    if (!dots.length) return new Float32Array([]);\n    const arr: number[] = [];\n    for (const { x, y, z } of dots) {\n      arr.push(x, y, z);\n    }\n    return new Float32Array(arr);\n  }, [dots]);\n\n  // Colors\n  const colors = useMemo(() => {\n    if (!dots.length) return new Float32Array([]);\n    const arr: number[] = [];\n    for (let i = 0; i < dots.length; i++) {\n      // Use the user-specified base color for each dot\n      arr.push(baseR, baseG, baseB);\n    }\n    return new Float32Array(arr);\n  }, [dots, baseR, baseG, baseB]);\n\n  const colorAttrRef = useRef<THREE.BufferAttribute>(null);\n\n  // pointerDown → store initial position, reset isDragging, also store which dot (if any)\n  const handlePointerDown = useCallback((e: any) => {\n    pointerDownRef.current = { x: e.clientX, y: e.clientY };\n    isDraggingRef.current = false;\n\n    // Clear old pointerDownDotIndex\n    pointerDownDotIndexRef.current = null;\n\n    // Check if pointerDown was actually on a dot\n    if (e.intersections?.length) {\n      // Sort by distance and grab the nearest intersection\n      const firstHit = e.intersections.sort(\n        (a: any, b: any) => a.distance - b.distance\n      )[0];\n      pointerDownDotIndexRef.current = firstHit.index ?? null;\n    }\n\n    e.stopPropagation();\n  }, []);\n\n  // pointerMove → check if we moved far enough to count as a drag\n  const handlePointerMove = useCallback((e: any) => {\n    if (!pointerDownRef.current) return;\n\n    const dx = e.clientX - pointerDownRef.current.x;\n    const dy = e.clientY - pointerDownRef.current.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    // If you want to be more/less sensitive, adjust this threshold\n    if (distance > 20) {\n      isDraggingRef.current = true;\n    }\n    e.stopPropagation();\n  }, []);\n\n  // pointerUp → only do the country highlight if NOT dragging\n  const handlePointerUp = useCallback(\n    (event: any) => {\n      // It's a click/tap, so do the intersection picking\n      if (!dots.length) {\n        console.warn(\"No dots loaded yet.\");\n        return;\n      }\n\n      if (event.intersections.length === 0) {\n        return;\n      }\n\n      const intersection = event.intersections.sort(\n        (a: any, b: any) => a.distance - b.distance\n      )[0];\n\n      const upDotIndex = intersection.index;\n      // Compare it to the pointerDown dot index\n      if (\n        upDotIndex == null ||\n        pointerDownDotIndexRef.current === null ||\n        upDotIndex !== pointerDownDotIndexRef.current\n      ) {\n        // Not the same dot -> skip\n        pointerDownRef.current = null;\n        pointerDownDotIndexRef.current = null;\n        return;\n      }\n\n      const idx = intersection.index;\n      if (idx == null || !dots[idx]) {\n        console.warn(\"No valid index found for intersection.\");\n        return;\n      }\n\n      const dot = dots[idx];\n      console.log(\n        `Clicked dot #${idx}. Country = ${dot.countryName}, ISO = ${dot.isoA3}`\n      );\n\n      if (onCountrySelect) onCountrySelect(dot.isoA3);\n\n      // Cancel any old highlight fade\n      if (highlightTimerRef.current) {\n        clearTimeout(highlightTimerRef.current);\n      }\n\n      // Set highlightRef\n      highlightRef.current = dot.isoA3;\n\n      // After 2s, revert\n      highlightTimerRef.current = setTimeout(() => {\n        highlightRef.current = null;\n      }, 2000);\n\n      // Reset\n      pointerDownRef.current = null;\n      pointerDownDotIndexRef.current = null;\n      isDraggingRef.current = false;\n\n      event.stopPropagation();\n    },\n    [dots, onCountrySelect]\n  );\n\n  // Animate the dot colors each frame\n  useFrame(() => {\n    if (!colorAttrRef.current || !dots.length) {\n      return;\n    }\n    const colorArray = colorAttrRef.current.array as Float32Array;\n\n    for (let i = 0; i < dots.length; i++) {\n      const dot = dots[i];\n      const offset = i * 3;\n\n      if (highlightRef.current === dot.isoA3) {\n        // highlight color\n        colorArray[offset + 0] = highlightR;\n        colorArray[offset + 1] = highlightG;\n        colorArray[offset + 2] = highlightB;\n      } else {\n        // revert to base color\n        colorArray[offset + 0] = baseR;\n        colorArray[offset + 1] = baseG;\n        colorArray[offset + 2] = baseB;\n      }\n    }\n    colorAttrRef.current.needsUpdate = true;\n  });\n\n  if (!dots.length) return null;\n\n  return (\n    <points\n      onPointerDown={handlePointerDown}\n      onPointerMove={handlePointerMove}\n      onPointerUp={handlePointerUp}\n    >\n      <bufferGeometry>\n        <bufferAttribute\n          attach=\"attributes-position\"\n          args={[positions, 3]}\n          count={positions.length / 3}\n          itemSize={3} // Always 3 for XYZ\n        />\n        <bufferAttribute\n          ref={colorAttrRef}\n          attach=\"attributes-color\"\n          args={[colors, 3]}\n          count={colors.length / 3}\n          itemSize={3} // Always 3 for RGB\n        />\n      </bufferGeometry>\n      <pointsMaterial\n        vertexColors\n        size={pointSize} // Visual size of each point\n        sizeAttenuation\n        transparent\n        opacity={0.8}\n      />\n    </points>\n  );\n};\n\nexport default ContinentDots;\n","import { useFrame } from \"@react-three/fiber\";\nimport { useRef, useState } from \"react\";\nimport * as THREE from \"three\";\nimport { lerp } from \"three/src/math/MathUtils\";\nimport { AllArcsBehavior } from \"../../../types/earthTypes\";\nimport useAtOrAboveBreakpoint from \"../../../utils/useAtOrAboveBreakpoint\";\nimport ArcGroup, { ArcGroupProps } from \"./arcs/ArcGroup\";\nimport Atmosphere, { AtmosphereProps } from \"./Atmosphere\";\nimport BaseSphere from \"./BaseSphere\";\nimport CityMarkers, { CityMarkersProps } from \"./CityMarkerGroup\";\nimport ContinentDots, { ContinentDotsProps } from \"./ContinentDots\";\n\ninterface GlobeProps {\n  radius: number;\n  rotationSpeed: number;\n  rotationCoords: [number, number, number];\n  isInteracting: boolean;\n  dots?: ContinentDotsProps;\n  atmosphere?: AtmosphereProps;\n  arcs?: ArcGroupProps & { persistArcBehavior: AllArcsBehavior };\n  cityMarkers?: CityMarkersProps;\n}\n\n/**\n * 3D Interactive Globe Component\n * - Features: Earth's sphere, atmosphere, continent dots, and animated arcs.\n * - Responsive Scaling: Adjusts based on breakpoints (XS, SM, MD).\n * - Animation: Handles rotation and smooth scaling after data loads.\n *\n * Props:\n * - radius: Base radius of the globe.\n * - rotationSpeed: Speed of Y-axis rotation (radians/frame).\n * - rotationCoords: Initial rotation (Euler angles).\n * - isInteracting: Pauses auto-rotation when true.\n * - dots: Configuration for continent dots.\n * - atmosphere: Atmospheric glow configuration.\n * - arcs: Flight arc animation configuration.\n */\nconst Globe = ({\n  radius,\n  rotationSpeed,\n  rotationCoords,\n  arcs,\n  atmosphere,\n  dots,\n  cityMarkers,\n  isInteracting,\n}: GlobeProps) => {\n  const globeRef = useRef<THREE.Group>(null);\n\n  // Breakpoints for final scale\n  const isMdUp = useAtOrAboveBreakpoint(\"md\");\n  const isSmUp = useAtOrAboveBreakpoint(\"sm\");\n  const isXSUp = useAtOrAboveBreakpoint(\"xs\");\n\n  let targetScale = 1.0;\n  if (isMdUp) {\n    targetScale = 1.0;\n  } else if (isSmUp) {\n    targetScale = 0.8;\n  } else if (isXSUp) {\n    targetScale = 0.7;\n  } else {\n    targetScale = 0.6;\n  }\n\n  const [currentScale, setCurrentScale] = useState(0.55);\n  const [dotsLoaded, setDotsLoaded] = useState(false);\n\n  useFrame((_, delta) => {\n    if (!globeRef.current) return;\n\n    // 1) Only rotate if not interacting\n    if (!isInteracting) {\n      globeRef.current.rotation.y += rotationSpeed;\n    }\n\n    // 2) If dots are loaded, lerp from 0 => targetScale\n    const scaleSpeed = 2.0;\n    setCurrentScale((prev) => lerp(prev, targetScale, delta * scaleSpeed));\n  });\n\n  return (\n    <group\n      rotation={rotationCoords}\n      visible={dotsLoaded}\n      ref={globeRef}\n      scale={currentScale}\n    >\n      <BaseSphere radius={radius - 1} />\n      {!!atmosphere && (\n        <Atmosphere\n          earthRadius={radius - 2}\n          color={atmosphere.color}\n          opacity={atmosphere.opacity}\n        />\n      )}\n      {!!dots && (\n        <ContinentDots\n          jsonUrl={dots.jsonUrl}\n          dotColor={dots.dotColor}\n          pointSize={dots.pointSize}\n          onLoaded={(isLoaded) => setDotsLoaded(isLoaded)}\n        />\n      )}\n\n      {!!cityMarkers && (\n        <CityMarkers\n          cities={cityMarkers.cities}\n          radius={cityMarkers.radius}\n          color={cityMarkers.color}\n          markerSize={cityMarkers.markerSize}\n        />\n      )}\n      {!!arcs && (\n        <ArcGroup\n          animationDuration={arcs.animationDuration}\n          color={arcs.color}\n          locationArray={arcs.locationArray}\n          onAllArcsDone={arcs.onAllArcsDone}\n          onProgressPersist={arcs.onProgressPersist}\n          radius={arcs.radius}\n          sequential={arcs.sequential}\n          persistArcBehavior={arcs.persistArcBehavior}\n        />\n      )}\n    </group>\n  );\n};\n\nexport default Globe;\n","import { useFrame, useThree } from \"@react-three/fiber\";\nimport { useEffect, useRef } from \"react\";\nimport * as THREE from \"three\";\nimport { EffectComposer } from \"three/examples/jsm/postprocessing/EffectComposer\";\nimport { RenderPass } from \"three/examples/jsm/postprocessing/RenderPass\";\nimport { UnrealBloomPass } from \"three/examples/jsm/postprocessing/UnrealBloomPass\";\n\ninterface ManualBloomProps {\n  bloomStrength?: number;\n  bloomRadius?: number;\n  bloomThreshold?: number;\n}\n/**\n * A custom post-processing bloom effect that uses:\n * - `EffectComposer` to chain multiple post-processing passes.\n * - `RenderPass` for the base scene rendering.\n * - `UnrealBloomPass` for the bloom effect.\n *\n * @param {ManualBloomProps} props\n * @prop {number} [bloomStrength=0.7] - Controls brightness of bloom highlights.\n * @prop {number} [bloomRadius=0.5] - Determines how large or soft the bloom edges appear.\n * @prop {number} [bloomThreshold=0.0] - Threshold above which areas start to bloom.\n *\n * Rendering order (the second arg in `useFrame`) is set to 1 so the bloom\n * pass happens after the scene renders. Returns null since all rendering\n * is handled via EffectComposer.\n */\nconst ManualBloom = ({\n  bloomStrength = 0.7,\n  bloomRadius = 0.5,\n  bloomThreshold = 0.0,\n}: ManualBloomProps) => {\n  const composer = useRef<EffectComposer | null>(null);\n  const { gl, scene, camera, size } = useThree();\n\n  useEffect(() => {\n    // Create EffectComposer once on mount\n    const effectComposer = new EffectComposer(gl);\n    effectComposer.setSize(size.width, size.height);\n\n    // 1. Render pass (renders the scene normally)\n    const renderScene = new RenderPass(scene, camera);\n    effectComposer.addPass(renderScene);\n\n    // 2. UnrealBloomPass\n    const bloomPass = new UnrealBloomPass(\n      new THREE.Vector2(size.width, size.height),\n      bloomStrength, // strength (how bright the bloom is)\n      bloomRadius, // radius (how wide or soft the bloom edges are)\n      bloomThreshold // threshold (how bright an area must be before it blooms)\n    );\n    effectComposer.addPass(bloomPass);\n\n    composer.current = effectComposer;\n  }, [gl, scene, camera, size, bloomStrength, bloomRadius, bloomThreshold]);\n\n  // Render the composer on every frame\n  useFrame(() => {\n    composer.current?.render();\n  }, 1);\n\n  return null;\n};\n\nexport default ManualBloom;\n","import { ArcLocation } from \"../../../types/earthTypes\";\n\nexport const flightPaths: ArcLocation[] = [\n  //\n  // Roundtrip: NYC -> Dallas -> NYC\n  //\n  {\n    start: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n    end: { lat: 32.7767, lon: -96.797, name: \"Dallas\" }, // Dallas\n  },\n  {\n    start: { lat: 32.7767, lon: -96.797, name: \"Dallas\" }, // Dallas\n    end: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n  },\n\n  //\n  // Roundtrip: NYC -> San Francisco -> NYC\n  //\n  {\n    start: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n    end: { lat: 37.7749, lon: -122.4194, name: \"San Francisco\" }, // San Francisco\n  },\n  {\n    start: { lat: 37.7749, lon: -122.4194, name: \"San Francisco\" }, // San Francisco\n    end: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n  },\n\n  //\n  // Roundtrip: NYC -> Louisville -> NYC\n  //\n  {\n    start: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n    end: { lat: 38.2527, lon: -85.7585, name: \"Louisville\" }, // Louisville\n  },\n  {\n    start: { lat: 38.2527, lon: -85.7585, name: \"Louisville\" }, // Louisville\n    end: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n  },\n\n  //\n  // Roundtrip: NYC -> Seattle -> NYC\n  //\n  {\n    start: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n    end: { lat: 47.6062, lon: -122.3321, name: \"Seattle\" }, // Seattle\n  },\n  {\n    start: { lat: 47.6062, lon: -122.3321, name: \"Seattle\" }, // Seattle\n    end: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n  },\n\n  //\n  // NYC -> Bogota -> Cumaral -> Cartagena -> NYC\n  //\n  {\n    start: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n    end: { lat: 4.711, lon: -74.0721, name: \"Bogota\" }, // Bogota\n  },\n  {\n    start: { lat: 4.711, lon: -74.0721, name: \"Bogota\" }, // Bogota\n    end: { lat: 4.2702, lon: -73.4772, name: \"Cumaral\" }, // Cumaral\n  },\n  {\n    start: { lat: 4.2702, lon: -73.4772, name: \"Cumaral\" }, // Cumaral\n    end: { lat: 10.391, lon: -75.4794, name: \"Cartagena\" }, // Cartagena\n  },\n  {\n    start: { lat: 10.391, lon: -75.4794, name: \"Cartagena\" }, // Cartagena\n    end: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n  },\n\n  //\n  // Roundtrip: NYC -> Destin -> NYC\n  //\n  {\n    start: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n    end: { lat: 30.3935, lon: -86.4958, name: \"Destin\" }, // Destin\n  },\n  {\n    start: { lat: 30.3935, lon: -86.4958, name: \"Destin\" }, // Destin\n    end: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n  },\n\n  //\n  // Roundtrip: NYC -> San Jose, CA -> NYC\n  //\n  {\n    start: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n    end: { lat: 37.3382, lon: -121.8863, name: \"San Jose, CA\" }, // San Jose, CA\n  },\n  {\n    start: { lat: 37.3382, lon: -121.8863, name: \"San Jose, CA\" }, // San Jose, CA\n    end: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n  },\n\n  //\n  // NYC -> Nashville -> Louisville -> NYC\n  //\n  {\n    start: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n    end: { lat: 36.1627, lon: -86.7816, name: \"Nashville\" }, // Nashville\n  },\n  {\n    start: { lat: 36.1627, lon: -86.7816, name: \"Nashville\" }, // Nashville\n    end: { lat: 38.2527, lon: -85.7585, name: \"Louisville\" }, // Louisville\n  },\n  {\n    start: { lat: 38.2527, lon: -85.7585, name: \"Louisville\" }, // Louisville\n    end: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n  },\n\n  //\n  // NYC -> London -> Zurich -> Copenhagen -> Bern -> NYC\n  //\n  {\n    start: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n    end: { lat: 51.5074, lon: -0.1278, name: \"London\" }, // London\n  },\n  {\n    start: { lat: 51.5074, lon: -0.1278, name: \"London\" }, // London\n    end: { lat: 47.3769, lon: 8.5417, name: \"Zurich\" }, // Zurich\n  },\n  {\n    start: { lat: 47.3769, lon: 8.5417, name: \"Zurich\" }, // Zurich\n    end: { lat: 55.6761, lon: 12.5683, name: \"Copenhagen\" }, // Copenhagen\n  },\n  {\n    start: { lat: 55.6761, lon: 12.5683, name: \"Copenhagen\" }, // Copenhagen\n    end: { lat: 46.948, lon: 7.4474, name: \"Bern\" }, // Bern\n  },\n  {\n    start: { lat: 46.948, lon: 7.4474, name: \"Bern\" }, // Bern\n    end: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n  },\n\n  //\n  // Roundtrip: NYC -> Reykjavik -> NYC\n  //\n  {\n    start: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n    end: { lat: 64.1466, lon: -21.9426, name: \"Reykjavik\" }, // Reykjavik\n  },\n  {\n    start: { lat: 64.1466, lon: -21.9426, name: \"Reykjavik\" }, // Reykjavik\n    end: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n  },\n\n  //\n  // Roundtrip: NYC -> Louisville -> NYC\n  //\n  {\n    start: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n    end: { lat: 38.2527, lon: -85.7585, name: \"Louisville\" }, // Louisville\n  },\n  {\n    start: { lat: 38.2527, lon: -85.7585, name: \"Louisville\" }, // Louisville\n    end: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n  },\n\n  //\n  // Roundtrip: NYC -> Louisville -> NYC (again)\n  //\n  {\n    start: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n    end: { lat: 38.2527, lon: -85.7585, name: \"Louisville\" }, // Louisville\n  },\n  {\n    start: { lat: 38.2527, lon: -85.7585, name: \"Louisville\" }, // Louisville\n    end: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n  },\n];\n","import { useTheme } from \"@nextui-org/use-theme\";\nimport { OrbitControls } from \"@react-three/drei\";\nimport { Canvas } from \"@react-three/fiber\";\nimport { Suspense, useEffect, useRef, useState } from \"react\";\nimport useAtOrAboveBreakpoint from \"../../utils/useAtOrAboveBreakpoint\";\nimport Globe from \"./layers/Globe\";\nimport ManualBloom from \"./layers/ManualBlooms\";\nimport { flightPaths } from \"./utils/flightPaths\";\n\nconst MAX_ZOOMED_OUT = 600;\nconst ROTATION_START_ATLANTIC = [0.68, -0.3, 0.28];\nconst EARTH_RADIUS = 150;\nconst EARTH_TILT = 23.4 * (Math.PI / 180); // ~0.41\nconst STARTING_Y = -1;\n\n/**\n * A top-level 3D Earth component that:\n * - Sets up a Three.js Canvas with OrbitControls and performance stats.\n * - Renders the `Globe` component and optional post-processing (ManualBloom).\n */\nconst Earth = () => {\n  // Temp fix: Theme must be set to dark to render the globe, canvas is black (known issue)\n  const { theme, setTheme } = useTheme();\n\n  useEffect(() => {\n    if (theme !== \"dark\") {\n      setTheme(\"dark\");\n    }\n  }, [theme, setTheme]);\n\n  const isSmallUp = useAtOrAboveBreakpoint(\"sm\");\n  const jsonUrl = isSmallUp\n    ? \"/landDots-150rad-40k.json\" // more dots\n    : \"/landDots-150rad-30k.json\"; // fewer dots\n\n  const [isInteracting, setIsInteracting] = useState(false);\n  const resumeRotationTimeout = useRef<NodeJS.Timeout | null>(null);\n\n  const handleInteractionStart = () => {\n    // Clear any existing timeouts\n    if (resumeRotationTimeout.current) {\n      clearTimeout(resumeRotationTimeout.current);\n      resumeRotationTimeout.current = null;\n    }\n    setIsInteracting(true);\n  };\n\n  const handleInteractionEnd = () => {\n    // Wait 2 seconds before resuming rotation\n    resumeRotationTimeout.current = setTimeout(() => {\n      setIsInteracting(false);\n    }, 1000);\n  };\n\n  return (\n    <Canvas\n      gl={{ alpha: true }}\n      style={{ background: \"transparent\" }}\n      camera={{ position: [0, 140, MAX_ZOOMED_OUT], fov: 35 }}\n      onCreated={(state) => {\n        // Make sure the projection matrix is up to date\n        state.camera.updateProjectionMatrix();\n\n        // How far to shift the “center” of the image.\n        // Try adjusting offsetX to something like size.width * 0.25 or 0.3, etc.\n        const offsetX = state.size.width * 0.2;\n\n        state.camera.setViewOffset(\n          /* fullWidth  */ state.size.width,\n          /* fullHeight */ state.size.height,\n          /* offsetX    */ offsetX,\n          /* offsetY    */ 0,\n          /* width      */ state.size.width,\n          /* height     */ state.size.height\n        );\n\n        state.raycaster.params.Points.threshold = 2;\n      }}\n    >\n      {/* <Perf position=\"bottom-right\" /> */}\n\n      <OrbitControls\n        enableDamping={true}\n        minDistance={300}\n        minPolarAngle={0.3} // ~17 degrees\n        maxPolarAngle={Math.PI - 0.3} // ~163 degrees\n        enablePan={false}\n        maxDistance={MAX_ZOOMED_OUT}\n        onStart={handleInteractionStart}\n        onEnd={handleInteractionEnd}\n      />\n\n      {/* Subtle ambient and hemispheral light */}\n      <ambientLight intensity={1} />\n      <hemisphereLight intensity={0.2} position={[0, 50, 0]} />\n\n      <Suspense fallback={null}>\n        <Globe\n          isInteracting={isInteracting}\n          rotationCoords={[EARTH_TILT, STARTING_Y, 0]}\n          rotationSpeed={0.001}\n          radius={EARTH_RADIUS}\n          dots={{\n            dotColor: \"#00aaff\",\n            pointSize: 2.5,\n            jsonUrl,\n          }}\n          // Atmosphere\n          atmosphere={{\n            color: \"#00aaff\",\n            opacity: 0.03, // I fear this isn't hooked up to anything\n            earthRadius: EARTH_RADIUS,\n          }}\n          // Arcs\n          arcs={{\n            locationArray: flightPaths,\n            color: \"#dd6ff0\",\n            radius: EARTH_RADIUS,\n            animationDuration: 700,\n            sequential: false,\n            onProgressPersist: true,\n            onAllArcsDone: \"persist\",\n            persistArcBehavior: undefined,\n          }}\n          cityMarkers={{\n            cities: flightPaths.map((f) => ({\n              lat: f.end.lat,\n              lon: f.end.lon,\n              name: f.end.name,\n            })),\n            radius: EARTH_RADIUS,\n            color: \"#dd6ff0\",\n            markerSize: 1,\n          }}\n        />\n        <ManualBloom bloomStrength={1.2} bloomRadius={1} bloomThreshold={0.3} />\n      </Suspense>\n    </Canvas>\n  );\n};\n\nexport default Earth;\n","import Flag from \"react-flagpack\";\nimport Earth from \"../components/earth/Earth\";\nimport Typewriter from \"../components/Typewriter\";\n\nconst TheGlobeProject = () => {\n  return (\n    <div className=\"relative w-screen h-screen overflow-hidden\">\n      {/* Full-screen Earth in the background */}\n      <div className=\"absolute inset-0 pointer-events-auto\">\n        <Earth />\n      </div>\n      {/* Right half overlay (non-blocking by default) */}\n      <div className=\"absolute top-0 right-0 w-1/2 h-full flex items-center justify-center pointer-events-none z-10\">\n        {/* Make the actual text clickable */}\n        <div className=\"pointer-events-auto text-4xl flex-col flex flex-start\">\n          <Typewriter\n            phrases={[\"2024 Travel\"]}\n            typingSpeed={100}\n            deletingSpeed={50}\n          />\n          <p className=\"text-xl mt-4 max-w-md \">\n            Looking back on a year in review of travel and adventure. I have the\n            opportunity to visit 10 cities in 5 countries.\n          </p>\n          <div className=\"flex flex-row gap-2\">\n            {/* <ColombianFlag />\n            <SwissFlag /> */}\n            <Flag code=\"ADAND020\" size=\"M\" />\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default TheGlobeProject;\n","import { useParams } from \"react-router-dom\";\nimport TheGlobeProject from \"../../projects/TheGlobeProjects\";\n\nconst ProjectDetails = () => {\n  const { projectSlug } = useParams();\n\n  switch (projectSlug) {\n    case \"earth\":\n      return <TheGlobeProject />;\n    default:\n      return <div>Oops! Project not found.</div>;\n  }\n};\n\nexport default ProjectDetails;\n","import { useEffect, useState } from \"react\";\n\n// Tailwind's default breakpoints in pixels\nconst BREAKPOINTS = {\n  xs: 320,\n  sm: 640,\n  md: 768,\n  lg: 1024,\n  xl: 1280,\n  \"2xl\": 1536,\n};\n\ntype TailwindBreakpoint = keyof typeof BREAKPOINTS;\n\n/**\n * Usage:\n *   const isLargeUp = useTailwindBreakpoint(\"lg\");\n *   // returns true if window width >= 1024\n */\nconst useAtOrAboveBreakpoint = (breakpoint: TailwindBreakpoint) => {\n  const [matches, setMatches] = useState(false);\n\n  useEffect(() => {\n    function handleResize() {\n      const newMatches = window.innerWidth >= BREAKPOINTS[breakpoint];\n      // Only update state if the value actually changed\n      setMatches((old) => {\n        if (old !== newMatches) {\n          return newMatches;\n        }\n        return old;\n      });\n    }\n\n    window.addEventListener(\"resize\", handleResize);\n    handleResize();\n    return () => window.removeEventListener(\"resize\", handleResize);\n  }, [breakpoint]);\n\n  return matches;\n};\n\nexport default useAtOrAboveBreakpoint;\n"],"names":["_ref","_phrases$index","phrases","period","typingSpeed","deletingSpeed","loop","preserveTrailingNewlines","phase","setPhase","useState","index","setIndex","charIndex","setCharIndex","linkColor","useLinkColor","useEffect","isLastPhrase","length","currentPhrase","nextPhrase","overlapLength","a","b","i","findPrefixOverlap","rawOverlapLength","leftover","slice","test","preserveTrailingNewlinesInOverlap","nextChar","currentTypingSpeed","timeoutId","setTimeout","c","clearTimeout","pauseId","prevChar","currentDeletingSpeed","display","_jsxs","children","text","split","map","segment","arr","_jsx","className","concat","styles","style","borderColor","latLongToVector3","lat","lon","radius","phi","Math","PI","theta","x","sin","cos","z","y","THREE","flights","color","behavior","opacity","setOpacity","elapsed","flickerInterval","totalDuration","intervalId","setInterval","random","clearInterval","frameId","startTime","performance","now","duration","animate","t","min","requestAnimationFrame","cancelAnimationFrame","arcGeometries","useMemo","flight","buildAllArcs","startLat","startLon","endLat","endLon","startVec","endVec","midPoint","addVectors","multiplyScalar","arcHeight","distanceTo","setLength","control1","lerpVectors","control2","curve","start","end","_Fragment","geometry","transparent","position","onDone","groupRef","useRef","dotRef","ringRef","FINAL_SCALE","dotScale","setDotScale","ringScale","setRingScale","ringOpacity","setRingOpacity","lengthSq","normal","clone","normalize","zAxis","quat","setFromUnitVectors","current","quaternion","copy","useFrame","newRingScale","ref","scale","args","side","depthTest","PartialCurve","constructor","baseCurve","minT","maxT","super","this","getPoint","optionalTarget","u","animationDuration","onProgressPersist","meshRef","geometryRef","done","setDone","showLandingEffect","setShowLandingEffect","fullCurve","tubeGeometry","indexCount","count","attributes","drawCount","floor","setDrawRange","extendP","retractP","startParam","endParam","visible","partialCurve","newGeom","dispose","object","attach","LandingEffect","locationArray","sequential","onAllArcsDone","persistArcBehavior","currentArcIndex","setCurrentArcIndex","arcsDoneCount","setArcsDoneCount","arcsCompleted","setArcsCompleted","Array","fill","showFinalArcs","setShowFinalArcs","ArcLight","prev","AllArcsStaticMesh","AtmosphereShader","uniforms","uColor","value","uIntensity","uPower","vertexShader","fragmentShader","earthRadius","depthWrite","_objectSpread","earthRef","emissive","emissiveIntensity","roughness","markerSize","PulseRing","baseRadius","_ref2","state","delta","userData","set","material","cities","uniqueCities","Map","city","name","from","values","CityMarker","jsonUrl","pointSize","onCountrySelect","onLoaded","dotColor","highlightColor","dots","setDots","highlightRef","highlightTimerRef","pointerDownRef","isDraggingRef","pointerDownDotIndexRef","baseR","baseG","baseB","r","g","highlightR","highlightG","highlightB","async","res","fetch","data","json","console","log","err","error","fetchDots","positions","Float32Array","push","colors","colorAttrRef","handlePointerDown","useCallback","e","_e$intersections","clientX","clientY","intersections","_firstHit$index","firstHit","sort","distance","stopPropagation","handlePointerMove","dx","dy","sqrt","handlePointerUp","event","warn","intersection","upDotIndex","idx","dot","countryName","isoA3","colorArray","array","offset","needsUpdate","onPointerDown","onPointerMove","onPointerUp","itemSize","vertexColors","size","sizeAttenuation","rotationSpeed","rotationCoords","arcs","atmosphere","cityMarkers","isInteracting","globeRef","isMdUp","useAtOrAboveBreakpoint","isSmUp","isXSUp","targetScale","currentScale","setCurrentScale","dotsLoaded","setDotsLoaded","_","rotation","lerp","BaseSphere","Atmosphere","ContinentDots","isLoaded","CityMarkers","ArcGroup","bloomStrength","bloomRadius","bloomThreshold","composer","gl","scene","camera","useThree","effectComposer","EffectComposer","setSize","width","height","renderScene","RenderPass","addPass","bloomPass","UnrealBloomPass","_composer$current","render","flightPaths","EARTH_RADIUS","EARTH_TILT","Earth","theme","setTheme","useTheme","setIsInteracting","resumeRotationTimeout","Canvas","alpha","background","fov","onCreated","updateProjectionMatrix","offsetX","setViewOffset","raycaster","params","Points","threshold","OrbitControls","enableDamping","minDistance","minPolarAngle","maxPolarAngle","enablePan","maxDistance","onStart","handleInteractionStart","onEnd","handleInteractionEnd","intensity","Suspense","fallback","Globe","undefined","f","ManualBloom","TheGlobeProject","Typewriter","Flag","code","ProjectDetails","projectSlug","useParams","BREAKPOINTS","xs","sm","md","lg","xl","breakpoint","matches","setMatches","handleResize","newMatches","window","innerWidth","old","addEventListener","removeEventListener"],"sourceRoot":""}