{"version":3,"file":"static/js/987.c7cc2861.chunk.js","mappings":"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","sources":["components/earth/utils/arcs.ts","components/earth/layers/arcs/AllArcsStaticMesh.tsx","components/earth/layers/arcs/LandingEffect.tsx","components/earth/layers/arcs/Arc.tsx","components/earth/layers/arcs/ArcGroup.tsx","components/earth/utils/AtmosphereShader.ts","components/earth/layers/Atmosphere.tsx","components/earth/layers/BaseSphere.tsx","components/earth/layers/helpers/CityMarker.tsx","components/earth/layers/CityMarkerGroup.tsx","components/earth/layers/ContinentDots.tsx","components/earth/layers/Globe.tsx","components/earth/layers/ManualBlooms.tsx","components/earth/utils/flightPaths.ts","components/earth/Earth.tsx","pages/project-details/ProjectDetails.tsx","utils/useAtOrAboveBreakpoint.ts"],"sourcesContent":["import * as THREE from \"three\";\n\n/**\n * Convert latitude & longitude to a THREE.Vector3 on a sphere.\n * @param lat   latitude in degrees\n * @param lon   longitude in degrees\n * @param radius sphere radius\n */\nexport const latLongToVector3 = (lat: number, lon: number, radius: number) => {\n  const phi = (90 - lat) * (Math.PI / 180);\n  const theta = (lon + 180) * (Math.PI / 180);\n\n  const x = -radius * Math.sin(phi) * Math.cos(theta);\n  const z = radius * Math.sin(phi) * Math.sin(theta);\n  const y = radius * Math.cos(phi);\n\n  return new THREE.Vector3(x, y, z);\n};\n\n/**\n * buildFullArcGeometry\n *\n * Creates a THREE.TubeGeometry for a 3D arc using the same\n * cubic-bezier control logic that your animated ArcLight uses.\n */\nexport const buildAllArcs = (\n  startLat: number,\n  startLon: number,\n  endLat: number,\n  endLon: number,\n  radius: number\n) => {\n  const startVec = latLongToVector3(startLat, startLon, radius);\n  const endVec = latLongToVector3(endLat, endLon, radius);\n\n  // Approx midpoint logic\n  const midPoint = new THREE.Vector3()\n    .addVectors(startVec, endVec)\n    .multiplyScalar(0.5);\n  const distance = startVec.distanceTo(endVec);\n  const arcHeight = distance * 1.5;\n  midPoint.setLength(midPoint.length() + arcHeight);\n\n  const control1 = new THREE.Vector3().lerpVectors(startVec, midPoint, 0.25);\n  const control2 = new THREE.Vector3().lerpVectors(startVec, midPoint, 0.75);\n\n  // Build a cubic bezier arc\n  const curve = new THREE.CubicBezierCurve3(\n    startVec,\n    control1,\n    control2,\n    endVec\n  );\n\n  return new THREE.TubeGeometry(curve, 64, 0.5, 8, false);\n};\n","import { useEffect, useMemo, useState } from \"react\";\nimport { AllArcsBehavior, ArcLocation } from \"../../../../types/earthTypes\";\nimport { buildAllArcs } from \"../../utils/arcs\";\n\nexport interface AllArcsStaticMeshProps {\n  /**\n   * Array of flight arc locations with start and end coordinates.\n   */\n  flights: ArcLocation[];\n  /**\n   * Base color of the arcs.\n   */\n  color: string;\n  /**\n   * Radius of the sphere on which the arcs are drawn.\n   */\n  radius: number;\n  /**\n   * Animation behavior for the arcs.\n   */\n  behavior?: AllArcsBehavior;\n}\n\n/**\n * `AllArcsStaticMesh` renders multiple arcs as static or animated meshes.\n * - Animates opacity based on the specified `behavior`.\n * - Generates arc geometries dynamically for each flight in the `flights` array.\n */\nconst AllArcsStaticMesh = ({\n  flights,\n  color,\n  radius,\n  behavior,\n}: AllArcsStaticMeshProps) => {\n  // Single opacity state shared by all arcs\n  const [opacity, setOpacity] = useState(!behavior ? 1 : 0);\n\n  useEffect(() => {\n    // If flicker is true, we do the old-timey rapid toggling.\n    if (behavior === \"flicker\") {\n      // Flicker for 1 second (1000 ms), toggling every 100 ms\n      let elapsed = 0;\n      const flickerInterval = 100;\n      const totalDuration = 1000;\n      const intervalId = setInterval(() => {\n        elapsed += flickerInterval;\n        // Randomly go 0 or 1\n        setOpacity(Math.random() < 0.5 ? 0 : 1);\n\n        // After flicker finishes, set full\n        if (elapsed >= totalDuration) {\n          clearInterval(intervalId);\n          setOpacity(1);\n        }\n      }, flickerInterval);\n\n      return () => clearInterval(intervalId);\n\n      // Else if smoothOn is true, do a modern fade from 0 to 1\n    } else if (behavior === \"smooth\") {\n      // We'll animate from 0 to 1 over 1 second\n      let frameId: number | null = null;\n      const startTime = performance.now();\n      const duration = 1000; // 1 second\n\n      const animate = (now: number) => {\n        const elapsed = now - startTime;\n        const t = Math.min(elapsed / duration, 1); // clamp 0..1\n        setOpacity(t);\n\n        if (t < 1) {\n          frameId = requestAnimationFrame(animate);\n        }\n      };\n\n      frameId = requestAnimationFrame(animate);\n      return () => {\n        if (frameId) cancelAnimationFrame(frameId);\n      };\n\n      // Otherwise, show immediately at full opacity\n    } else {\n      setOpacity(1);\n    }\n  }, [behavior]);\n\n  // Precompute the geometries\n  const arcGeometries = useMemo(() => {\n    return flights.map((flight) => {\n      return buildAllArcs(\n        flight.start.lat,\n        flight.start.lon,\n        flight.end.lat,\n        flight.end.lon,\n        radius\n      );\n    });\n  }, [flights, radius]);\n\n  return (\n    <>\n      {arcGeometries.map((geometry, index) => (\n        <mesh key={index} geometry={geometry}>\n          <meshBasicMaterial color={color} transparent opacity={opacity} />\n        </mesh>\n      ))}\n    </>\n  );\n};\n\nexport default AllArcsStaticMesh;\n","import { useFrame } from \"@react-three/fiber\";\nimport { useEffect, useRef, useState } from \"react\";\nimport * as THREE from \"three\";\n\ninterface ArcLandingEffectProps {\n  position: THREE.Vector3;\n  color?: string;\n  onDone?: () => void;\n}\n\nconst LandingEffect = ({\n  position,\n  color = \"#ffffff\",\n  onDone,\n}: ArcLandingEffectProps) => {\n  const groupRef = useRef<THREE.Group>(null!);\n\n  // If you want separate references to tweak them individually:\n  const dotRef = useRef<THREE.Mesh>(null!);\n  const ringRef = useRef<THREE.Mesh>(null!);\n\n  // Circle’s *base* radius (the dot):\n  const BASE_RADIUS = 1;\n\n  // How large do we want them to expand? (1 = same size as base, 2 = double, etc.)\n  const FINAL_SCALE = 1.3;\n\n  // Local state for scale & opacity\n  const [dotScale, setDotScale] = useState(0); // for the solid circle\n  const [ringScale, setRingScale] = useState(0); // for the expanding ring\n  const [ringOpacity, setRingOpacity] = useState(1);\n\n  // Orient the group’s +Z axis toward the point on the globe\n  useEffect(() => {\n    if (position.lengthSq() === 0) return;\n    const normal = position.clone().normalize();\n    const zAxis = new THREE.Vector3(0, 0, 1);\n    const quat = new THREE.Quaternion().setFromUnitVectors(zAxis, normal);\n    groupRef.current.quaternion.copy(quat);\n  }, [position]);\n\n  useFrame(() => {\n    // Animate dot scale: step ~6% closer to 1\n    const newDotScale = dotScale + (1 - dotScale) * 0.06;\n    setDotScale(newDotScale);\n\n    // Animate ring scale: step ~6% closer to 1\n    const newRingScale = ringScale + (1 - ringScale) * 0.06;\n    setRingScale(newRingScale);\n\n    // Fade ring out as it nears full scale\n    const newOpacity = 1 - newRingScale;\n    setRingOpacity(newOpacity);\n\n    // Once it's mostly expanded, remove it\n    if (newRingScale > 0.98) {\n      onDone?.();\n    }\n  });\n\n  return (\n    <group ref={groupRef} position={position}>\n      {/* Dot (solid circle) */}\n      <mesh\n        ref={dotRef}\n        scale={[\n          dotScale * FINAL_SCALE,\n          dotScale * FINAL_SCALE,\n          dotScale * FINAL_SCALE,\n        ]}\n      >\n        <circleGeometry args={[BASE_RADIUS, 64]} />\n        <meshBasicMaterial color={color} transparent opacity={1} />\n      </mesh>\n\n      <mesh\n        ref={ringRef}\n        scale={[\n          ringScale * FINAL_SCALE,\n          ringScale * FINAL_SCALE,\n          ringScale * FINAL_SCALE,\n        ]}\n      >\n        <ringGeometry args={[2.95, 3.1, 64]} />\n        <meshBasicMaterial\n          color={color}\n          transparent\n          opacity={ringOpacity}\n          side={THREE.DoubleSide}\n          depthTest={true}\n        />\n      </mesh>\n    </group>\n  );\n};\n\nexport default LandingEffect;\n","import { useFrame } from \"@react-three/fiber\";\nimport { useMemo, useRef, useState } from \"react\";\nimport * as THREE from \"three\";\nimport { latLongToVector3 } from \"../../utils/arcs\";\nimport LandingEffect from \"./LandingEffect\";\n\ninterface ArcProps {\n  /**\n   * Color of the arc.\n   */\n  color: string;\n  /**\n   * Starting latitude in degrees.\n   */\n  startLat: number;\n  /**\n   * Starting longitude in degrees.\n   */\n  startLon: number;\n  /**\n   * Ending latitude in degrees.\n   */\n  endLat: number;\n  /**\n   * Ending longitude in degrees.\n   */\n  endLon: number;\n  /**\n   * Radius of the sphere on which the arc is drawn.\n   */\n  radius: number;\n  /**\n   * Duration of the arc animation in milliseconds.\n   * Defaults to 2500ms.\n   */\n  animationDuration?: number;\n  /**\n   * Callback function triggered when the arc animation completes.\n   */\n  onDone?: () => void;\n  /**\n   * Whether the arc persists after drawing or retracts in a two-phase animation.\n   * Defaults to `false`.\n   */\n  onProgressPersist?: boolean;\n}\n\n/**\n * `PartialCurve` extends a base `THREE.Curve` to only render a section (partial curve)\n * between `minT` and `maxT`.\n */\nclass PartialCurve extends THREE.Curve<THREE.Vector3> {\n  baseCurve: THREE.Curve<THREE.Vector3>;\n  minT: number;\n  maxT: number;\n\n  /**\n   * Constructs a `PartialCurve` from a base curve and fractional range [minT, maxT].\n   * @param baseCurve The base curve (e.g., `THREE.CubicBezierCurve3`) to extract from.\n   * @param minT Start fraction of the curve (0.0–1.0).\n   * @param maxT End fraction of the curve (0.0–1.0).\n   */\n  constructor(\n    baseCurve: THREE.Curve<THREE.Vector3>,\n    minT: number,\n    maxT: number\n  ) {\n    super();\n    this.baseCurve = baseCurve;\n    this.minT = minT;\n    this.maxT = maxT;\n  }\n\n  /**\n   * Computes a point on the partial curve given `t` (fractional position).\n   * @param t Fraction along the partial curve (0.0–1.0).\n   * @param optionalTarget Optional target vector for storing the result.\n   * @returns The computed point as a `THREE.Vector3`.\n   */\n  getPoint(t: number, optionalTarget?: THREE.Vector3) {\n    const u = this.minT + (this.maxT - this.minT) * t;\n    return this.baseCurve.getPoint(u, optionalTarget);\n  }\n}\n\n/**\n * `Arc` renders a curved path between two geographic points on a sphere.\n * - Animates the arc over time, optionally showing a landing effect upon completion.\n * - Supports both persistent and retractable animations.\n */\nconst Arc = ({\n  color,\n  startLat,\n  startLon,\n  endLat,\n  endLon,\n  radius,\n  animationDuration = 2500,\n  onDone,\n  onProgressPersist = false,\n}: ArcProps) => {\n  const meshRef = useRef<THREE.Mesh>(null!);\n  const geometryRef = useRef<THREE.TubeGeometry>(null!);\n  const [done, setDone] = useState(false);\n  const [startTime] = useState(() => performance.now());\n  const [showLandingEffect, setShowLandingEffect] = useState(false);\n\n  // Convert lat/lon → 3D vectors on the sphere\n  const startVec = useMemo(\n    () => latLongToVector3(startLat, startLon, radius),\n    [startLat, startLon, radius]\n  );\n  const endVec = useMemo(\n    () => latLongToVector3(endLat, endLon, radius),\n    [endLat, endLon, radius]\n  );\n\n  // Full arc\n  const fullCurve = useMemo(() => {\n    const midPoint = new THREE.Vector3()\n      .addVectors(startVec, endVec)\n      .multiplyScalar(0.5);\n    const distance = startVec.distanceTo(endVec);\n    const arcHeight = distance * 1.5;\n    midPoint.setLength(midPoint.length() + arcHeight);\n\n    const control1 = new THREE.Vector3().lerpVectors(startVec, midPoint, 0.25);\n    const control2 = new THREE.Vector3().lerpVectors(startVec, midPoint, 0.75);\n\n    return new THREE.CubicBezierCurve3(startVec, control1, control2, endVec);\n  }, [startVec, endVec]);\n\n  // Create a (full) TubeGeometry once\n  const tubeGeometry = useMemo(() => {\n    return new THREE.TubeGeometry(fullCurve, 64, 0.5, 8, false);\n  }, [fullCurve]);\n\n  // Store that geometry in geometryRef so we can .setDrawRange() on it\n  useMemo(() => {\n    geometryRef.current = tubeGeometry;\n  }, [tubeGeometry]);\n\n  useFrame(() => {\n    if (done) return;\n\n    const elapsed = performance.now() - startTime;\n    let t = elapsed / animationDuration;\n    if (t > 1) t = 1;\n\n    if (onProgressPersist) {\n      // Single-phase (persist mode), 0->1, using setDrawRange\n      const indexCount = geometryRef.current.index\n        ? geometryRef.current.index.count\n        : geometryRef.current.attributes.position.count;\n      const drawCount = Math.floor(indexCount * t);\n      geometryRef.current.setDrawRange(0, drawCount);\n\n      // Optional: show the effect at t=1 in persist mode\n      if (t >= 1) {\n        geometryRef.current.setDrawRange(0, indexCount);\n        // If you want the landing effect as soon as we fully reach the end:\n        if (!showLandingEffect) {\n          setShowLandingEffect(true);\n        }\n        setDone(true);\n        onDone?.();\n      }\n    } else {\n      // Two-phase: 0..0.5 => extend, 0.5..1 => retract\n      if (!meshRef.current) return;\n\n      let extendP = 0;\n      let retractP = 0;\n\n      if (t <= 0.5) {\n        // extending\n        extendP = t / 0.5; // 0..1\n        retractP = 0;\n      } else {\n        // retracting\n        extendP = 1;\n        retractP = (t - 0.5) / 0.5; // 0..1\n\n        // As soon as the arc hits the end (t >= 0.5) show landing effect\n        if (!showLandingEffect) {\n          setShowLandingEffect(true);\n        }\n      }\n\n      const startParam = retractP; // grows 0..1 in second half\n      const endParam = extendP; // 0..1 in first half, pinned at 1 in second half\n\n      if (endParam <= startParam) {\n        meshRef.current.visible = false;\n      } else {\n        meshRef.current.visible = true;\n        const partialCurve = new PartialCurve(fullCurve, startParam, endParam);\n        const newGeom = new THREE.TubeGeometry(partialCurve, 64, 0.5, 8, false);\n\n        // Dispose old geometry to avoid leaks\n        if (meshRef.current.geometry) {\n          (meshRef.current.geometry as THREE.BufferGeometry).dispose();\n        }\n        meshRef.current.geometry = newGeom;\n      }\n\n      if (t >= 1) {\n        // fully done\n        meshRef.current.visible = false;\n        setDone(true);\n        onDone?.();\n      }\n    }\n  });\n\n  return (\n    <>\n      <mesh ref={meshRef}>\n        {/* For persist arcs, we pass in the stable geometryRef */}\n        {onProgressPersist ? (\n          <primitive object={tubeGeometry} attach=\"geometry\" />\n        ) : null}\n        <meshBasicMaterial color={color} transparent opacity={0.9} />\n      </mesh>\n\n      {/* Show landing effect when showLandingEffect = true */}\n      {showLandingEffect && (\n        <LandingEffect\n          position={endVec}\n          color=\"#ffcd53\"\n          onDone={() => setShowLandingEffect(false)}\n        />\n      )}\n    </>\n  );\n};\n\nexport default Arc;\n","import { useEffect, useState } from \"react\";\nimport {\n  AllArcsBehavior,\n  ArcLocation,\n  OnAllArcsDoneBehavior,\n} from \"../../../../types/earthTypes\";\nimport AllArcsStaticMesh from \"./AllArcsStaticMesh\";\nimport ArcLight from \"./Arc\";\n\nexport interface ArcGroupProps {\n  /**\n   * Array of start and end coordinates for each arc.\n   */\n  locationArray: ArcLocation[];\n\n  /**\n   * If true, arcs animate sequentially one-by-one.\n   * If false, all arcs animate in parallel.\n   */\n  sequential?: boolean;\n\n  /**\n   * Color of the arcs (e.g., hex code, RGB, etc.).\n   */\n  color: string;\n\n  /**\n   * Radius of the globe used to map lat/lon to 3D coordinates.\n   */\n  radius: number;\n\n  /**\n   * Duration of each arc animation in milliseconds.\n   * Default is 2500ms.\n   */\n  animationDuration?: number;\n\n  /**\n   * If true, completed arcs remain visible after animation ends.\n   * If false, arcs disappear upon completing their animation.\n   */\n  onProgressPersist?: boolean;\n\n  /**\n   * Behavior when all arcs finish:\n   *  - \"persist\": Keep arcs visible (default).\n   *  - \"remove\": Hide all arcs immediately after completion.\n   *  - \"reset\": Hide arcs and restart the animation sequence.\n   */\n  onAllArcsDone?: OnAllArcsDoneBehavior;\n\n  /**\n   * Determines how arcs behave after persisting in the final state.\n   */\n  persistArcBehavior: AllArcsBehavior;\n}\n\n/**\n * Component for rendering a group of arcs between geographic points.\n * Arcs can animate sequentially or in parallel based on the `sequential` prop.\n *\n * Once an arc finishes:\n *  - If `onProgressPersist` is false, the arc disappears.\n *  - Otherwise, the arc remains visible until all arcs are complete.\n *\n * When all arcs finish:\n *  - Behavior is determined by the `onAllArcsDone` prop.\n */\nconst ArcGroup = ({\n  locationArray,\n  sequential = false,\n  color,\n  radius,\n  animationDuration = 2500,\n  onProgressPersist = true,\n  onAllArcsDone = \"persist\",\n  persistArcBehavior,\n}: ArcGroupProps) => {\n  /**\n   * currentArcIndex:\n   *  - In sequential mode, the index of the arc currently animating (or just finished).\n   *  - In parallel mode, not really used to limit arcs, but we still track for resetting logic.\n   */\n  const [currentArcIndex, setCurrentArcIndex] = useState(0);\n\n  /**\n   * arcsDoneCount: how many arcs have fully completed their animation.\n   */\n  const [arcsDoneCount, setArcsDoneCount] = useState(0);\n\n  /**\n   * Track which arcs have completed to control per-arc visibility if onProgressPersist=false\n   */\n  const [arcsCompleted, setArcsCompleted] = useState<boolean[]>(\n    Array(locationArray.length).fill(false)\n  );\n\n  const [showFinalArcs, setShowFinalArcs] = useState(false);\n\n  /**\n   * Reset everything if the user chooses \"reset\" after the final arc,\n   * or if we mount fresh.\n   */\n  const resetAll = () => {\n    setCurrentArcIndex(0);\n    setArcsDoneCount(0);\n    setArcsCompleted(Array(locationArray.length).fill(false));\n  };\n\n  /**\n   * Once the final arc is done, handle \"onAllArcsDone\" behavior\n   */\n  useEffect(() => {\n    if (arcsDoneCount === locationArray.length && locationArray.length > 0) {\n      // If we've just completed the final arc:\n      switch (onAllArcsDone) {\n        case \"remove\":\n          // Hide all arcs\n          setArcsCompleted(Array(locationArray.length).fill(true));\n          // But \"onProgressPersist\" logic here means we set arcsCompleted to show them as \"done\"\n          // Actually, we want them hidden, so let's do a separate \"removeAll\" approach:\n          setTimeout(() => {\n            // Instantly hide all arcs\n            setArcsCompleted(Array(locationArray.length).fill(false));\n          }, 0);\n          break;\n        case \"reset\":\n          // Wait a short moment so we can see the final arc\n          setTimeout(() => {\n            resetAll();\n          }, 500);\n          break;\n        case \"persist\":\n          setShowFinalArcs(true);\n          break;\n        default:\n          break;\n      }\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [arcsDoneCount, locationArray.length, onAllArcsDone]);\n\n  return (\n    <>\n      {!showFinalArcs &&\n        locationArray.map((flight, i) => {\n          // If we are in sequential mode, skip arcs beyond currentArcIndex\n          if (sequential && i > currentArcIndex) {\n            return null;\n          }\n\n          // If arc i is done & onProgressPersist is false => hide it\n          if (arcsCompleted[i] && !onProgressPersist) {\n            return null;\n          }\n\n          return (\n            <ArcLight\n              key={i}\n              color={color}\n              startLat={flight.start.lat}\n              startLon={flight.start.lon}\n              endLat={flight.end.lat}\n              endLon={flight.end.lon}\n              radius={radius + 0.1}\n              onProgressPersist={onProgressPersist}\n              animationDuration={animationDuration}\n              onDone={() => {\n                setArcsCompleted((prev) => {\n                  const copy = [...prev];\n                  copy[i] = true;\n                  return copy;\n                });\n\n                // Increase arcsDoneCount\n                setArcsDoneCount((prev) => prev + 1);\n\n                // If sequential, move to the next arc in line\n                if (sequential && i === currentArcIndex) {\n                  setTimeout(() => {\n                    setCurrentArcIndex((prev) => prev + 1);\n                  }, 500);\n                }\n              }}\n            />\n          );\n        })}\n      {showFinalArcs && (\n        <AllArcsStaticMesh\n          flights={locationArray}\n          color={color}\n          radius={radius + 0.1}\n          behavior={persistArcBehavior}\n        />\n      )}\n    </>\n  );\n};\n\nexport default ArcGroup;\n","// AtmosphereShader.ts\nimport * as THREE from \"three\";\n\nexport const AtmosphereShader = {\n  uniforms: {\n    uColor: { value: new THREE.Color(\"#00aaff\") },\n    uIntensity: { value: 1.0 }, // how strong the glow is\n    uPower: { value: 2.0 }, // how quickly it falls off\n  },\n  vertexShader: `\n    varying vec3 vNormal;\n    void main() {\n      vNormal = normalize(normal);\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  `,\n  fragmentShader: `\n    uniform vec3 uColor;\n    uniform float uIntensity;\n    uniform float uPower;\n    varying vec3 vNormal;\n    \n    void main() {\n      // Fresnel-like term: how perpendicular the normal is to the view direction\n      float intensity = pow(1.0 - dot(vNormal, vec3(0.0, 0.0, 1.0)), uPower);\n      gl_FragColor = vec4(uColor, intensity * uIntensity);\n    }\n  `,\n};\n","// Atmosphere.tsx\nimport { useRef } from \"react\";\nimport * as THREE from \"three\";\nimport { AtmosphereShader } from \"../utils/AtmosphereShader\";\n\nexport interface AtmosphereProps {\n  earthRadius: number;\n  color: string;\n  opacity: number;\n}\n\n/**\n * `Atmosphere` is a slightly larger, inverted sphere around the Earth for a glowing atmospheric effect.\n * Uses a custom shader from `AtmosphereShader`.\n *\n * @param {AtmosphereProps} props\n *   @prop {number} earthRadius - Base radius of the Earth sphere.\n *   @prop {string} color - Color for the atmosphere glow (hex).\n *   @prop {number} opacity - Opacity level for the atmospheric glow.\n *\n * Renders a sphere with THREE.BackSide and a custom shader material to achieve a radial glow.\n */\nconst Atmosphere = ({ earthRadius, color, opacity }: AtmosphereProps) => {\n  const meshRef = useRef<THREE.Mesh>(null);\n\n  return (\n    <mesh ref={meshRef}>\n      <sphereGeometry args={[earthRadius * 1.018, 80, 80]} />\n      <shaderMaterial\n        side={THREE.BackSide}\n        transparent={true}\n        depthWrite={false}\n        uniforms={{\n          ...AtmosphereShader.uniforms,\n          uColor: { value: new THREE.Color(color) },\n          uIntensity: { value: 1.2 },\n          uPower: { value: 2.0 },\n        }}\n        vertexShader={AtmosphereShader.vertexShader}\n        fragmentShader={AtmosphereShader.fragmentShader}\n        opacity={opacity}\n      />\n    </mesh>\n  );\n};\n\nexport default Atmosphere;\n","import { useRef } from \"react\";\nimport * as THREE from \"three\";\n\ninterface BaseSphereProps {\n  radius: number;\n}\n\n/**\n * The main Earth sphere mesh, without any atmosphere or land dots.\n *\n * @param {BaseSphereProps} props\n *   @prop {number} radius - Radius of the sphere geometry.\n *\n * Uses a meshStandardMaterial for basic shading, plus a slight emissive glow.\n */\nconst BaseSphere = ({ radius }: BaseSphereProps) => {\n  const earthRef = useRef<THREE.Mesh>(null!);\n  return (\n    <mesh ref={earthRef}>\n      <sphereGeometry args={[radius, 64, 64]} />\n      <meshStandardMaterial\n        color=\"#0b2a57\"\n        emissive=\"#081c3c\"\n        emissiveIntensity={0.3}\n        roughness={0.45}\n      />\n    </mesh>\n  );\n};\n\nexport default BaseSphere;\n","import { useFrame } from \"@react-three/fiber\";\nimport { useEffect, useMemo, useRef } from \"react\";\nimport * as THREE from \"three\";\n\ninterface CityMarkerProps {\n  position: THREE.Vector3;\n  color: string;\n  markerSize: number;\n}\n\n/**\n * A single marker that is oriented to face outward from the globe.\n * - Renders a base circle marker plus a pulsing ring effect.\n */\nconst CityMarker = ({ position, color, markerSize }: CityMarkerProps) => {\n  // This is the correct way to define a React Three Fiber ref:\n  const groupRef = useRef<THREE.Group>(null!);\n\n  // Compute the normal only once per position\n  const normal = useMemo(() => position.clone().normalize(), [position]);\n\n  // Once the group is rendered, set its orientation & position\n  useEffect(() => {\n    if (!groupRef.current) return;\n    const zAxis = new THREE.Vector3(0, 0, 1);\n    const quat = new THREE.Quaternion().setFromUnitVectors(zAxis, normal);\n\n    groupRef.current.quaternion.copy(quat);\n    groupRef.current.position.copy(position);\n  }, [normal, position]);\n\n  return (\n    <group ref={groupRef}>\n      {/* Base marker (circle) */}\n      <mesh>\n        <circleGeometry args={[markerSize, 32]} />\n        <meshBasicMaterial color={color} side={THREE.DoubleSide} />\n      </mesh>\n\n      {/* Pulsing ring effect */}\n      <PulseRing baseRadius={markerSize * 1} color={color} />\n    </group>\n  );\n};\n\nexport default CityMarker;\n\n/**\n * A repeatedly-expanding ring that fades out as it grows, then resets.\n * You can tweak the speed, scale, and fade for your desired \"pulse.\"\n */\nfunction PulseRing({\n  baseRadius,\n  color,\n}: {\n  baseRadius: number;\n  color: string;\n}) {\n  const ringRef = useRef<THREE.Mesh>(null!);\n\n  /**\n   * We'll animate a \"phase\" t from 0..1 over some duration, then reset to 0.\n   * - scale = 1 + 1 * t (grows from 1 → 2)\n   * - opacity = 1 - t   (fades from 1 → 0)\n   */\n  const PULSE_DURATION = 2.2; // seconds per pulse\n  const MIN_SCALE = 1;\n  const MAX_SCALE = 2.5;\n\n  useFrame((state, delta) => {\n    if (!ringRef.current) return;\n\n    // We'll track time in ringRef’s userData (or you could use a useRef for the time).\n    // Accumulate delta each frame, loop back when passing PULSE_DURATION.\n    if (!ringRef.current.userData.elapsed) {\n      ringRef.current.userData.elapsed = 0;\n    }\n\n    ringRef.current.userData.elapsed += delta;\n    let t = ringRef.current.userData.elapsed / PULSE_DURATION;\n\n    // If time > PULSE_DURATION, reset\n    if (t > 1) {\n      ringRef.current.userData.elapsed = 0;\n      t = 0;\n    }\n\n    // scale 1..2\n    const scale = MIN_SCALE + (MAX_SCALE - MIN_SCALE) * t;\n    // fade 1..0\n    const opacity = 1 - t;\n\n    ringRef.current.scale.set(scale, scale, scale);\n    const material = ringRef.current.material as THREE.MeshBasicMaterial;\n    material.opacity = opacity;\n  });\n\n  return (\n    <mesh ref={ringRef}>\n      {/* Slightly thin ring geometry so it looks like a halo */}\n      <ringGeometry args={[baseRadius * 1, baseRadius * 1.5, 64]} />\n      <meshBasicMaterial\n        color={color}\n        transparent\n        opacity={1}\n        side={THREE.DoubleSide}\n      />\n    </mesh>\n  );\n}\n","import { useMemo } from \"react\";\nimport { CityLocation } from \"../../../types/earthTypes\";\nimport { latLongToVector3 } from \"../utils/arcs\";\nimport CityMarker from \"./helpers/CityMarker\";\n\nexport interface CityMarkersProps {\n  cities: CityLocation[];\n  radius: number;\n  color?: string;\n  markerSize?: number;\n}\n\nconst CityMarkers = ({\n  cities,\n  radius,\n  color = \"#ffcd53\",\n  markerSize = 1.5,\n}: CityMarkersProps) => {\n  // 1) Deduplicate by name (optional if your data is guaranteed unique):\n  const uniqueCities = useMemo(() => {\n    const map = new Map();\n    for (const city of cities) {\n      map.set(city.name, city);\n    }\n    return Array.from(map.values());\n  }, [cities]);\n\n  return (\n    <>\n      {uniqueCities.map((city, i) => {\n        // Convert lat/lon to Vector3 on the sphere\n        const position = latLongToVector3(city.lat, city.lon, radius);\n\n        return (\n          <CityMarker\n            key={city.name + i}\n            position={position}\n            color={color}\n            markerSize={markerSize}\n          />\n        );\n      })}\n    </>\n  );\n};\n\nexport default CityMarkers;\n","import { useFrame } from \"@react-three/fiber\";\nimport { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\nimport * as THREE from \"three\";\nimport { DotInfo } from \"../../../types/earthTypes\";\n\n// Optional: A quick, minimal debounce helper\nfunction debounce<T extends (...args: any[]) => void>(fn: T, delay: number): T {\n  let timeoutId: ReturnType<typeof setTimeout> | null = null;\n  return function (this: any, ...args: Parameters<T>) {\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n    }\n    timeoutId = setTimeout(() => fn.apply(this, args), delay);\n  } as T;\n}\n\nexport interface ContinentDotsProps {\n  jsonUrl: string;\n  pointSize: number;\n  onCountrySelect?: (iso: string) => void;\n  dotColor: string;\n  highlightColor?: string;\n  onLoaded?: (loaded: boolean) => void;\n}\n\n/**\n * A point cloud representing countries on the globe.\n * Fetches dot coordinates (x,y,z) from a JSON file, then displays them as points.\n * Allows clicking a point to highlight it briefly and optionally call onCountrySelect.\n *\n * @param {ContinentDotsProps} props\n *   @prop {string} jsonUrl - URL of the JSON data containing dot positions & country info.\n *   @prop {number} pointSize - Visual size of each point.\n *   @prop {(iso: string) => void} [onCountrySelect] - Callback invoked on country dot click.\n *   @prop {string} dotColor - Base color (hex) for the dots.\n *   @prop {string} [highlightColor] - Color (hex) to highlight the clicked dot with.\n *   @prop {(loaded: boolean) => void} onLoaded - Informs the parent when data is finished loading.\n *\n * Internally uses a BufferGeometry with position and color attributes.\n * On click, changes color to highlightColor for 2 seconds, then reverts.\n */\nconst ContinentDots = ({\n  jsonUrl,\n  pointSize,\n  onCountrySelect,\n  onLoaded,\n  dotColor,\n  highlightColor = \"#FFFF00\", // fallback if not provided\n}: ContinentDotsProps) => {\n  const [dots, setDots] = useState<DotInfo[]>([]);\n  const highlightRef = useRef<string | null>(null);\n  const highlightTimerRef = useRef<NodeJS.Timeout | null>(null);\n\n  const pointerDownRef = useRef<{ x: number; y: number } | null>(null);\n  const isDraggingRef = useRef(false);\n  const pointerDownDotIndexRef = useRef<number | null>(null);\n\n  // Pre-convert the base color into an RGB triple\n  const [baseR, baseG, baseB] = useMemo(() => {\n    const c = new THREE.Color(dotColor);\n    return [c.r, c.g, c.b]; // each is 0-1 float\n  }, [dotColor]);\n\n  // Pre-convert the highlight color into an RGB triple\n  const [highlightR, highlightG, highlightB] = useMemo(() => {\n    const c = new THREE.Color(highlightColor);\n    return [c.r, c.g, c.b]; // each is 0-1 float\n  }, [highlightColor]);\n\n  useEffect(() => {\n    const fetchDots = async () => {\n      try {\n        const res = await fetch(jsonUrl);\n        const data = await res.json();\n        console.log(\"Loaded landDots.json:\", data);\n        setDots(data);\n        !!onLoaded && onLoaded(true);\n      } catch (err) {\n        console.error(\"Failed to load landDots.json:\", err);\n      }\n    };\n    fetchDots();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [jsonUrl]);\n\n  // Positions\n  const positions = useMemo(() => {\n    if (!dots.length) return new Float32Array([]);\n    const arr: number[] = [];\n    for (const { x, y, z } of dots) {\n      arr.push(x, y, z);\n    }\n    return new Float32Array(arr);\n  }, [dots]);\n\n  // Colors\n  const colors = useMemo(() => {\n    if (!dots.length) return new Float32Array([]);\n    const arr: number[] = [];\n    for (let i = 0; i < dots.length; i++) {\n      // Use the user-specified base color for each dot\n      arr.push(baseR, baseG, baseB);\n    }\n    return new Float32Array(arr);\n  }, [dots, baseR, baseG, baseB]);\n\n  const colorAttrRef = useRef<THREE.BufferAttribute>(null);\n\n  // pointerDown → store initial position, reset isDragging, also store which dot (if any)\n  const handlePointerDown = useCallback((e: any) => {\n    pointerDownRef.current = { x: e.clientX, y: e.clientY };\n    isDraggingRef.current = false;\n\n    // Clear old pointerDownDotIndex\n    pointerDownDotIndexRef.current = null;\n\n    // Check if pointerDown was actually on a dot\n    if (e.intersections?.length) {\n      // Sort by distance and grab the nearest intersection\n      const firstHit = e.intersections.sort(\n        (a: any, b: any) => a.distance - b.distance\n      )[0];\n      pointerDownDotIndexRef.current = firstHit.index ?? null;\n    }\n\n    e.stopPropagation();\n  }, []);\n\n  // pointerMove → check if we moved far enough to count as a drag\n  const handlePointerMove = useCallback((e: any) => {\n    if (!pointerDownRef.current) return;\n\n    const dx = e.clientX - pointerDownRef.current.x;\n    const dy = e.clientY - pointerDownRef.current.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    // If you want to be more/less sensitive, adjust this threshold\n    if (distance > 20) {\n      isDraggingRef.current = true;\n    }\n    e.stopPropagation();\n  }, []);\n\n  // pointerUp → only do the country highlight if NOT dragging\n  const handlePointerUp = useCallback(\n    (event: any) => {\n      // It's a click/tap, so do the intersection picking\n      if (!dots.length) {\n        console.warn(\"No dots loaded yet.\");\n        return;\n      }\n\n      if (event.intersections.length === 0) {\n        return;\n      }\n\n      const intersection = event.intersections.sort(\n        (a: any, b: any) => a.distance - b.distance\n      )[0];\n\n      const upDotIndex = intersection.index;\n      // Compare it to the pointerDown dot index\n      if (\n        upDotIndex == null ||\n        pointerDownDotIndexRef.current === null ||\n        upDotIndex !== pointerDownDotIndexRef.current\n      ) {\n        // Not the same dot -> skip\n        pointerDownRef.current = null;\n        pointerDownDotIndexRef.current = null;\n        return;\n      }\n\n      const idx = intersection.index;\n      if (idx == null || !dots[idx]) {\n        console.warn(\"No valid index found for intersection.\");\n        return;\n      }\n\n      const dot = dots[idx];\n      console.log(\n        `Clicked dot #${idx}. Country = ${dot.countryName}, ISO = ${dot.isoA3}`\n      );\n\n      if (onCountrySelect) onCountrySelect(dot.isoA3);\n\n      // Cancel any old highlight fade\n      if (highlightTimerRef.current) {\n        clearTimeout(highlightTimerRef.current);\n      }\n\n      // Set highlightRef\n      highlightRef.current = dot.isoA3;\n\n      // After 2s, revert\n      highlightTimerRef.current = setTimeout(() => {\n        highlightRef.current = null;\n      }, 2000);\n\n      // Reset\n      pointerDownRef.current = null;\n      pointerDownDotIndexRef.current = null;\n      isDraggingRef.current = false;\n\n      event.stopPropagation();\n    },\n    [dots, onCountrySelect]\n  );\n\n  // Animate the dot colors each frame\n  useFrame(() => {\n    if (!colorAttrRef.current || !dots.length) {\n      return;\n    }\n    const colorArray = colorAttrRef.current.array as Float32Array;\n\n    for (let i = 0; i < dots.length; i++) {\n      const dot = dots[i];\n      const offset = i * 3;\n\n      if (highlightRef.current === dot.isoA3) {\n        // highlight color\n        colorArray[offset + 0] = highlightR;\n        colorArray[offset + 1] = highlightG;\n        colorArray[offset + 2] = highlightB;\n      } else {\n        // revert to base color\n        colorArray[offset + 0] = baseR;\n        colorArray[offset + 1] = baseG;\n        colorArray[offset + 2] = baseB;\n      }\n    }\n    colorAttrRef.current.needsUpdate = true;\n  });\n\n  if (!dots.length) return null;\n\n  return (\n    <points\n      onPointerDown={handlePointerDown}\n      onPointerMove={handlePointerMove}\n      onPointerUp={handlePointerUp}\n    >\n      <bufferGeometry>\n        <bufferAttribute\n          attach=\"attributes-position\"\n          args={[positions, 3]}\n          count={positions.length / 3}\n          itemSize={3} // Always 3 for XYZ\n        />\n        <bufferAttribute\n          ref={colorAttrRef}\n          attach=\"attributes-color\"\n          args={[colors, 3]}\n          count={colors.length / 3}\n          itemSize={3} // Always 3 for RGB\n        />\n      </bufferGeometry>\n      <pointsMaterial\n        vertexColors\n        size={pointSize} // Visual size of each point\n        sizeAttenuation\n        transparent\n        opacity={0.8}\n      />\n    </points>\n  );\n};\n\nexport default ContinentDots;\n","import { useFrame } from \"@react-three/fiber\";\nimport { useRef, useState } from \"react\";\nimport * as THREE from \"three\";\nimport { lerp } from \"three/src/math/MathUtils\";\nimport { AllArcsBehavior } from \"../../../types/earthTypes\";\nimport useAtOrAboveBreakpoint from \"../../../utils/useAtOrAboveBreakpoint\";\nimport ArcGroup, { ArcGroupProps } from \"./arcs/ArcGroup\";\nimport Atmosphere, { AtmosphereProps } from \"./Atmosphere\";\nimport BaseSphere from \"./BaseSphere\";\nimport CityMarkers, { CityMarkersProps } from \"./CityMarkerGroup\";\nimport ContinentDots, { ContinentDotsProps } from \"./ContinentDots\";\n\ninterface GlobeProps {\n  radius: number;\n  rotationSpeed: number;\n  rotationCoords: [number, number, number];\n  isInteracting: boolean;\n  dots?: ContinentDotsProps;\n  atmosphere?: AtmosphereProps;\n  arcs?: ArcGroupProps & { persistArcBehavior: AllArcsBehavior };\n  cityMarkers?: CityMarkersProps;\n}\n\n/**\n * 3D Interactive Globe Component\n * - Features: Earth's sphere, atmosphere, continent dots, and animated arcs.\n * - Responsive Scaling: Adjusts based on breakpoints (XS, SM, MD).\n * - Animation: Handles rotation and smooth scaling after data loads.\n *\n * Props:\n * - radius: Base radius of the globe.\n * - rotationSpeed: Speed of Y-axis rotation (radians/frame).\n * - rotationCoords: Initial rotation (Euler angles).\n * - isInteracting: Pauses auto-rotation when true.\n * - dots: Configuration for continent dots.\n * - atmosphere: Atmospheric glow configuration.\n * - arcs: Flight arc animation configuration.\n */\nconst Globe = ({\n  radius,\n  rotationSpeed,\n  rotationCoords,\n  arcs,\n  atmosphere,\n  dots,\n  cityMarkers,\n  isInteracting,\n}: GlobeProps) => {\n  const globeRef = useRef<THREE.Group>(null);\n\n  // Breakpoints for final scale\n  const isMdUp = useAtOrAboveBreakpoint(\"md\");\n  const isSmUp = useAtOrAboveBreakpoint(\"sm\");\n  const isXSUp = useAtOrAboveBreakpoint(\"xs\");\n\n  let targetScale = 1.0;\n  if (isMdUp) {\n    targetScale = 1.0;\n  } else if (isSmUp) {\n    targetScale = 0.8;\n  } else if (isXSUp) {\n    targetScale = 0.7;\n  } else {\n    targetScale = 0.6;\n  }\n\n  const [currentScale, setCurrentScale] = useState(0.55);\n  const [dotsLoaded, setDotsLoaded] = useState(false);\n\n  useFrame((_, delta) => {\n    if (!globeRef.current) return;\n\n    // 1) Only rotate if not interacting\n    if (!isInteracting) {\n      globeRef.current.rotation.y += rotationSpeed;\n    }\n\n    // 2) If dots are loaded, lerp from 0 => targetScale\n    const scaleSpeed = 2.0;\n    setCurrentScale((prev) => lerp(prev, targetScale, delta * scaleSpeed));\n  });\n\n  return (\n    <group\n      rotation={rotationCoords}\n      visible={dotsLoaded}\n      ref={globeRef}\n      scale={currentScale}\n    >\n      <BaseSphere radius={radius - 1} />\n      {!!atmosphere && (\n        <Atmosphere\n          earthRadius={radius - 2}\n          color={atmosphere.color}\n          opacity={atmosphere.opacity}\n        />\n      )}\n      {!!dots && (\n        <ContinentDots\n          jsonUrl={dots.jsonUrl}\n          dotColor={dots.dotColor}\n          pointSize={dots.pointSize}\n          onLoaded={(isLoaded) => setDotsLoaded(isLoaded)}\n        />\n      )}\n\n      {!!cityMarkers && (\n        <CityMarkers\n          cities={cityMarkers.cities}\n          radius={cityMarkers.radius}\n          color={cityMarkers.color}\n          markerSize={cityMarkers.markerSize}\n        />\n      )}\n      {!!arcs && (\n        <ArcGroup\n          animationDuration={arcs.animationDuration}\n          color={arcs.color}\n          locationArray={arcs.locationArray}\n          onAllArcsDone={arcs.onAllArcsDone}\n          onProgressPersist={arcs.onProgressPersist}\n          radius={arcs.radius}\n          sequential={arcs.sequential}\n          persistArcBehavior={arcs.persistArcBehavior}\n        />\n      )}\n    </group>\n  );\n};\n\nexport default Globe;\n","import { useFrame, useThree } from \"@react-three/fiber\";\nimport { useEffect, useRef } from \"react\";\nimport * as THREE from \"three\";\nimport { EffectComposer } from \"three/examples/jsm/postprocessing/EffectComposer\";\nimport { RenderPass } from \"three/examples/jsm/postprocessing/RenderPass\";\nimport { UnrealBloomPass } from \"three/examples/jsm/postprocessing/UnrealBloomPass\";\n\ninterface ManualBloomProps {\n  bloomStrength?: number;\n  bloomRadius?: number;\n  bloomThreshold?: number;\n}\n/**\n * A custom post-processing bloom effect that uses:\n * - `EffectComposer` to chain multiple post-processing passes.\n * - `RenderPass` for the base scene rendering.\n * - `UnrealBloomPass` for the bloom effect.\n *\n * @param {ManualBloomProps} props\n * @prop {number} [bloomStrength=0.7] - Controls brightness of bloom highlights.\n * @prop {number} [bloomRadius=0.5] - Determines how large or soft the bloom edges appear.\n * @prop {number} [bloomThreshold=0.0] - Threshold above which areas start to bloom.\n *\n * Rendering order (the second arg in `useFrame`) is set to 1 so the bloom\n * pass happens after the scene renders. Returns null since all rendering\n * is handled via EffectComposer.\n */\nconst ManualBloom = ({\n  bloomStrength = 0.7,\n  bloomRadius = 0.5,\n  bloomThreshold = 0.0,\n}: ManualBloomProps) => {\n  const composer = useRef<EffectComposer | null>(null);\n  const { gl, scene, camera, size } = useThree();\n\n  useEffect(() => {\n    // Create EffectComposer once on mount\n    const effectComposer = new EffectComposer(gl);\n    effectComposer.setSize(size.width, size.height);\n\n    // 1. Render pass (renders the scene normally)\n    const renderScene = new RenderPass(scene, camera);\n    effectComposer.addPass(renderScene);\n\n    // 2. UnrealBloomPass\n    const bloomPass = new UnrealBloomPass(\n      new THREE.Vector2(size.width, size.height),\n      bloomStrength, // strength (how bright the bloom is)\n      bloomRadius, // radius (how wide or soft the bloom edges are)\n      bloomThreshold // threshold (how bright an area must be before it blooms)\n    );\n    effectComposer.addPass(bloomPass);\n\n    composer.current = effectComposer;\n  }, [gl, scene, camera, size, bloomStrength, bloomRadius, bloomThreshold]);\n\n  // Render the composer on every frame\n  useFrame(() => {\n    composer.current?.render();\n  }, 1);\n\n  return null;\n};\n\nexport default ManualBloom;\n","import { ArcLocation } from \"../../../types/earthTypes\";\n\nexport const flightPaths: ArcLocation[] = [\n  //\n  // Roundtrip: NYC -> Dallas -> NYC\n  //\n  {\n    start: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n    end: { lat: 32.7767, lon: -96.797, name: \"Dallas\" }, // Dallas\n  },\n  {\n    start: { lat: 32.7767, lon: -96.797, name: \"Dallas\" }, // Dallas\n    end: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n  },\n\n  //\n  // Roundtrip: NYC -> San Francisco -> NYC\n  //\n  {\n    start: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n    end: { lat: 37.7749, lon: -122.4194, name: \"San Francisco\" }, // San Francisco\n  },\n  {\n    start: { lat: 37.7749, lon: -122.4194, name: \"San Francisco\" }, // San Francisco\n    end: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n  },\n\n  //\n  // Roundtrip: NYC -> Louisville -> NYC\n  //\n  {\n    start: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n    end: { lat: 38.2527, lon: -85.7585, name: \"Louisville\" }, // Louisville\n  },\n  {\n    start: { lat: 38.2527, lon: -85.7585, name: \"Louisville\" }, // Louisville\n    end: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n  },\n\n  //\n  // Roundtrip: NYC -> Seattle -> NYC\n  //\n  {\n    start: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n    end: { lat: 47.6062, lon: -122.3321, name: \"Seattle\" }, // Seattle\n  },\n  {\n    start: { lat: 47.6062, lon: -122.3321, name: \"Seattle\" }, // Seattle\n    end: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n  },\n\n  //\n  // NYC -> Bogota -> Cumaral -> Cartagena -> NYC\n  //\n  {\n    start: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n    end: { lat: 4.711, lon: -74.0721, name: \"Bogota\" }, // Bogota\n  },\n  {\n    start: { lat: 4.711, lon: -74.0721, name: \"Bogota\" }, // Bogota\n    end: { lat: 4.2702, lon: -73.4772, name: \"Cumaral\" }, // Cumaral\n  },\n  {\n    start: { lat: 4.2702, lon: -73.4772, name: \"Cumaral\" }, // Cumaral\n    end: { lat: 10.391, lon: -75.4794, name: \"Cartagena\" }, // Cartagena\n  },\n  {\n    start: { lat: 10.391, lon: -75.4794, name: \"Cartagena\" }, // Cartagena\n    end: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n  },\n\n  //\n  // Roundtrip: NYC -> Destin -> NYC\n  //\n  {\n    start: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n    end: { lat: 30.3935, lon: -86.4958, name: \"Destin\" }, // Destin\n  },\n  {\n    start: { lat: 30.3935, lon: -86.4958, name: \"Destin\" }, // Destin\n    end: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n  },\n\n  //\n  // Roundtrip: NYC -> San Jose, CA -> NYC\n  //\n  {\n    start: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n    end: { lat: 37.3382, lon: -121.8863, name: \"San Jose, CA\" }, // San Jose, CA\n  },\n  {\n    start: { lat: 37.3382, lon: -121.8863, name: \"San Jose, CA\" }, // San Jose, CA\n    end: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n  },\n\n  //\n  // NYC -> Nashville -> Louisville -> NYC\n  //\n  {\n    start: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n    end: { lat: 36.1627, lon: -86.7816, name: \"Nashville\" }, // Nashville\n  },\n  {\n    start: { lat: 36.1627, lon: -86.7816, name: \"Nashville\" }, // Nashville\n    end: { lat: 38.2527, lon: -85.7585, name: \"Louisville\" }, // Louisville\n  },\n  {\n    start: { lat: 38.2527, lon: -85.7585, name: \"Louisville\" }, // Louisville\n    end: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n  },\n\n  //\n  // NYC -> London -> Zurich -> Copenhagen -> Bern -> NYC\n  //\n  {\n    start: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n    end: { lat: 51.5074, lon: -0.1278, name: \"London\" }, // London\n  },\n  {\n    start: { lat: 51.5074, lon: -0.1278, name: \"London\" }, // London\n    end: { lat: 47.3769, lon: 8.5417, name: \"Zurich\" }, // Zurich\n  },\n  {\n    start: { lat: 47.3769, lon: 8.5417, name: \"Zurich\" }, // Zurich\n    end: { lat: 55.6761, lon: 12.5683, name: \"Copenhagen\" }, // Copenhagen\n  },\n  {\n    start: { lat: 55.6761, lon: 12.5683, name: \"Copenhagen\" }, // Copenhagen\n    end: { lat: 46.948, lon: 7.4474, name: \"Bern\" }, // Bern\n  },\n  {\n    start: { lat: 46.948, lon: 7.4474, name: \"Bern\" }, // Bern\n    end: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n  },\n\n  //\n  // Roundtrip: NYC -> Reykjavik -> NYC\n  //\n  {\n    start: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n    end: { lat: 64.1466, lon: -21.9426, name: \"Reykjavik\" }, // Reykjavik\n  },\n  {\n    start: { lat: 64.1466, lon: -21.9426, name: \"Reykjavik\" }, // Reykjavik\n    end: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n  },\n\n  //\n  // Roundtrip: NYC -> Louisville -> NYC\n  //\n  {\n    start: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n    end: { lat: 38.2527, lon: -85.7585, name: \"Louisville\" }, // Louisville\n  },\n  {\n    start: { lat: 38.2527, lon: -85.7585, name: \"Louisville\" }, // Louisville\n    end: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n  },\n\n  //\n  // Roundtrip: NYC -> Louisville -> NYC (again)\n  //\n  {\n    start: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n    end: { lat: 38.2527, lon: -85.7585, name: \"Louisville\" }, // Louisville\n  },\n  {\n    start: { lat: 38.2527, lon: -85.7585, name: \"Louisville\" }, // Louisville\n    end: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n  },\n];\n","import { useTheme } from \"@nextui-org/use-theme\";\nimport { OrbitControls } from \"@react-three/drei\";\nimport { Canvas } from \"@react-three/fiber\";\nimport { Suspense, useEffect, useRef, useState } from \"react\";\nimport useAtOrAboveBreakpoint from \"../../utils/useAtOrAboveBreakpoint\";\nimport Globe from \"./layers/Globe\";\nimport ManualBloom from \"./layers/ManualBlooms\";\nimport { flightPaths } from \"./utils/flightPaths\";\n\nconst MAX_ZOOMED_OUT = 600;\nconst ROTATION_START_ATLANTIC = [0.68, -0.3, 0.28];\nconst EARTH_RADIUS = 150;\nconst EARTH_TILT = 23.4 * (Math.PI / 180); // ~0.41\nconst STARTING_Y = -1;\n\n/**\n * A top-level 3D Earth component that:\n * - Sets up a Three.js Canvas with OrbitControls and performance stats.\n * - Renders the `Globe` component and optional post-processing (ManualBloom).\n */\nconst Earth = () => {\n  // Temp fix: Theme must be set to dark to render the globe, canvas is black (known issue)\n  const { theme, setTheme } = useTheme();\n\n  useEffect(() => {\n    if (theme !== \"dark\") {\n      setTheme(\"dark\");\n    }\n  }, [theme, setTheme]);\n\n  const isSmallUp = useAtOrAboveBreakpoint(\"sm\");\n  const jsonUrl = isSmallUp\n    ? \"/landDots-150rad-40k.json\" // more dots\n    : \"/landDots-150rad-30k.json\"; // fewer dots\n\n  const [isInteracting, setIsInteracting] = useState(false);\n  const resumeRotationTimeout = useRef<NodeJS.Timeout | null>(null);\n\n  const handleInteractionStart = () => {\n    // Clear any existing timeouts\n    if (resumeRotationTimeout.current) {\n      clearTimeout(resumeRotationTimeout.current);\n      resumeRotationTimeout.current = null;\n    }\n    setIsInteracting(true);\n  };\n\n  const handleInteractionEnd = () => {\n    // Wait 2 seconds before resuming rotation\n    resumeRotationTimeout.current = setTimeout(() => {\n      setIsInteracting(false);\n    }, 1000);\n  };\n\n  return (\n    <div className=\"h-full w-full\">\n      <Canvas\n        gl={{ alpha: true }}\n        style={{ background: \"transparent\" }}\n        camera={{ position: [0, 140, MAX_ZOOMED_OUT], fov: 35 }}\n        onCreated={(state) => {\n          // Increase the threshold so clicks are less “exact”.\n          // Adjust the number until it feels right.\n          state.raycaster.params.Points.threshold = 2;\n        }}\n      >\n        {/* <Perf position=\"bottom-right\" /> */}\n\n        <OrbitControls\n          enableDamping={true}\n          minDistance={300}\n          minPolarAngle={0.3} // ~17 degrees\n          maxPolarAngle={Math.PI - 0.3} // ~163 degrees\n          enablePan={false}\n          maxDistance={MAX_ZOOMED_OUT}\n          onStart={handleInteractionStart}\n          onEnd={handleInteractionEnd}\n        />\n\n        {/* Subtle ambient and hemispheral light */}\n        <ambientLight intensity={1} />\n        <hemisphereLight intensity={0.2} position={[0, 50, 0]} />\n\n        <Suspense fallback={null}>\n          <Globe\n            isInteracting={isInteracting}\n            rotationCoords={[EARTH_TILT, STARTING_Y, 0]}\n            rotationSpeed={0.001}\n            radius={EARTH_RADIUS}\n            dots={{\n              dotColor: \"#00aaff\",\n              pointSize: 2.5,\n              jsonUrl,\n            }}\n            // Atmosphere\n            atmosphere={{\n              color: \"#00aaff\",\n              opacity: 0.03, // I fear this isn't hooked up to anything\n              earthRadius: EARTH_RADIUS,\n            }}\n            // Arcs\n            arcs={{\n              locationArray: flightPaths,\n              color: \"#dd6ff0\",\n              radius: EARTH_RADIUS,\n              animationDuration: 700,\n              sequential: false,\n              onProgressPersist: true,\n              onAllArcsDone: \"persist\",\n              persistArcBehavior: undefined,\n            }}\n            cityMarkers={{\n              cities: flightPaths.map((f) => ({\n                lat: f.end.lat,\n                lon: f.end.lon,\n                name: f.end.name,\n              })),\n              radius: EARTH_RADIUS,\n              color: \"#dd6ff0\",\n              markerSize: 1,\n            }}\n          />\n          <ManualBloom\n            bloomStrength={1.2}\n            bloomRadius={1}\n            bloomThreshold={0.3}\n          />\n        </Suspense>\n      </Canvas>\n    </div>\n  );\n};\n\nexport default Earth;\n","import { useParams } from \"react-router-dom\";\nimport Earth from \"../../components/earth/Earth\";\n\nconst ProjectDetails = () => {\n  const { projectSlug } = useParams();\n\n  switch (projectSlug) {\n    case \"earth\":\n      return <Earth />;\n    default:\n      return <div>Oops! Project not found.</div>;\n  }\n};\n\nexport default ProjectDetails;\n","import { useEffect, useState } from \"react\";\n\n// Tailwind's default breakpoints in pixels\nconst BREAKPOINTS = {\n  xs: 320,\n  sm: 640,\n  md: 768,\n  lg: 1024,\n  xl: 1280,\n  \"2xl\": 1536,\n};\n\ntype TailwindBreakpoint = keyof typeof BREAKPOINTS;\n\n/**\n * Usage:\n *   const isLargeUp = useTailwindBreakpoint(\"lg\");\n *   // returns true if window width >= 1024\n */\nconst useAtOrAboveBreakpoint = (breakpoint: TailwindBreakpoint) => {\n  const [matches, setMatches] = useState(false);\n\n  useEffect(() => {\n    function handleResize() {\n      const newMatches = window.innerWidth >= BREAKPOINTS[breakpoint];\n      // Only update state if the value actually changed\n      setMatches((old) => {\n        if (old !== newMatches) {\n          return newMatches;\n        }\n        return old;\n      });\n    }\n\n    window.addEventListener(\"resize\", handleResize);\n    handleResize();\n    return () => window.removeEventListener(\"resize\", handleResize);\n  }, [breakpoint]);\n\n  return matches;\n};\n\nexport default useAtOrAboveBreakpoint;\n"],"names":["latLongToVector3","lat","lon","radius","phi","Math","PI","theta","x","sin","cos","z","y","THREE","_ref","flights","color","behavior","opacity","setOpacity","useState","useEffect","elapsed","flickerInterval","totalDuration","intervalId","setInterval","random","clearInterval","frameId","startTime","performance","now","duration","animate","t","min","requestAnimationFrame","cancelAnimationFrame","arcGeometries","useMemo","map","flight","buildAllArcs","startLat","startLon","endLat","endLon","startVec","endVec","midPoint","addVectors","multiplyScalar","arcHeight","distanceTo","setLength","length","control1","lerpVectors","control2","curve","start","end","_jsx","_Fragment","children","geometry","index","transparent","position","onDone","groupRef","useRef","dotRef","ringRef","FINAL_SCALE","dotScale","setDotScale","ringScale","setRingScale","ringOpacity","setRingOpacity","lengthSq","normal","clone","normalize","zAxis","quat","setFromUnitVectors","current","quaternion","copy","useFrame","newRingScale","_jsxs","ref","scale","args","side","depthTest","PartialCurve","constructor","baseCurve","minT","maxT","super","this","getPoint","optionalTarget","u","animationDuration","onProgressPersist","meshRef","geometryRef","done","setDone","showLandingEffect","setShowLandingEffect","fullCurve","tubeGeometry","indexCount","count","attributes","drawCount","floor","setDrawRange","extendP","retractP","startParam","endParam","visible","partialCurve","newGeom","dispose","object","attach","LandingEffect","locationArray","sequential","onAllArcsDone","persistArcBehavior","currentArcIndex","setCurrentArcIndex","arcsDoneCount","setArcsDoneCount","arcsCompleted","setArcsCompleted","Array","fill","showFinalArcs","setShowFinalArcs","setTimeout","i","ArcLight","prev","AllArcsStaticMesh","AtmosphereShader","uniforms","uColor","value","uIntensity","uPower","vertexShader","fragmentShader","earthRadius","depthWrite","_objectSpread","earthRef","emissive","emissiveIntensity","roughness","markerSize","PulseRing","baseRadius","_ref2","state","delta","userData","set","material","cities","uniqueCities","Map","city","name","from","values","CityMarker","jsonUrl","pointSize","onCountrySelect","onLoaded","dotColor","highlightColor","dots","setDots","highlightRef","highlightTimerRef","pointerDownRef","isDraggingRef","pointerDownDotIndexRef","baseR","baseG","baseB","c","r","g","b","highlightR","highlightG","highlightB","async","res","fetch","data","json","console","log","err","error","fetchDots","positions","Float32Array","arr","push","colors","colorAttrRef","handlePointerDown","useCallback","e","_e$intersections","clientX","clientY","intersections","_firstHit$index","firstHit","sort","a","distance","stopPropagation","handlePointerMove","dx","dy","sqrt","handlePointerUp","event","warn","intersection","upDotIndex","idx","dot","concat","countryName","isoA3","clearTimeout","colorArray","array","offset","needsUpdate","onPointerDown","onPointerMove","onPointerUp","itemSize","vertexColors","size","sizeAttenuation","rotationSpeed","rotationCoords","arcs","atmosphere","cityMarkers","isInteracting","globeRef","isMdUp","useAtOrAboveBreakpoint","isSmUp","isXSUp","targetScale","currentScale","setCurrentScale","dotsLoaded","setDotsLoaded","_","rotation","lerp","BaseSphere","Atmosphere","ContinentDots","isLoaded","CityMarkers","ArcGroup","bloomStrength","bloomRadius","bloomThreshold","composer","gl","scene","camera","useThree","effectComposer","EffectComposer","setSize","width","height","renderScene","RenderPass","addPass","bloomPass","UnrealBloomPass","_composer$current","render","flightPaths","EARTH_RADIUS","EARTH_TILT","Earth","theme","setTheme","useTheme","setIsInteracting","resumeRotationTimeout","className","Canvas","alpha","style","background","fov","onCreated","raycaster","params","Points","threshold","OrbitControls","enableDamping","minDistance","minPolarAngle","maxPolarAngle","enablePan","maxDistance","onStart","handleInteractionStart","onEnd","handleInteractionEnd","intensity","Suspense","fallback","Globe","undefined","f","ManualBloom","ProjectDetails","projectSlug","useParams","BREAKPOINTS","xs","sm","md","lg","xl","breakpoint","matches","setMatches","handleResize","newMatches","window","innerWidth","old","addEventListener","removeEventListener"],"sourceRoot":""}