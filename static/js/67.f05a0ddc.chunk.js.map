{"version":3,"file":"static/js/67.f05a0ddc.chunk.js","mappings":"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","sources":["webpack://homebase/./src/css/typewriter.module.css?13c8","components/Typewriter.tsx","components/earth/utils/arcs.ts","components/earth/layers/arcs/AllArcsStaticMesh.tsx","components/earth/layers/arcs/LandingEffect.tsx","components/earth/layers/arcs/Arc.tsx","components/earth/layers/arcs/ArcGroup.tsx","components/earth/utils/AtmosphereShader.ts","components/earth/layers/Atmosphere.tsx","components/earth/layers/BaseSphere.tsx","components/earth/layers/helpers/CityMarker.tsx","components/earth/layers/CityMarkerGroup.tsx","store/hooks.ts","components/earth/utils/earthMath.ts","components/earth/layers/ContinentDots.tsx","components/earth/layers/Globe.tsx","components/earth/layers/ManualBlooms.tsx","components/earth/SceneHelpers.tsx","components/earth/utils/flightPaths.ts","components/earth/EarthScene.tsx","projects/globe-project/CountryButtons.tsx","projects/globe-project/TheGlobeProjects.tsx","pages/project-details/ProjectDetails.tsx","utils/useAtOrAboveBreakpoint.ts"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport default {\"blink\":\"typewriter_blink__KoZUv\"};","import { useEffect, useState } from \"react\";\nimport styles from \"../css/typewriter.module.css\";\nimport { useLinkColor } from \"../utils/ColorContext\";\n\ninterface TypewriterProps {\n  phrases: string[];\n  period?: number;\n  typingSpeed: number;\n  deletingSpeed: number;\n  loop?: boolean;\n  preserveTrailingNewlines?: boolean;\n}\n\nfunction findPrefixOverlap(a: string, b: string): number {\n  let i = 0;\n  while (i < a.length && i < b.length && a[i] === b[i]) {\n    i++;\n  }\n  return i;\n}\n\nfunction preserveTrailingNewlinesInOverlap(\n  currentPhrase: string,\n  rawOverlapLength: number\n) {\n  if (rawOverlapLength >= currentPhrase.length) return rawOverlapLength;\n  const leftover = currentPhrase.slice(rawOverlapLength);\n  if (/^[\\n\\s]+$/.test(leftover)) {\n    return currentPhrase.length;\n  }\n  return rawOverlapLength;\n}\n\nconst Typewriter = ({\n  phrases,\n  period = 2000,\n  typingSpeed,\n  deletingSpeed,\n  loop = true,\n  preserveTrailingNewlines = false,\n}: TypewriterProps) => {\n  const [phase, setPhase] = useState<\"typing\" | \"deleting\" | \"pause\">(\"typing\");\n  const [index, setIndex] = useState(0);\n  const [charIndex, setCharIndex] = useState(0);\n\n  const { linkColor } = useLinkColor();\n\n  // Whenever phrases changes, reset the typewriter\n  useEffect(() => {\n    setPhase(\"typing\");\n    setIndex(0);\n    setCharIndex(0);\n  }, [phrases]);\n\n  const isLastPhrase = !loop && index === phrases.length - 1;\n\n  const currentPhrase = phrases[index] ?? \"\";\n  const nextPhrase = isLastPhrase ? \"\" : phrases[(index + 1) % phrases.length];\n\n  let overlapLength = findPrefixOverlap(currentPhrase, nextPhrase);\n  if (preserveTrailingNewlines) {\n    overlapLength = preserveTrailingNewlinesInOverlap(\n      currentPhrase,\n      overlapLength\n    );\n  }\n\n  useEffect(() => {\n    if (phase === \"typing\") {\n      if (charIndex < currentPhrase.length) {\n        // Slow down for newlines / periods\n        const nextChar = currentPhrase[charIndex];\n        let currentTypingSpeed = typingSpeed;\n        if (nextChar === \".\" || nextChar === \"\\n\") {\n          currentTypingSpeed *= 2;\n        }\n\n        const timeoutId = setTimeout(() => {\n          setCharIndex((c) => c + 1);\n        }, currentTypingSpeed);\n        return () => clearTimeout(timeoutId);\n      } else {\n        // Done typing; pause\n        const pauseId = setTimeout(() => {\n          setPhase(\"pause\");\n        }, period);\n        return () => clearTimeout(pauseId);\n      }\n    } else if (phase === \"pause\") {\n      if (isLastPhrase) return;\n      setPhase(\"deleting\");\n    } else if (phase === \"deleting\") {\n      if (charIndex > overlapLength) {\n        // Slow down for newlines / periods\n        const prevChar = currentPhrase[charIndex - 1];\n        let currentDeletingSpeed = deletingSpeed;\n        if (prevChar === \".\" || prevChar === \"\\n\") {\n          currentDeletingSpeed *= 2;\n        }\n\n        const timeoutId = setTimeout(() => {\n          setCharIndex((c) => c - 1);\n        }, currentDeletingSpeed);\n        return () => clearTimeout(timeoutId);\n      } else {\n        // If looping, move on; otherwise just end\n        setIndex((i) => (loop ? (i + 1) % phrases.length : i + 1));\n        setPhase(\"typing\");\n      }\n    }\n  }, [\n    phase,\n    charIndex,\n    currentPhrase,\n    overlapLength,\n    period,\n    typingSpeed,\n    deletingSpeed,\n    index,\n    nextPhrase,\n    isLastPhrase,\n    loop,\n    phrases.length,\n  ]);\n\n  const display = currentPhrase.slice(0, charIndex);\n\n  function renderWithLineBreaks(text: string) {\n    return text.split(\"\\n\").map((segment, i, arr) => (\n      <span key={i}>\n        {segment}\n        {i < arr.length - 1 && <br />}\n      </span>\n    ));\n  }\n\n  return (\n    <div>\n      {renderWithLineBreaks(display)}\n      <span\n        className={`border-r-[2.5px] solid ml-[1.8px] ${styles.blink}`}\n        style={{ borderColor: linkColor }}\n      />\n    </div>\n  );\n};\n\nexport default Typewriter;\n","import * as THREE from \"three\";\n\n/**\n * Convert latitude & longitude to a THREE.Vector3 on a sphere.\n * @param lat   latitude in degrees\n * @param lon   longitude in degrees\n * @param radius sphere radius\n */\nexport const latLongToVector3 = (lat: number, lon: number, radius: number) => {\n  const phi = (90 - lat) * (Math.PI / 180);\n  const theta = (lon + 180) * (Math.PI / 180);\n\n  const x = -radius * Math.sin(phi) * Math.cos(theta);\n  const z = radius * Math.sin(phi) * Math.sin(theta);\n  const y = radius * Math.cos(phi);\n\n  return new THREE.Vector3(x, y, z);\n};\n\n/**\n * buildFullArcGeometry\n *\n * Creates a THREE.TubeGeometry for a 3D arc using the same\n * cubic-bezier control logic that your animated ArcLight uses.\n */\nexport const buildAllArcs = (\n  startLat: number,\n  startLon: number,\n  endLat: number,\n  endLon: number,\n  radius: number\n) => {\n  const startVec = latLongToVector3(startLat, startLon, radius);\n  const endVec = latLongToVector3(endLat, endLon, radius);\n\n  // Approx midpoint logic\n  const midPoint = new THREE.Vector3()\n    .addVectors(startVec, endVec)\n    .multiplyScalar(0.5);\n  const distance = startVec.distanceTo(endVec);\n  const arcHeight = distance * 1.5;\n  midPoint.setLength(midPoint.length() + arcHeight);\n\n  const control1 = new THREE.Vector3().lerpVectors(startVec, midPoint, 0.25);\n  const control2 = new THREE.Vector3().lerpVectors(startVec, midPoint, 0.75);\n\n  // Build a cubic bezier arc\n  const curve = new THREE.CubicBezierCurve3(\n    startVec,\n    control1,\n    control2,\n    endVec\n  );\n\n  return new THREE.TubeGeometry(curve, 64, 0.5, 8, false);\n};\n","import { useEffect, useMemo, useState } from \"react\";\nimport { AllArcsBehavior, ArcLocation } from \"../../../../types/earthTypes\";\nimport { buildAllArcs } from \"../../utils/arcs\";\n\nexport interface AllArcsStaticMeshProps {\n  /**\n   * Array of flight arc locations with start and end coordinates.\n   */\n  flights: ArcLocation[];\n  /**\n   * Base color of the arcs.\n   */\n  color: string;\n  /**\n   * Radius of the sphere on which the arcs are drawn.\n   */\n  radius: number;\n  /**\n   * Animation behavior for the arcs.\n   */\n  behavior?: AllArcsBehavior;\n}\n\n/**\n * `AllArcsStaticMesh` renders multiple arcs as static or animated meshes.\n * - Animates opacity based on the specified `behavior`.\n * - Generates arc geometries dynamically for each flight in the `flights` array.\n */\nconst AllArcsStaticMesh = ({\n  flights,\n  color,\n  radius,\n  behavior,\n}: AllArcsStaticMeshProps) => {\n  // Single opacity state shared by all arcs\n  const [opacity, setOpacity] = useState(!behavior ? 1 : 0);\n\n  useEffect(() => {\n    // If flicker is true, we do the old-timey rapid toggling.\n    if (behavior === \"flicker\") {\n      // Flicker for 1 second (1000 ms), toggling every 100 ms\n      let elapsed = 0;\n      const flickerInterval = 100;\n      const totalDuration = 1000;\n      const intervalId = setInterval(() => {\n        elapsed += flickerInterval;\n        // Randomly go 0 or 1\n        setOpacity(Math.random() < 0.5 ? 0 : 1);\n\n        // After flicker finishes, set full\n        if (elapsed >= totalDuration) {\n          clearInterval(intervalId);\n          setOpacity(1);\n        }\n      }, flickerInterval);\n\n      return () => clearInterval(intervalId);\n\n      // Else if smoothOn is true, do a modern fade from 0 to 1\n    } else if (behavior === \"smooth\") {\n      // We'll animate from 0 to 1 over 1 second\n      let frameId: number | null = null;\n      const startTime = performance.now();\n      const duration = 1000; // 1 second\n\n      const animate = (now: number) => {\n        const elapsed = now - startTime;\n        const t = Math.min(elapsed / duration, 1); // clamp 0..1\n        setOpacity(t);\n\n        if (t < 1) {\n          frameId = requestAnimationFrame(animate);\n        }\n      };\n\n      frameId = requestAnimationFrame(animate);\n      return () => {\n        if (frameId) cancelAnimationFrame(frameId);\n      };\n\n      // Otherwise, show immediately at full opacity\n    } else {\n      setOpacity(1);\n    }\n  }, [behavior]);\n\n  // Precompute the geometries\n  const arcGeometries = useMemo(() => {\n    return flights.map((flight) => {\n      return buildAllArcs(\n        flight.start.lat,\n        flight.start.lon,\n        flight.end.lat,\n        flight.end.lon,\n        radius\n      );\n    });\n  }, [flights, radius]);\n\n  return (\n    <>\n      {arcGeometries.map((geometry, index) => (\n        <mesh key={index} geometry={geometry}>\n          <meshBasicMaterial color={color} transparent opacity={opacity} />\n        </mesh>\n      ))}\n    </>\n  );\n};\n\nexport default AllArcsStaticMesh;\n","import { useFrame } from \"@react-three/fiber\";\nimport { useEffect, useRef, useState } from \"react\";\nimport * as THREE from \"three\";\n\ninterface ArcLandingEffectProps {\n  position: THREE.Vector3;\n  color?: string;\n  onDone?: () => void;\n}\n\nconst LandingEffect = ({\n  position,\n  color = \"#ffffff\",\n  onDone,\n}: ArcLandingEffectProps) => {\n  const groupRef = useRef<THREE.Group>(null!);\n\n  // If you want separate references to tweak them individually:\n  const dotRef = useRef<THREE.Mesh>(null!);\n  const ringRef = useRef<THREE.Mesh>(null!);\n\n  // Circle’s *base* radius (the dot):\n  const BASE_RADIUS = 1;\n\n  // How large do we want them to expand? (1 = same size as base, 2 = double, etc.)\n  const FINAL_SCALE = 1.3;\n\n  // Local state for scale & opacity\n  const [dotScale, setDotScale] = useState(0); // for the solid circle\n  const [ringScale, setRingScale] = useState(0); // for the expanding ring\n  const [ringOpacity, setRingOpacity] = useState(1);\n\n  // Orient the group’s +Z axis toward the point on the globe\n  useEffect(() => {\n    if (position.lengthSq() === 0) return;\n    const normal = position.clone().normalize();\n    const zAxis = new THREE.Vector3(0, 0, 1);\n    const quat = new THREE.Quaternion().setFromUnitVectors(zAxis, normal);\n    groupRef.current.quaternion.copy(quat);\n  }, [position]);\n\n  useFrame(() => {\n    // Animate dot scale: step ~6% closer to 1\n    const newDotScale = dotScale + (1 - dotScale) * 0.06;\n    setDotScale(newDotScale);\n\n    // Animate ring scale: step ~6% closer to 1\n    const newRingScale = ringScale + (1 - ringScale) * 0.06;\n    setRingScale(newRingScale);\n\n    // Fade ring out as it nears full scale\n    const newOpacity = 1 - newRingScale;\n    setRingOpacity(newOpacity);\n\n    // Once it's mostly expanded, remove it\n    if (newRingScale > 0.98) {\n      onDone?.();\n    }\n  });\n\n  return (\n    <group ref={groupRef} position={position}>\n      {/* Dot (solid circle) */}\n      <mesh\n        ref={dotRef}\n        scale={[\n          dotScale * FINAL_SCALE,\n          dotScale * FINAL_SCALE,\n          dotScale * FINAL_SCALE,\n        ]}\n      >\n        <circleGeometry args={[BASE_RADIUS, 64]} />\n        <meshBasicMaterial color={color} transparent opacity={1} />\n      </mesh>\n\n      <mesh\n        ref={ringRef}\n        scale={[\n          ringScale * FINAL_SCALE,\n          ringScale * FINAL_SCALE,\n          ringScale * FINAL_SCALE,\n        ]}\n      >\n        <ringGeometry args={[2.95, 3.1, 64]} />\n        <meshBasicMaterial\n          color={color}\n          transparent\n          opacity={ringOpacity}\n          side={THREE.DoubleSide}\n          depthTest={true}\n        />\n      </mesh>\n    </group>\n  );\n};\n\nexport default LandingEffect;\n","import { useFrame } from \"@react-three/fiber\";\nimport { useMemo, useRef, useState } from \"react\";\nimport * as THREE from \"three\";\nimport { latLongToVector3 } from \"../../utils/arcs\";\nimport LandingEffect from \"./LandingEffect\";\n\ninterface ArcProps {\n  /**\n   * Color of the arc.\n   */\n  color: string;\n  /**\n   * Starting latitude in degrees.\n   */\n  startLat: number;\n  /**\n   * Starting longitude in degrees.\n   */\n  startLon: number;\n  /**\n   * Ending latitude in degrees.\n   */\n  endLat: number;\n  /**\n   * Ending longitude in degrees.\n   */\n  endLon: number;\n  /**\n   * Radius of the sphere on which the arc is drawn.\n   */\n  radius: number;\n  /**\n   * Duration of the arc animation in milliseconds.\n   * Defaults to 2500ms.\n   */\n  animationDuration?: number;\n  /**\n   * Callback function triggered when the arc animation completes.\n   */\n  onDone?: () => void;\n  /**\n   * Whether the arc persists after drawing or retracts in a two-phase animation.\n   * Defaults to `false`.\n   */\n  onProgressPersist?: boolean;\n}\n\n/**\n * `PartialCurve` extends a base `THREE.Curve` to only render a section (partial curve)\n * between `minT` and `maxT`.\n */\nclass PartialCurve extends THREE.Curve<THREE.Vector3> {\n  baseCurve: THREE.Curve<THREE.Vector3>;\n  minT: number;\n  maxT: number;\n\n  /**\n   * Constructs a `PartialCurve` from a base curve and fractional range [minT, maxT].\n   * @param baseCurve The base curve (e.g., `THREE.CubicBezierCurve3`) to extract from.\n   * @param minT Start fraction of the curve (0.0–1.0).\n   * @param maxT End fraction of the curve (0.0–1.0).\n   */\n  constructor(\n    baseCurve: THREE.Curve<THREE.Vector3>,\n    minT: number,\n    maxT: number\n  ) {\n    super();\n    this.baseCurve = baseCurve;\n    this.minT = minT;\n    this.maxT = maxT;\n  }\n\n  /**\n   * Computes a point on the partial curve given `t` (fractional position).\n   * @param t Fraction along the partial curve (0.0–1.0).\n   * @param optionalTarget Optional target vector for storing the result.\n   * @returns The computed point as a `THREE.Vector3`.\n   */\n  getPoint(t: number, optionalTarget?: THREE.Vector3) {\n    const u = this.minT + (this.maxT - this.minT) * t;\n    return this.baseCurve.getPoint(u, optionalTarget);\n  }\n}\n\n/**\n * `Arc` renders a curved path between two geographic points on a sphere.\n * - Animates the arc over time, optionally showing a landing effect upon completion.\n * - Supports both persistent and retractable animations.\n */\nconst Arc = ({\n  color,\n  startLat,\n  startLon,\n  endLat,\n  endLon,\n  radius,\n  animationDuration = 2500,\n  onDone,\n  onProgressPersist = false,\n}: ArcProps) => {\n  const meshRef = useRef<THREE.Mesh>(null!);\n  const geometryRef = useRef<THREE.TubeGeometry>(null!);\n  const [done, setDone] = useState(false);\n  const [startTime] = useState(() => performance.now());\n  const [showLandingEffect, setShowLandingEffect] = useState(false);\n\n  // Convert lat/lon → 3D vectors on the sphere\n  const startVec = useMemo(\n    () => latLongToVector3(startLat, startLon, radius),\n    [startLat, startLon, radius]\n  );\n  const endVec = useMemo(\n    () => latLongToVector3(endLat, endLon, radius),\n    [endLat, endLon, radius]\n  );\n\n  // Full arc\n  const fullCurve = useMemo(() => {\n    const midPoint = new THREE.Vector3()\n      .addVectors(startVec, endVec)\n      .multiplyScalar(0.5);\n    const distance = startVec.distanceTo(endVec);\n    const arcHeight = distance * 1.5;\n    midPoint.setLength(midPoint.length() + arcHeight);\n\n    const control1 = new THREE.Vector3().lerpVectors(startVec, midPoint, 0.25);\n    const control2 = new THREE.Vector3().lerpVectors(startVec, midPoint, 0.75);\n\n    return new THREE.CubicBezierCurve3(startVec, control1, control2, endVec);\n  }, [startVec, endVec]);\n\n  // Create a (full) TubeGeometry once\n  const tubeGeometry = useMemo(() => {\n    return new THREE.TubeGeometry(fullCurve, 64, 0.5, 8, false);\n  }, [fullCurve]);\n\n  // Store that geometry in geometryRef so we can .setDrawRange() on it\n  useMemo(() => {\n    geometryRef.current = tubeGeometry;\n  }, [tubeGeometry]);\n\n  useFrame(() => {\n    if (done) return;\n\n    const elapsed = performance.now() - startTime;\n    let t = elapsed / animationDuration;\n    if (t > 1) t = 1;\n\n    if (onProgressPersist) {\n      // Single-phase (persist mode), 0->1, using setDrawRange\n      const indexCount = geometryRef.current.index\n        ? geometryRef.current.index.count\n        : geometryRef.current.attributes.position.count;\n      const drawCount = Math.floor(indexCount * t);\n      geometryRef.current.setDrawRange(0, drawCount);\n\n      // Optional: show the effect at t=1 in persist mode\n      if (t >= 1) {\n        geometryRef.current.setDrawRange(0, indexCount);\n        // If you want the landing effect as soon as we fully reach the end:\n        if (!showLandingEffect) {\n          setShowLandingEffect(true);\n        }\n        setDone(true);\n        onDone?.();\n      }\n    } else {\n      // Two-phase: 0..0.5 => extend, 0.5..1 => retract\n      if (!meshRef.current) return;\n\n      let extendP = 0;\n      let retractP = 0;\n\n      if (t <= 0.5) {\n        // extending\n        extendP = t / 0.5; // 0..1\n        retractP = 0;\n      } else {\n        // retracting\n        extendP = 1;\n        retractP = (t - 0.5) / 0.5; // 0..1\n\n        // As soon as the arc hits the end (t >= 0.5) show landing effect\n        if (!showLandingEffect) {\n          setShowLandingEffect(true);\n        }\n      }\n\n      const startParam = retractP; // grows 0..1 in second half\n      const endParam = extendP; // 0..1 in first half, pinned at 1 in second half\n\n      if (endParam <= startParam) {\n        meshRef.current.visible = false;\n      } else {\n        meshRef.current.visible = true;\n        const partialCurve = new PartialCurve(fullCurve, startParam, endParam);\n        const newGeom = new THREE.TubeGeometry(partialCurve, 64, 0.5, 8, false);\n\n        // Dispose old geometry to avoid leaks\n        if (meshRef.current.geometry) {\n          (meshRef.current.geometry as THREE.BufferGeometry).dispose();\n        }\n        meshRef.current.geometry = newGeom;\n      }\n\n      if (t >= 1) {\n        // fully done\n        meshRef.current.visible = false;\n        setDone(true);\n        onDone?.();\n      }\n    }\n  });\n\n  return (\n    <>\n      <mesh ref={meshRef}>\n        {/* For persist arcs, we pass in the stable geometryRef */}\n        {onProgressPersist ? (\n          <primitive object={tubeGeometry} attach=\"geometry\" />\n        ) : null}\n        <meshBasicMaterial color={color} transparent opacity={0.9} />\n      </mesh>\n\n      {/* Show landing effect when showLandingEffect = true */}\n      {showLandingEffect && (\n        <LandingEffect\n          position={endVec}\n          color=\"#ffcd53\"\n          onDone={() => setShowLandingEffect(false)}\n        />\n      )}\n    </>\n  );\n};\n\nexport default Arc;\n","import { useEffect, useState } from \"react\";\nimport {\n  AllArcsBehavior,\n  ArcLocation,\n  OnAllArcsDoneBehavior,\n} from \"../../../../types/earthTypes\";\nimport AllArcsStaticMesh from \"./AllArcsStaticMesh\";\nimport ArcLight from \"./Arc\";\n\nexport interface ArcGroupProps {\n  /**\n   * Array of start and end coordinates for each arc.\n   */\n  locationArray: ArcLocation[];\n\n  /**\n   * If true, arcs animate sequentially one-by-one.\n   * If false, all arcs animate in parallel.\n   */\n  sequential?: boolean;\n\n  /**\n   * Color of the arcs (e.g., hex code, RGB, etc.).\n   */\n  color: string;\n\n  /**\n   * Radius of the globe used to map lat/lon to 3D coordinates.\n   */\n  radius: number;\n\n  /**\n   * Duration of each arc animation in milliseconds.\n   * Default is 2500ms.\n   */\n  animationDuration?: number;\n\n  /**\n   * If true, completed arcs remain visible after animation ends.\n   * If false, arcs disappear upon completing their animation.\n   */\n  onProgressPersist?: boolean;\n\n  /**\n   * Behavior when all arcs finish:\n   *  - \"persist\": Keep arcs visible (default).\n   *  - \"remove\": Hide all arcs immediately after completion.\n   *  - \"reset\": Hide arcs and restart the animation sequence.\n   */\n  onAllArcsDone?: OnAllArcsDoneBehavior;\n\n  /**\n   * Determines how arcs behave after persisting in the final state.\n   */\n  persistArcBehavior: AllArcsBehavior;\n}\n\n/**\n * Component for rendering a group of arcs between geographic points.\n * Arcs can animate sequentially or in parallel based on the `sequential` prop.\n *\n * Once an arc finishes:\n *  - If `onProgressPersist` is false, the arc disappears.\n *  - Otherwise, the arc remains visible until all arcs are complete.\n *\n * When all arcs finish:\n *  - Behavior is determined by the `onAllArcsDone` prop.\n */\nconst ArcGroup = ({\n  locationArray,\n  sequential = false,\n  color,\n  radius,\n  animationDuration = 2500,\n  onProgressPersist = true,\n  onAllArcsDone = \"persist\",\n  persistArcBehavior,\n}: ArcGroupProps) => {\n  /**\n   * currentArcIndex:\n   *  - In sequential mode, the index of the arc currently animating (or just finished).\n   *  - In parallel mode, not really used to limit arcs, but we still track for resetting logic.\n   */\n  const [currentArcIndex, setCurrentArcIndex] = useState(0);\n\n  /**\n   * arcsDoneCount: how many arcs have fully completed their animation.\n   */\n  const [arcsDoneCount, setArcsDoneCount] = useState(0);\n\n  /**\n   * Track which arcs have completed to control per-arc visibility if onProgressPersist=false\n   */\n  const [arcsCompleted, setArcsCompleted] = useState<boolean[]>(\n    Array(locationArray.length).fill(false)\n  );\n\n  const [showFinalArcs, setShowFinalArcs] = useState(false);\n\n  /**\n   * Reset everything if the user chooses \"reset\" after the final arc,\n   * or if we mount fresh.\n   */\n  const resetAll = () => {\n    setCurrentArcIndex(0);\n    setArcsDoneCount(0);\n    setArcsCompleted(Array(locationArray.length).fill(false));\n  };\n\n  /**\n   * Once the final arc is done, handle \"onAllArcsDone\" behavior\n   */\n  useEffect(() => {\n    if (arcsDoneCount === locationArray.length && locationArray.length > 0) {\n      // If we've just completed the final arc:\n      switch (onAllArcsDone) {\n        case \"remove\":\n          // Hide all arcs\n          setArcsCompleted(Array(locationArray.length).fill(true));\n          // But \"onProgressPersist\" logic here means we set arcsCompleted to show them as \"done\"\n          // Actually, we want them hidden, so let's do a separate \"removeAll\" approach:\n          setTimeout(() => {\n            // Instantly hide all arcs\n            setArcsCompleted(Array(locationArray.length).fill(false));\n          }, 0);\n          break;\n        case \"reset\":\n          // Wait a short moment so we can see the final arc\n          setTimeout(() => {\n            resetAll();\n          }, 500);\n          break;\n        case \"persist\":\n          setShowFinalArcs(true);\n          break;\n        default:\n          break;\n      }\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [arcsDoneCount, locationArray.length, onAllArcsDone]);\n\n  return (\n    <>\n      {!showFinalArcs &&\n        locationArray.map((flight, i) => {\n          // If we are in sequential mode, skip arcs beyond currentArcIndex\n          if (sequential && i > currentArcIndex) {\n            return null;\n          }\n\n          // If arc i is done & onProgressPersist is false => hide it\n          if (arcsCompleted[i] && !onProgressPersist) {\n            return null;\n          }\n\n          return (\n            <ArcLight\n              key={i}\n              color={color}\n              startLat={flight.start.lat}\n              startLon={flight.start.lon}\n              endLat={flight.end.lat}\n              endLon={flight.end.lon}\n              radius={radius + 0.1}\n              onProgressPersist={onProgressPersist}\n              animationDuration={animationDuration}\n              onDone={() => {\n                setArcsCompleted((prev) => {\n                  const copy = [...prev];\n                  copy[i] = true;\n                  return copy;\n                });\n\n                // Increase arcsDoneCount\n                setArcsDoneCount((prev) => prev + 1);\n\n                // If sequential, move to the next arc in line\n                if (sequential && i === currentArcIndex) {\n                  setTimeout(() => {\n                    setCurrentArcIndex((prev) => prev + 1);\n                  }, 500);\n                }\n              }}\n            />\n          );\n        })}\n      {showFinalArcs && (\n        <AllArcsStaticMesh\n          flights={locationArray}\n          color={color}\n          radius={radius + 0.1}\n          behavior={persistArcBehavior}\n        />\n      )}\n    </>\n  );\n};\n\nexport default ArcGroup;\n","// AtmosphereShader.ts\nimport * as THREE from \"three\";\n\nexport const AtmosphereShader = {\n  uniforms: {\n    uColor: { value: new THREE.Color(\"#00aaff\") },\n    uIntensity: { value: 1.0 }, // how strong the glow is\n    uPower: { value: 2.0 }, // how quickly it falls off\n  },\n  vertexShader: `\n    varying vec3 vNormal;\n    void main() {\n      vNormal = normalize(normal);\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  `,\n  fragmentShader: `\n    uniform vec3 uColor;\n    uniform float uIntensity;\n    uniform float uPower;\n    varying vec3 vNormal;\n    \n    void main() {\n      // Fresnel-like term: how perpendicular the normal is to the view direction\n      float intensity = pow(1.0 - dot(vNormal, vec3(0.0, 0.0, 1.0)), uPower);\n      gl_FragColor = vec4(uColor, intensity * uIntensity);\n    }\n  `,\n};\n","// Atmosphere.tsx\nimport { useRef } from \"react\";\nimport * as THREE from \"three\";\nimport { AtmosphereShader } from \"../utils/AtmosphereShader\";\n\nexport interface AtmosphereProps {\n  earthRadius: number;\n  color: string;\n  opacity: number;\n}\n\n/**\n * `Atmosphere` is a slightly larger, inverted sphere around the Earth for a glowing atmospheric effect.\n * Uses a custom shader from `AtmosphereShader`.\n *\n * @param {AtmosphereProps} props\n *   @prop {number} earthRadius - Base radius of the Earth sphere.\n *   @prop {string} color - Color for the atmosphere glow (hex).\n *   @prop {number} opacity - Opacity level for the atmospheric glow.\n *\n * Renders a sphere with THREE.BackSide and a custom shader material to achieve a radial glow.\n */\nconst Atmosphere = ({ earthRadius, color, opacity }: AtmosphereProps) => {\n  const meshRef = useRef<THREE.Mesh>(null);\n\n  return (\n    <mesh ref={meshRef}>\n      <sphereGeometry args={[earthRadius * 1.018, 80, 80]} />\n      <shaderMaterial\n        side={THREE.BackSide}\n        transparent={true}\n        depthWrite={false}\n        uniforms={{\n          ...AtmosphereShader.uniforms,\n          uColor: { value: new THREE.Color(color) },\n          uIntensity: { value: 1.2 },\n          uPower: { value: 2.0 },\n        }}\n        vertexShader={AtmosphereShader.vertexShader}\n        fragmentShader={AtmosphereShader.fragmentShader}\n        opacity={opacity}\n      />\n    </mesh>\n  );\n};\n\nexport default Atmosphere;\n","interface BaseSphereProps {\n  radius: number;\n}\n\n/**\n * The main Earth sphere mesh, without any atmosphere or land dots.\n *\n * @param {BaseSphereProps} props\n *   @prop {number} radius - Radius of the sphere geometry.\n *\n * Uses a meshStandardMaterial for basic shading, plus a slight emissive glow.\n */\nconst BaseSphere = ({ radius }: BaseSphereProps) => {\n  return (\n    <mesh>\n      <sphereGeometry args={[radius, 64, 64]} />\n      <meshStandardMaterial\n        color=\"#0b2a57\"\n        emissive=\"#081c3c\"\n        emissiveIntensity={0.3}\n        roughness={0.45}\n      />\n    </mesh>\n  );\n};\n\nexport default BaseSphere;\n","import { useFrame } from \"@react-three/fiber\";\nimport { useEffect, useMemo, useRef } from \"react\";\nimport * as THREE from \"three\";\n\ninterface CityMarkerProps {\n  position: THREE.Vector3;\n  color: string;\n  markerSize: number;\n}\n\n/**\n * A single marker that is oriented to face outward from the globe.\n * - Renders a base circle marker plus a pulsing ring effect.\n */\nconst CityMarker = ({ position, color, markerSize }: CityMarkerProps) => {\n  // This is the correct way to define a React Three Fiber ref:\n  const groupRef = useRef<THREE.Group>(null!);\n\n  // Compute the normal only once per position\n  const normal = useMemo(() => position.clone().normalize(), [position]);\n\n  // Once the group is rendered, set its orientation & position\n  useEffect(() => {\n    if (!groupRef.current) return;\n    const zAxis = new THREE.Vector3(0, 0, 1);\n    const quat = new THREE.Quaternion().setFromUnitVectors(zAxis, normal);\n\n    groupRef.current.quaternion.copy(quat);\n    groupRef.current.position.copy(position);\n  }, [normal, position]);\n\n  return (\n    <group ref={groupRef}>\n      {/* Base marker (circle) */}\n      <mesh>\n        <circleGeometry args={[markerSize, 32]} />\n        <meshBasicMaterial color={color} side={THREE.DoubleSide} />\n      </mesh>\n\n      {/* Pulsing ring effect */}\n      <PulseRing baseRadius={markerSize * 1} color={color} />\n    </group>\n  );\n};\n\nexport default CityMarker;\n\n/**\n * A repeatedly-expanding ring that fades out as it grows, then resets.\n * You can tweak the speed, scale, and fade for your desired \"pulse.\"\n */\nfunction PulseRing({\n  baseRadius,\n  color,\n}: {\n  baseRadius: number;\n  color: string;\n}) {\n  const ringRef = useRef<THREE.Mesh>(null!);\n\n  /**\n   * We'll animate a \"phase\" t from 0..1 over some duration, then reset to 0.\n   * - scale = 1 + 1 * t (grows from 1 → 2)\n   * - opacity = 1 - t   (fades from 1 → 0)\n   */\n  const PULSE_DURATION = 2.2; // seconds per pulse\n  const MIN_SCALE = 1;\n  const MAX_SCALE = 2.5;\n\n  useFrame((state, delta) => {\n    if (!ringRef.current) return;\n\n    // We'll track time in ringRef’s userData (or you could use a useRef for the time).\n    // Accumulate delta each frame, loop back when passing PULSE_DURATION.\n    if (!ringRef.current.userData.elapsed) {\n      ringRef.current.userData.elapsed = 0;\n    }\n\n    ringRef.current.userData.elapsed += delta;\n    let t = ringRef.current.userData.elapsed / PULSE_DURATION;\n\n    // If time > PULSE_DURATION, reset\n    if (t > 1) {\n      ringRef.current.userData.elapsed = 0;\n      t = 0;\n    }\n\n    // scale 1..2\n    const scale = MIN_SCALE + (MAX_SCALE - MIN_SCALE) * t;\n    // fade 1..0\n    const opacity = 1 - t;\n\n    ringRef.current.scale.set(scale, scale, scale);\n    const material = ringRef.current.material as THREE.MeshBasicMaterial;\n    material.opacity = opacity;\n  });\n\n  return (\n    <mesh ref={ringRef}>\n      {/* Slightly thin ring geometry so it looks like a halo */}\n      <ringGeometry args={[baseRadius * 1, baseRadius * 1.5, 64]} />\n      <meshBasicMaterial\n        color={color}\n        transparent\n        opacity={1}\n        side={THREE.DoubleSide}\n      />\n    </mesh>\n  );\n}\n","import { useMemo } from \"react\";\nimport { CityLocation } from \"../../../types/earthTypes\";\nimport { latLongToVector3 } from \"../utils/arcs\";\nimport CityMarker from \"./helpers/CityMarker\";\n\nexport interface CityMarkersProps {\n  cities: CityLocation[];\n  radius: number;\n  color?: string;\n  markerSize?: number;\n}\n\nconst CityMarkers = ({\n  cities,\n  radius,\n  color = \"#ffcd53\",\n  markerSize = 1.5,\n}: CityMarkersProps) => {\n  // 1) Deduplicate by name (optional if your data is guaranteed unique):\n  const uniqueCities = useMemo(() => {\n    const map = new Map();\n    for (const city of cities) {\n      map.set(city.name, city);\n    }\n    return Array.from(map.values());\n  }, [cities]);\n\n  return (\n    <>\n      {uniqueCities.map((city, i) => {\n        // Convert lat/lon to Vector3 on the sphere\n        const position = latLongToVector3(city.lat, city.lon, radius);\n\n        return (\n          <CityMarker\n            key={city.name + i}\n            position={position}\n            color={color}\n            markerSize={markerSize}\n          />\n        );\n      })}\n    </>\n  );\n};\n\nexport default CityMarkers;\n","import { TypedUseSelectorHook, useDispatch, useSelector } from \"react-redux\";\nimport type { AppDispatch, RootState } from \"./store\";\n\n// Use throughout your app instead of plain `useDispatch` and `useSelector`\nexport const useAppDispatch = () => useDispatch<AppDispatch>();\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;\n","import gsap from \"gsap\";\nimport * as THREE from \"three\";\nimport { OrbitControls as OrbitControlsImpl } from \"three-stdlib\";\nimport { DotInfo } from \"../../../types/earthTypes\";\n\ninterface GetCountryCentroidProps {\n  isoA3: string;\n  dots: DotInfo[];\n}\n\n/**\n * Given an ISO code and an array of DotInfo,\n * compute the average (x, y, z) of all dots for that ISO.\n */\nexport const getCountryCentroid = ({\n  isoA3,\n  dots,\n}: GetCountryCentroidProps): THREE.Vector3 | null => {\n  const countryDots = dots.filter((d) => d.isoA3 === isoA3);\n  if (!countryDots.length) return null;\n\n  let sumX = 0,\n    sumY = 0,\n    sumZ = 0;\n  for (const d of countryDots) {\n    sumX += d.x;\n    sumY += d.y;\n    sumZ += d.z;\n  }\n\n  const count = countryDots.length;\n  return new THREE.Vector3(sumX / count, sumY / count, sumZ / count);\n};\n\ninterface FlyCameraToPointProps {\n  camera: THREE.Camera;\n  controls: OrbitControlsImpl;\n  targetPos: THREE.Vector3;\n  distanceOffset?: number;\n}\n\n/**\n * Fly the camera so that `targetPos` ends up in front of you.\n * - `camera`: your THREE.Camera\n * - `controls`: your OrbitControls reference\n * - `targetPos`: a THREE.Vector3 (e.g. a country centroid)\n * - `distanceOffset`: how far away (in world units) to position the camera from that point\n */\nexport const flyCameraToPoint = ({\n  camera,\n  controls,\n  targetPos,\n  distanceOffset = 300,\n}: FlyCameraToPointProps): void => {\n  // 1) Compute a camera position that is `distanceOffset` away from targetPos\n  const dir = targetPos.clone().normalize();\n  const newCamPos = dir.multiplyScalar(targetPos.length() + distanceOffset);\n\n  // 2) Animate the camera position\n  gsap.to(camera.position, {\n    x: newCamPos.x,\n    y: newCamPos.y,\n    z: newCamPos.z,\n    duration: 2,\n    ease: \"power2.inOut\",\n    onUpdate: () => {\n      controls.update();\n    },\n  });\n};\n\n/** ------------------------------------------------------------------\n *  (OPTIONAL) HELPER #1: Fly camera to a specific ISO code directly.\n * ------------------------------------------------------------------ */\n// This function is purely optional — it’s basically a convenience that\n// wraps getCountryCentroid and flyCameraToPoint together.\nexport function flyCameraToCountry({\n  camera,\n  controls,\n  globe,\n  isoA3,\n  dots,\n  distanceOffset = 300,\n}: {\n  camera: THREE.Camera;\n  controls: OrbitControlsImpl;\n  globe: THREE.Group;\n  isoA3: string;\n  dots: DotInfo[];\n  distanceOffset?: number;\n}) {\n  const centroid = getCountryCentroid({ isoA3, dots });\n  if (!centroid) return;\n  const worldPos = centroid.clone();\n  globe.localToWorld(worldPos);\n  flyCameraToPoint({\n    camera,\n    controls,\n    targetPos: worldPos,\n    distanceOffset,\n  });\n}\n\n/** ------------------------------------------------------------------\n *  (OPTIONAL) HELPER #2: Sort & get the nearest intersection from a pointer event.\n * ------------------------------------------------------------------ */\nexport function getNearestIntersection(\n  e: THREE.Event & { intersections?: THREE.Intersection[] }\n): THREE.Intersection | null {\n  if (!e.intersections || e.intersections.length === 0) {\n    return null;\n  }\n  // Sort by distance ascending\n  const sorted = e.intersections.sort((a, b) => a.distance - b.distance);\n  return sorted[0];\n}\n","import { useFrame } from \"@react-three/fiber\";\nimport {\n  PointerEvent,\n  RefObject,\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\nimport * as THREE from \"three\";\nimport { OrbitControls as OrbitControlsImpl } from \"three-stdlib\";\nimport { selectFocusIso } from \"../../../store/globeSlice\";\nimport { useAppSelector } from \"../../../store/hooks\";\nimport { DotInfo } from \"../../../types/earthTypes\";\nimport {\n  flyCameraToPoint,\n  getCountryCentroid,\n  getNearestIntersection,\n} from \"../utils/earthMath\";\n\nexport interface ContinentDotsProps {\n  jsonUrl: string;\n  pointSize: number;\n  onCountrySelect?: (iso: string) => void;\n  dotColor: string;\n  highlightColor?: string;\n  onLoaded?: (loaded: boolean) => void;\n  globeRef?: RefObject<THREE.Group | null>;\n  controlsRef?: RefObject<OrbitControlsImpl | null>;\n  cameraRef?: RefObject<THREE.Camera | null>;\n}\n\n/**\n * A point cloud representing countries on the globe.\n * - Fetches dot coordinates (x,y,z).\n * - Handles highlighting & rotation when focusIso changes.\n */\nconst ContinentDots = ({\n  jsonUrl,\n  pointSize,\n  onCountrySelect,\n  onLoaded,\n  dotColor,\n  highlightColor = \"#FFFF00\",\n  globeRef,\n  controlsRef,\n  cameraRef,\n}: ContinentDotsProps) => {\n  const focusIso = useAppSelector(selectFocusIso);\n  const [dots, setDots] = useState<DotInfo[]>([]);\n\n  // -------------------- Highlighting Logic --------------------\n  const highlightRef = useRef<string | null>(null);\n  const highlightTimerRef = useRef<NodeJS.Timeout | null>(null);\n\n  // -------------------- Pointer / Drag Detection --------------------\n  const pointerDownPositionRef = useRef<{ x: number; y: number } | null>(null);\n  const isDraggingRef = useRef<boolean>(false);\n  const pointerDownDotIndexRef = useRef<number | null>(null);\n\n  // -------------------- Pre-Converted Colors (Base & Highlight) --------------------\n  const [baseR, baseG, baseB] = useMemo(() => {\n    const color = new THREE.Color(dotColor);\n    return [color.r, color.g, color.b];\n  }, [dotColor]);\n\n  const [highlightR, highlightG, highlightB] = useMemo(() => {\n    const color = new THREE.Color(highlightColor);\n    return [color.r, color.g, color.b];\n  }, [highlightColor]);\n\n  // -------------------- Fetch Country Dots on Mount --------------------\n  useEffect(() => {\n    const fetchDots = async () => {\n      try {\n        const response = await fetch(jsonUrl);\n        const data: DotInfo[] = await response.json();\n        console.log(\"Loaded landDots.json:\", data);\n        setDots(data);\n        onLoaded?.(true);\n      } catch (err) {\n        console.error(\"Failed to load landDots.json:\", err);\n      }\n    };\n\n    fetchDots();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [jsonUrl]);\n\n  // -------------------- Fly to Country / Focus Handling --------------------\n  const handleFlyToIso = useCallback(\n    (isoCode: string) => {\n      if (!controlsRef?.current || !cameraRef?.current || !globeRef?.current) {\n        return;\n      }\n\n      // 1) Get the 3D centroid of that ISO\n      const centroidVec = getCountryCentroid({ isoA3: isoCode, dots });\n      if (!centroidVec) return;\n\n      // 2) Convert centroid from local space (globeRef) to world space\n      const worldPos = centroidVec.clone();\n      globeRef.current.localToWorld(worldPos);\n\n      // 3) Fly camera to the new position\n      flyCameraToPoint({\n        camera: cameraRef.current,\n        controls: controlsRef.current,\n        targetPos: worldPos,\n        distanceOffset: 300,\n      });\n    },\n    [cameraRef, controlsRef, globeRef, dots]\n  );\n\n  // Whenever focusIso changes, highlight + fly\n  useEffect(() => {\n    if (!focusIso || dots.length === 0) {\n      highlightRef.current = null;\n      return;\n    }\n    highlightRef.current = focusIso;\n\n    if (globeRef?.current) {\n      handleFlyToIso(focusIso);\n    }\n  }, [focusIso, dots, globeRef, handleFlyToIso]);\n\n  // -------------------- Geometry: Positions & Colors --------------------\n  const positions = useMemo(() => {\n    if (!dots.length) return new Float32Array(0);\n    const arr = dots.flatMap((d) => [d.x, d.y, d.z]);\n    return new Float32Array(arr);\n  }, [dots]);\n\n  const colors = useMemo(() => {\n    if (!dots.length) return new Float32Array(0);\n    // For each dot, push the base color\n    const arr: number[] = [];\n    for (let i = 0; i < dots.length; i++) {\n      arr.push(baseR, baseG, baseB);\n    }\n    return new Float32Array(arr);\n  }, [dots, baseR, baseG, baseB]);\n\n  // We'll store an explicit ref to the color attribute so we can update it each frame\n  const colorAttrRef = useRef<THREE.BufferAttribute>(null);\n\n  // -------------------- Pointer Events --------------------\n  const handlePointerDown = useCallback((event: PointerEvent) => {\n    pointerDownPositionRef.current = { x: event.clientX, y: event.clientY };\n    isDraggingRef.current = false;\n    pointerDownDotIndexRef.current = null;\n\n    const nearestIntersection = getNearestIntersection(event);\n    pointerDownDotIndexRef.current = nearestIntersection?.index ?? null;\n\n    event.stopPropagation();\n  }, []);\n\n  const handlePointerMove = useCallback((event: PointerEvent) => {\n    if (!pointerDownPositionRef.current) return;\n    const dx = event.clientX - pointerDownPositionRef.current.x;\n    const dy = event.clientY - pointerDownPositionRef.current.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    // If we moved the pointer a certain threshold, treat it as a drag\n    if (distance > 20) {\n      isDraggingRef.current = true;\n    }\n    event.stopPropagation();\n  }, []);\n\n  const handlePointerUp = useCallback(\n    (event: PointerEvent) => {\n      if (!dots.length || !pointerDownDotIndexRef.current) return;\n\n      // If there's no intersection, do nothing\n      const nearestIntersection = getNearestIntersection(event);\n      if (!nearestIntersection) return;\n\n      // Is the dot the same one we pointer-downed on?\n      if (\n        nearestIntersection.index !== pointerDownDotIndexRef.current ||\n        isDraggingRef.current\n      ) {\n        // We either dragged or clicked a different dot\n        pointerDownPositionRef.current = null;\n        pointerDownDotIndexRef.current = null;\n        return;\n      }\n\n      // We are clicking on the same dot\n      const idx = nearestIntersection.index;\n      const dot = dots[idx];\n      if (!dot) return;\n\n      console.log(\n        `Clicked dot #${idx} → Country=${dot.countryName}, ISO=${dot.isoA3}`\n      );\n\n      // 1) Fire onCountrySelect if needed\n      onCountrySelect?.(dot.isoA3);\n\n      // 2) Fly to it\n      handleFlyToIso(dot.isoA3);\n\n      // 3) Temporarily highlight this country\n      highlightRef.current = dot.isoA3;\n      if (highlightTimerRef.current) {\n        clearTimeout(highlightTimerRef.current);\n      }\n      highlightTimerRef.current = setTimeout(() => {\n        highlightRef.current = null;\n      }, 2000);\n\n      // Reset\n      pointerDownPositionRef.current = null;\n      pointerDownDotIndexRef.current = null;\n      isDraggingRef.current = false;\n      event.stopPropagation();\n    },\n    [dots, onCountrySelect, handleFlyToIso]\n  );\n\n  // -------------------- Animate the Dot Colors --------------------\n  useFrame(() => {\n    if (!colorAttrRef.current || !dots.length) return;\n    const colorArray = colorAttrRef.current.array as Float32Array;\n\n    for (let i = 0; i < dots.length; i++) {\n      const dot = dots[i];\n      const offset = i * 3;\n\n      // If dot isoA3 matches the highlightRef, use highlight color\n      if (highlightRef.current === dot.isoA3) {\n        colorArray[offset] = highlightR;\n        colorArray[offset + 1] = highlightG;\n        colorArray[offset + 2] = highlightB;\n      } else {\n        // revert to base color\n        colorArray[offset] = baseR;\n        colorArray[offset + 1] = baseG;\n        colorArray[offset + 2] = baseB;\n      }\n    }\n    colorAttrRef.current.needsUpdate = true;\n  });\n\n  // -------------------- Early return if no dots loaded --------------------\n  if (!dots.length) return null;\n\n  // -------------------- Render the Point Cloud --------------------\n  return (\n    <points\n      onPointerDown={handlePointerDown}\n      onPointerMove={handlePointerMove}\n      onPointerUp={handlePointerUp}\n    >\n      <bufferGeometry>\n        <bufferAttribute\n          attach=\"attributes-position\"\n          args={[positions, 3]}\n          count={positions.length / 3}\n          itemSize={3}\n        />\n        <bufferAttribute\n          ref={colorAttrRef}\n          attach=\"attributes-color\"\n          args={[colors, 3]}\n          count={colors.length / 3}\n          itemSize={3}\n        />\n      </bufferGeometry>\n      <pointsMaterial\n        vertexColors\n        size={pointSize}\n        sizeAttenuation\n        transparent\n        opacity={0.8}\n      />\n    </points>\n  );\n};\n\nexport default ContinentDots;\n","import { useFrame } from \"@react-three/fiber\";\nimport { useRef, useState } from \"react\";\nimport * as THREE from \"three\";\nimport { lerp } from \"three/src/math/MathUtils\";\nimport { AllArcsBehavior } from \"../../../types/earthTypes\";\nimport useAtOrAboveBreakpoint from \"../../../utils/useAtOrAboveBreakpoint\";\nimport ArcGroup, { ArcGroupProps } from \"./arcs/ArcGroup\";\nimport Atmosphere, { AtmosphereProps } from \"./Atmosphere\";\nimport BaseSphere from \"./BaseSphere\";\nimport CityMarkers, { CityMarkersProps } from \"./CityMarkerGroup\";\nimport ContinentDots, { ContinentDotsProps } from \"./ContinentDots\";\n\ninterface GlobeProps {\n  radius: number;\n  rotationSpeed: number;\n  isInteracting: boolean;\n  dots?: ContinentDotsProps;\n  atmosphere?: AtmosphereProps;\n  arcs?: ArcGroupProps & { persistArcBehavior: AllArcsBehavior };\n  cityMarkers?: CityMarkersProps;\n}\n\n/**\n * 3D Interactive Globe Component\n * - Features: Earth's sphere, atmosphere, continent dots, and animated arcs.\n * - Responsive Scaling: Adjusts based on breakpoints (XS, SM, MD).\n * - Animation: Handles rotation and smooth scaling after data loads.\n *\n * Props:\n * - radius: Base radius of the globe.\n * - rotationSpeed: Speed of Y-axis rotation (radians/frame).\n * - isInteracting: Pauses auto-rotation when true.\n * - dots: Configuration for continent dots.\n * - atmosphere: Atmospheric glow configuration.\n * - arcs: Flight arc animation configuration.\n */\nconst Globe = ({\n  radius,\n  rotationSpeed,\n  arcs,\n  atmosphere,\n  dots,\n  cityMarkers,\n  isInteracting,\n}: GlobeProps) => {\n  const globeRef = useRef<THREE.Group>(null);\n\n  // Breakpoints for final scale\n  const isMdUp = useAtOrAboveBreakpoint(\"md\");\n  const isSmUp = useAtOrAboveBreakpoint(\"sm\");\n  const isXSUp = useAtOrAboveBreakpoint(\"xs\");\n\n  let targetScale = 1.0;\n  if (isMdUp) {\n    targetScale = 1.0;\n  } else if (isSmUp) {\n    targetScale = 0.8;\n  } else if (isXSUp) {\n    targetScale = 0.7;\n  } else {\n    targetScale = 0.6;\n  }\n\n  const [currentScale, setCurrentScale] = useState(0.55);\n  const [dotsLoaded, setDotsLoaded] = useState(false);\n\n  useFrame((_, delta) => {\n    if (!globeRef.current) return;\n\n    // 1) Only rotate if not interacting\n    if (!isInteracting) {\n      globeRef.current.rotation.y += rotationSpeed;\n    }\n\n    // 2) If dots are loaded, lerp from 0 => targetScale\n    const scaleSpeed = 2.0;\n    setCurrentScale((prev) => lerp(prev, targetScale, delta * scaleSpeed));\n  });\n\n  return (\n    <group visible={dotsLoaded} ref={globeRef} scale={currentScale}>\n      <BaseSphere radius={radius - 1} />\n      {!!atmosphere && (\n        <Atmosphere\n          earthRadius={radius - 2}\n          color={atmosphere.color}\n          opacity={atmosphere.opacity}\n        />\n      )}\n      {!!dots && (\n        <ContinentDots\n          jsonUrl={dots.jsonUrl}\n          dotColor={dots.dotColor}\n          pointSize={dots.pointSize}\n          onLoaded={(isLoaded) => setDotsLoaded(isLoaded)}\n          globeRef={globeRef}\n          controlsRef={dots.controlsRef}\n          cameraRef={dots.cameraRef}\n        />\n      )}\n\n      {!!cityMarkers && (\n        <CityMarkers\n          cities={cityMarkers.cities}\n          radius={cityMarkers.radius}\n          color={cityMarkers.color}\n          markerSize={cityMarkers.markerSize}\n        />\n      )}\n      {!!arcs && (\n        <ArcGroup\n          animationDuration={arcs.animationDuration}\n          color={arcs.color}\n          locationArray={arcs.locationArray}\n          onAllArcsDone={arcs.onAllArcsDone}\n          onProgressPersist={arcs.onProgressPersist}\n          radius={arcs.radius}\n          sequential={arcs.sequential}\n          persistArcBehavior={arcs.persistArcBehavior}\n        />\n      )}\n    </group>\n  );\n};\n\nexport default Globe;\n","import { useFrame, useThree } from \"@react-three/fiber\";\nimport { useEffect, useRef } from \"react\";\nimport * as THREE from \"three\";\nimport { EffectComposer } from \"three/examples/jsm/postprocessing/EffectComposer\";\nimport { RenderPass } from \"three/examples/jsm/postprocessing/RenderPass\";\nimport { UnrealBloomPass } from \"three/examples/jsm/postprocessing/UnrealBloomPass\";\n\ninterface ManualBloomProps {\n  bloomStrength?: number;\n  bloomRadius?: number;\n  bloomThreshold?: number;\n}\n/**\n * A custom post-processing bloom effect that uses:\n * - `EffectComposer` to chain multiple post-processing passes.\n * - `RenderPass` for the base scene rendering.\n * - `UnrealBloomPass` for the bloom effect.\n *\n * @param {ManualBloomProps} props\n * @prop {number} [bloomStrength=0.7] - Controls brightness of bloom highlights.\n * @prop {number} [bloomRadius=0.5] - Determines how large or soft the bloom edges appear.\n * @prop {number} [bloomThreshold=0.0] - Threshold above which areas start to bloom.\n *\n * Rendering order (the second arg in `useFrame`) is set to 1 so the bloom\n * pass happens after the scene renders. Returns null since all rendering\n * is handled via EffectComposer.\n */\nconst ManualBloom = ({\n  bloomStrength = 0.7,\n  bloomRadius = 0.5,\n  bloomThreshold = 0.0,\n}: ManualBloomProps) => {\n  const composer = useRef<EffectComposer | null>(null);\n  const { gl, scene, camera, size } = useThree();\n\n  useEffect(() => {\n    // Create EffectComposer once on mount\n    const effectComposer = new EffectComposer(gl);\n    effectComposer.setSize(size.width, size.height);\n\n    // 1. Render pass (renders the scene normally)\n    const renderScene = new RenderPass(scene, camera);\n    effectComposer.addPass(renderScene);\n\n    // 2. UnrealBloomPass\n    const bloomPass = new UnrealBloomPass(\n      new THREE.Vector2(size.width, size.height),\n      bloomStrength, // strength (how bright the bloom is)\n      bloomRadius, // radius (how wide or soft the bloom edges are)\n      bloomThreshold // threshold (how bright an area must be before it blooms)\n    );\n    effectComposer.addPass(bloomPass);\n\n    composer.current = effectComposer;\n  }, [gl, scene, camera, size, bloomStrength, bloomRadius, bloomThreshold]);\n\n  // Render the composer on every frame\n  useFrame(() => {\n    composer.current?.render();\n  }, 1);\n\n  return null;\n};\n\nexport default ManualBloom;\n","import { RefObject, useEffect } from \"react\";\nimport * as THREE from \"three\";\nimport { EARTH_RADIUS } from \"./EarthScene\";\n\ninterface SceneHelpersProps {\n  axesHelperRef: RefObject<THREE.AxesHelper | null>;\n  cameraRef: RefObject<THREE.Camera | null>;\n}\n\nconst SceneHelpers = ({ axesHelperRef, cameraRef }: SceneHelpersProps) => {\n  useEffect(() => {\n    if (axesHelperRef.current) {\n      axesHelperRef.current.visible = true;\n    }\n  }, [axesHelperRef]);\n\n  return (\n    <>\n      <primitive\n        ref={axesHelperRef}\n        object={new THREE.AxesHelper(500).setColors(\"red\", \"white\", \"blue\")}\n      />\n      <gridHelper args={[1000, 50]} />\n      <primitive\n        object={\n          new THREE.BoxHelper(\n            new THREE.Mesh(new THREE.SphereGeometry(EARTH_RADIUS))\n          )\n        }\n      />\n      {cameraRef.current && (\n        <primitive object={new THREE.CameraHelper(cameraRef.current)} />\n      )}\n      <polarGridHelper args={[EARTH_RADIUS, 16, 8, 64]} />\n    </>\n  );\n};\n\nexport default SceneHelpers;\n","import { ArcLocation } from \"../../../types/earthTypes\";\n\nexport const flightPaths: ArcLocation[] = [\n  //\n  // Roundtrip: NYC -> Dallas -> NYC\n  //\n  {\n    start: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n    end: { lat: 32.7767, lon: -96.797, name: \"Dallas\" }, // Dallas\n  },\n  {\n    start: { lat: 32.7767, lon: -96.797, name: \"Dallas\" }, // Dallas\n    end: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n  },\n\n  //\n  // Roundtrip: NYC -> San Francisco -> NYC\n  //\n  {\n    start: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n    end: { lat: 37.7749, lon: -122.4194, name: \"San Francisco\" }, // San Francisco\n  },\n  {\n    start: { lat: 37.7749, lon: -122.4194, name: \"San Francisco\" }, // San Francisco\n    end: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n  },\n\n  //\n  // Roundtrip: NYC -> Louisville -> NYC\n  //\n  {\n    start: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n    end: { lat: 38.2527, lon: -85.7585, name: \"Louisville\" }, // Louisville\n  },\n  {\n    start: { lat: 38.2527, lon: -85.7585, name: \"Louisville\" }, // Louisville\n    end: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n  },\n\n  //\n  // Roundtrip: NYC -> Seattle -> NYC\n  //\n  {\n    start: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n    end: { lat: 47.6062, lon: -122.3321, name: \"Seattle\" }, // Seattle\n  },\n  {\n    start: { lat: 47.6062, lon: -122.3321, name: \"Seattle\" }, // Seattle\n    end: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n  },\n\n  //\n  // NYC -> Bogota -> Cumaral -> Cartagena -> NYC\n  //\n  {\n    start: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n    end: { lat: 4.711, lon: -74.0721, name: \"Bogota\" }, // Bogota\n  },\n  {\n    start: { lat: 4.711, lon: -74.0721, name: \"Bogota\" }, // Bogota\n    end: { lat: 4.2702, lon: -73.4772, name: \"Cumaral\" }, // Cumaral\n  },\n  {\n    start: { lat: 4.2702, lon: -73.4772, name: \"Cumaral\" }, // Cumaral\n    end: { lat: 10.391, lon: -75.4794, name: \"Cartagena\" }, // Cartagena\n  },\n  {\n    start: { lat: 10.391, lon: -75.4794, name: \"Cartagena\" }, // Cartagena\n    end: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n  },\n\n  //\n  // Roundtrip: NYC -> Destin -> NYC\n  //\n  {\n    start: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n    end: { lat: 30.3935, lon: -86.4958, name: \"Destin\" }, // Destin\n  },\n  {\n    start: { lat: 30.3935, lon: -86.4958, name: \"Destin\" }, // Destin\n    end: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n  },\n\n  //\n  // Roundtrip: NYC -> San Jose, CA -> NYC\n  //\n  {\n    start: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n    end: { lat: 37.3382, lon: -121.8863, name: \"San Jose, CA\" }, // San Jose, CA\n  },\n  {\n    start: { lat: 37.3382, lon: -121.8863, name: \"San Jose, CA\" }, // San Jose, CA\n    end: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n  },\n\n  //\n  // NYC -> Nashville -> Louisville -> NYC\n  //\n  {\n    start: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n    end: { lat: 36.1627, lon: -86.7816, name: \"Nashville\" }, // Nashville\n  },\n  {\n    start: { lat: 36.1627, lon: -86.7816, name: \"Nashville\" }, // Nashville\n    end: { lat: 38.2527, lon: -85.7585, name: \"Louisville\" }, // Louisville\n  },\n  {\n    start: { lat: 38.2527, lon: -85.7585, name: \"Louisville\" }, // Louisville\n    end: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n  },\n\n  //\n  // NYC -> London -> Zurich -> Copenhagen -> Bern -> NYC\n  //\n  {\n    start: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n    end: { lat: 51.5074, lon: -0.1278, name: \"London\" }, // London\n  },\n  {\n    start: { lat: 51.5074, lon: -0.1278, name: \"London\" }, // London\n    end: { lat: 47.3769, lon: 8.5417, name: \"Zurich\" }, // Zurich\n  },\n  {\n    start: { lat: 47.3769, lon: 8.5417, name: \"Zurich\" }, // Zurich\n    end: { lat: 55.6761, lon: 12.5683, name: \"Copenhagen\" }, // Copenhagen\n  },\n  {\n    start: { lat: 55.6761, lon: 12.5683, name: \"Copenhagen\" }, // Copenhagen\n    end: { lat: 46.948, lon: 7.4474, name: \"Bern\" }, // Bern\n  },\n  {\n    start: { lat: 46.948, lon: 7.4474, name: \"Bern\" }, // Bern\n    end: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n  },\n\n  //\n  // Roundtrip: NYC -> Reykjavik -> NYC\n  //\n  {\n    start: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n    end: { lat: 64.1466, lon: -21.9426, name: \"Reykjavik\" }, // Reykjavik\n  },\n  {\n    start: { lat: 64.1466, lon: -21.9426, name: \"Reykjavik\" }, // Reykjavik\n    end: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n  },\n\n  //\n  // Roundtrip: NYC -> Louisville -> NYC\n  //\n  {\n    start: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n    end: { lat: 38.2527, lon: -85.7585, name: \"Louisville\" }, // Louisville\n  },\n  {\n    start: { lat: 38.2527, lon: -85.7585, name: \"Louisville\" }, // Louisville\n    end: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n  },\n\n  //\n  // Roundtrip: NYC -> Louisville -> NYC (again)\n  //\n  {\n    start: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n    end: { lat: 38.2527, lon: -85.7585, name: \"Louisville\" }, // Louisville\n  },\n  {\n    start: { lat: 38.2527, lon: -85.7585, name: \"Louisville\" }, // Louisville\n    end: { lat: 40.7128, lon: -74.006, name: \"New York City\" }, // NYC\n  },\n];\n","import { useTheme } from \"@nextui-org/use-theme\";\nimport { OrbitControls } from \"@react-three/drei\";\nimport { Canvas } from \"@react-three/fiber\";\nimport { Suspense, useEffect, useRef, useState } from \"react\";\nimport * as THREE from \"three\";\nimport { OrbitControls as OrbitControlsImpl } from \"three-stdlib\";\nimport useAtOrAboveBreakpoint from \"../../utils/useAtOrAboveBreakpoint\";\nimport Globe from \"./layers/Globe\";\nimport ManualBloom from \"./layers/ManualBlooms\";\nimport SceneHelpers from \"./SceneHelpers\";\nimport { flightPaths } from \"./utils/flightPaths\";\n\nconst MAX_ZOOMED_OUT = 700;\nexport const EARTH_RADIUS = 150;\n\ninterface EarthSceneProps {\n  enableHelpers?: boolean;\n}\n\n/**\n * A top-level 3D Earth component that:\n * - Sets up a Three.js Canvas with OrbitControls and performance stats.\n * - Renders the `Globe` component and optional post-processing (ManualBloom).\n */\nconst EarthScene = ({ enableHelpers }: EarthSceneProps) => {\n  // Refs for Three.js objects\n  const controlsRef = useRef<OrbitControlsImpl>(null);\n  const axesHelperRef = useRef<THREE.AxesHelper | null>(null);\n  const cameraRef = useRef<THREE.Camera | null>(null);\n\n  const { theme, setTheme } = useTheme();\n\n  useEffect(() => {\n    if (theme !== \"dark\") {\n      setTheme(\"dark\");\n    }\n  }, [theme, setTheme]);\n\n  const isSmallUp = useAtOrAboveBreakpoint(\"sm\");\n  const jsonUrl = isSmallUp\n    ? \"/landDots-150rad-40k.json\" // more dots\n    : \"/landDots-150rad-30k.json\"; // fewer dots\n\n  const [isInteracting, setIsInteracting] = useState(false);\n  const resumeRotationTimeout = useRef<NodeJS.Timeout | null>(null);\n\n  const handleInteractionStart = () => {\n    // Clear any existing timeouts\n    if (resumeRotationTimeout.current) {\n      clearTimeout(resumeRotationTimeout.current);\n      resumeRotationTimeout.current = null;\n    }\n    setIsInteracting(true);\n  };\n\n  const handleInteractionEnd = () => {\n    // Wait 1 second before resuming\n    resumeRotationTimeout.current = setTimeout(() => {\n      setIsInteracting(false);\n    }, 1000);\n  };\n\n  const isXLUp = useAtOrAboveBreakpoint(\"xl\");\n  const isSmUp = useAtOrAboveBreakpoint(\"sm\");\n\n  return (\n    <Canvas\n      gl={{ alpha: true }}\n      style={{ background: \"transparent\" }}\n      camera={{ position: [0, 150, 900], fov: 35 }}\n      onCreated={(state) => {\n        cameraRef.current = state.camera; // Store camera reference\n        state.camera.updateProjectionMatrix();\n        const offsetX = isXLUp ? state.size.width * 0.2 : 0;\n        const offsetY = isSmUp ? 0 : state.size.height * 0.07;\n        state.camera.setViewOffset(\n          /* fullWidth  */ state.size.width,\n          /* fullHeight */ state.size.height,\n          /* offsetX    */ offsetX,\n          /* offsetY    */ offsetY,\n          /* width      */ state.size.width,\n          /* height     */ state.size.height\n        );\n\n        state.raycaster.params.Points.threshold = 2;\n      }}\n    >\n      <OrbitControls\n        ref={controlsRef}\n        enableDamping={true}\n        minDistance={300}\n        minPolarAngle={0.3} // ~17 degrees\n        maxPolarAngle={Math.PI - 0.3} // ~163 degrees\n        enablePan={false}\n        maxDistance={MAX_ZOOMED_OUT}\n        onStart={handleInteractionStart}\n        onEnd={handleInteractionEnd}\n      />\n      <ambientLight intensity={1} />\n      <hemisphereLight intensity={0.2} position={[0, 50, 0]} />\n      <Suspense fallback={null}>\n        <Globe\n          isInteracting={isInteracting}\n          rotationSpeed={0.001}\n          radius={EARTH_RADIUS}\n          dots={{\n            dotColor: \"#00aaff\",\n            pointSize: 2.5,\n            jsonUrl,\n            controlsRef,\n            cameraRef,\n          }}\n          atmosphere={{\n            color: \"#00aaff\",\n            opacity: 0.03, // I fear this isn't hooked up to anything\n            earthRadius: EARTH_RADIUS,\n          }}\n          arcs={{\n            locationArray: flightPaths,\n            color: \"#dd6ff0\",\n            radius: EARTH_RADIUS,\n            animationDuration: 700,\n            sequential: false,\n            onProgressPersist: true,\n            onAllArcsDone: \"persist\",\n            persistArcBehavior: undefined,\n          }}\n          cityMarkers={{\n            cities: flightPaths.map((f) => ({\n              lat: f.end.lat,\n              lon: f.end.lon,\n              name: f.end.name,\n            })),\n            radius: EARTH_RADIUS,\n            color: \"#dd6ff0\",\n            markerSize: 1,\n          }}\n        />\n        <ManualBloom bloomStrength={1.2} bloomRadius={1} bloomThreshold={0.3} />\n      </Suspense>\n      {enableHelpers && (\n        <SceneHelpers axesHelperRef={axesHelperRef} cameraRef={cameraRef} />\n      )}\n    </Canvas>\n  );\n};\n\nexport default EarthScene;\n","import { Button } from \"@nextui-org/react\";\nimport Flag from \"react-flagpack\";\nimport { setFocusIso } from \"../../store/globeSlice\";\nimport { useAppDispatch } from \"../../store/hooks\";\n\ninterface CountryButtonProps {\n  isos: string[] /** Must be alpha-3 */;\n}\nconst CountryButtons = ({ isos }: CountryButtonProps) => {\n  const dispatch = useAppDispatch();\n  const handleClick = (iso: string) => {\n    dispatch(setFocusIso(iso));\n  };\n  return (\n    <>\n      {isos.map((iso) => (\n        <Button\n          size=\"md\"\n          variant=\"light\"\n          key={iso}\n          isIconOnly\n          onPress={() => handleClick(iso)}\n        >\n          <Flag code={iso} hasBorder={false} size=\"l\" />\n        </Button>\n      ))}\n    </>\n  );\n};\n\nexport default CountryButtons;\n","import EarthScene from \"../../components/earth/EarthScene\";\nimport Typewriter from \"../../components/Typewriter\";\nimport CountryButtons from \"./CountryButtons\";\n\nconst TheGlobeProject = () => {\n  return (\n    <div className=\"relative w-screen h-screen overflow-hidden\">\n      {/* Full-screen Earth in the background */}\n      <div className=\"absolute inset-0 pointer-events-auto\">\n        <EarthScene />\n      </div>\n      {/* Right half overlay (non-blocking by default) */}\n      <div className=\"flex absolute top-0 right-0 w-full sm:w-1/2 h-full items-end sm:items-center justify-center pointer-events-none z-10\">\n        {/* Make the actual text clickable */}\n        <div className=\"flex flex-col pointer-events-auto text-2xl items-center px-2 pb-8 sm:text-4xl sm:flex-start sm:pb-0 sm:px-0\">\n          <div className=\"flex mb-2 sm:mb-4\">\n            <Typewriter\n              phrases={[\n                \"2024 Travel:\",\n                \"2024 Travel: 3 continents\",\n                \"2024 Travel: 5 countries\",\n                \"2024 Travel: X cities\",\n              ]}\n              loop={false}\n              typingSpeed={100}\n              deletingSpeed={50}\n            />\n          </div>\n          <div className=\"flex flex-row gap-2\">\n            <CountryButtons isos={[\"CHE\", \"ISL\", \"COL\", \"GBR\", \"USA\"]} />\n          </div>\n          <p className=\"text-medium sm:text-xl mt-2 max-w-md text-left\">\n            Looking back on a year of travel and adventure.\n          </p>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default TheGlobeProject;\n","import { useParams } from \"react-router-dom\";\nimport TheGlobeProject from \"../../projects/globe-project/TheGlobeProjects\";\n\nconst ProjectDetails = () => {\n  const { projectSlug } = useParams();\n\n  switch (projectSlug) {\n    case \"earth\":\n      return <TheGlobeProject />;\n    default:\n      return <div>Oops! Project not found.</div>;\n  }\n};\n\nexport default ProjectDetails;\n","import { useEffect, useState } from \"react\";\n\n// Tailwind's default breakpoints in pixels\nconst BREAKPOINTS = {\n  xs: 320,\n  sm: 640,\n  md: 768,\n  lg: 1024,\n  xl: 1280,\n  \"2xl\": 1536,\n};\n\ntype TailwindBreakpoint = keyof typeof BREAKPOINTS;\n\n/**\n * Usage:\n *   const isLargeUp = useTailwindBreakpoint(\"lg\");\n *   // returns true if window width >= 1024\n */\nconst useAtOrAboveBreakpoint = (breakpoint: TailwindBreakpoint) => {\n  const [matches, setMatches] = useState(false);\n\n  useEffect(() => {\n    function handleResize() {\n      const newMatches = window.innerWidth >= BREAKPOINTS[breakpoint];\n      // Only update state if the value actually changed\n      setMatches((old) => {\n        if (old !== newMatches) {\n          return newMatches;\n        }\n        return old;\n      });\n    }\n\n    window.addEventListener(\"resize\", handleResize);\n    handleResize();\n    return () => window.removeEventListener(\"resize\", handleResize);\n  }, [breakpoint]);\n\n  return matches;\n};\n\nexport default useAtOrAboveBreakpoint;\n"],"names":["_ref","_phrases$index","phrases","period","typingSpeed","deletingSpeed","loop","preserveTrailingNewlines","phase","setPhase","useState","index","setIndex","charIndex","setCharIndex","linkColor","useLinkColor","useEffect","isLastPhrase","length","currentPhrase","nextPhrase","overlapLength","a","b","i","findPrefixOverlap","rawOverlapLength","leftover","slice","test","preserveTrailingNewlinesInOverlap","nextChar","currentTypingSpeed","timeoutId","setTimeout","c","clearTimeout","pauseId","prevChar","currentDeletingSpeed","display","_jsxs","children","text","split","map","segment","arr","_jsx","className","concat","styles","style","borderColor","latLongToVector3","lat","lon","radius","phi","Math","PI","theta","x","sin","cos","z","y","THREE","flights","color","behavior","opacity","setOpacity","elapsed","flickerInterval","totalDuration","intervalId","setInterval","random","clearInterval","frameId","startTime","performance","now","duration","animate","t","min","requestAnimationFrame","cancelAnimationFrame","arcGeometries","useMemo","flight","buildAllArcs","startLat","startLon","endLat","endLon","startVec","endVec","midPoint","addVectors","multiplyScalar","arcHeight","distanceTo","setLength","control1","lerpVectors","control2","curve","start","end","_Fragment","geometry","transparent","position","onDone","groupRef","useRef","dotRef","ringRef","FINAL_SCALE","dotScale","setDotScale","ringScale","setRingScale","ringOpacity","setRingOpacity","lengthSq","normal","clone","normalize","zAxis","quat","setFromUnitVectors","current","quaternion","copy","useFrame","newRingScale","ref","scale","args","side","depthTest","PartialCurve","constructor","baseCurve","minT","maxT","super","this","getPoint","optionalTarget","u","animationDuration","onProgressPersist","meshRef","geometryRef","done","setDone","showLandingEffect","setShowLandingEffect","fullCurve","tubeGeometry","indexCount","count","attributes","drawCount","floor","setDrawRange","extendP","retractP","startParam","endParam","visible","partialCurve","newGeom","dispose","object","attach","LandingEffect","locationArray","sequential","onAllArcsDone","persistArcBehavior","currentArcIndex","setCurrentArcIndex","arcsDoneCount","setArcsDoneCount","arcsCompleted","setArcsCompleted","Array","fill","showFinalArcs","setShowFinalArcs","ArcLight","prev","AllArcsStaticMesh","AtmosphereShader","uniforms","uColor","value","uIntensity","uPower","vertexShader","fragmentShader","earthRadius","depthWrite","_objectSpread","emissive","emissiveIntensity","roughness","markerSize","PulseRing","baseRadius","_ref2","state","delta","userData","set","material","cities","uniqueCities","Map","city","name","from","values","CityMarker","useAppSelector","useSelector","getCountryCentroid","isoA3","dots","countryDots","filter","d","sumX","sumY","sumZ","flyCameraToPoint","camera","controls","targetPos","distanceOffset","newCamPos","gsap","to","ease","onUpdate","update","getNearestIntersection","e","intersections","sort","distance","jsonUrl","pointSize","onCountrySelect","onLoaded","dotColor","highlightColor","globeRef","controlsRef","cameraRef","focusIso","selectFocusIso","setDots","highlightRef","highlightTimerRef","pointerDownPositionRef","isDraggingRef","pointerDownDotIndexRef","baseR","baseG","baseB","r","g","highlightR","highlightG","highlightB","async","response","fetch","data","json","console","log","err","error","fetchDots","handleFlyToIso","useCallback","isoCode","centroidVec","worldPos","localToWorld","positions","Float32Array","flatMap","colors","push","colorAttrRef","handlePointerDown","event","_nearestIntersection$","clientX","clientY","nearestIntersection","stopPropagation","handlePointerMove","dx","dy","sqrt","handlePointerUp","idx","dot","countryName","colorArray","array","offset","needsUpdate","onPointerDown","onPointerMove","onPointerUp","itemSize","vertexColors","size","sizeAttenuation","rotationSpeed","arcs","atmosphere","cityMarkers","isInteracting","isMdUp","useAtOrAboveBreakpoint","isSmUp","isXSUp","targetScale","currentScale","setCurrentScale","dotsLoaded","setDotsLoaded","_","rotation","lerp","BaseSphere","Atmosphere","ContinentDots","isLoaded","CityMarkers","ArcGroup","bloomStrength","bloomRadius","bloomThreshold","composer","gl","scene","useThree","effectComposer","EffectComposer","setSize","width","height","renderScene","RenderPass","addPass","bloomPass","UnrealBloomPass","_composer$current","render","axesHelperRef","setColors","EARTH_RADIUS","flightPaths","enableHelpers","theme","setTheme","useTheme","setIsInteracting","resumeRotationTimeout","isXLUp","Canvas","alpha","background","fov","onCreated","updateProjectionMatrix","offsetX","offsetY","setViewOffset","raycaster","params","Points","threshold","OrbitControls","enableDamping","minDistance","minPolarAngle","maxPolarAngle","enablePan","maxDistance","onStart","handleInteractionStart","onEnd","handleInteractionEnd","intensity","Suspense","fallback","Globe","undefined","f","ManualBloom","SceneHelpers","isos","dispatch","useDispatch","iso","Button","variant","isIconOnly","onPress","setFocusIso","handleClick","Flag","code","hasBorder","TheGlobeProject","EarthScene","Typewriter","CountryButtons","ProjectDetails","projectSlug","useParams","BREAKPOINTS","xs","sm","md","lg","xl","breakpoint","matches","setMatches","handleResize","newMatches","window","innerWidth","old","addEventListener","removeEventListener"],"sourceRoot":""}